<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>【尚硅谷】MySQL-索引的数据结构 | 時光</title><meta name="keywords" content="SQL,尚硅谷"><meta name="author" content="時光"><meta name="copyright" content="時光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="【尚硅谷】MySQL-索引的数据结构"><meta name="application-name" content="【尚硅谷】MySQL-索引的数据结构"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="【尚硅谷】MySQL-索引的数据结构"><meta property="og:url" content="https://blog.shiguang666.eu.org/2024/09/20/4ee543fd05bd/index.html"><meta property="og:site_name" content="時光"><meta property="og:description" content="在线视频:MySQL数据库入门到大牛，mysql安装到优化，百科全书级，全网天花板官方资料: 尚硅谷MySQL入门到高级-宋红康版 代码仓库Gitee：https:&amp;#x2F;&amp;#x2F;gitee.com&amp;#x2F;an_shiguang&amp;#x2F;learn-mysql  为什么使用索引索引是存储引擎用于快速找到数据记录的一种数据结"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg"><meta property="article:author" content="時光"><meta property="article:tag" content="博客,時光,時光的博客,時光博客园子,实用博客,开源,共享"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg"><meta name="description" content="在线视频:MySQL数据库入门到大牛，mysql安装到优化，百科全书级，全网天花板官方资料: 尚硅谷MySQL入门到高级-宋红康版 代码仓库Gitee：https:&amp;#x2F;&amp;#x2F;gitee.com&amp;#x2F;an_shiguang&amp;#x2F;learn-mysql  为什么使用索引索引是存储引擎用于快速找到数据记录的一种数据结"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.shiguang666.eu.org/2024/09/20/4ee543fd05bd/"><link rel="preconnect" href="//cdn.cbd.int"><meta name="google-site-verification" content="xxx"><meta name="baidu-site-verification" content="code-xxx"><meta name="msvalidate.01" content="xxx"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与各类博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.shiguangdev.eu.org',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🌟 技术分享领航人","📚 终身学习倡导者","💡 创新思维启发源","📈 成长路径引路人","🚀 科技趋势探索者","🤖️ AI技术探索先锋","🌈 技术创新推动手","💬 社区互动活跃家","🛠️ 代码经验传授师","📢 知识传播倡导员"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":300,"languages":{"author":"作者: 時光","link":"链接: ","source":"来源: 時光","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '時光',
  title: '【尚硅谷】MySQL-索引的数据结构',
  postAI: '',
  pageFillDescription: '为什么使用索引, 索引及其优缺点, 索引概述, 优点, 缺点, InnoDB中索引的推演, 索引之前的查找, 在一个页中的查找, 在很多页中查找, 设计索引, 一个简单的索引设计方案, 数据页的连续性, InnoDB中的索引方案, ①  迭代1次：目录项纪录的页, ② 迭代2次：多个目录项纪录的页, ③ 迭代3次：目录项记录页的目录页, ④ B+Tree, 常见索引概念, 聚簇索引, 二级索引（辅助索引、非聚簇索引）, 联合索引, InnoDB的B+树索引的注意事项, 1. 根页面位置万年不动, 2. 内节点中目录项记录的唯一性, 3. 一个页面最少存储 2 条记录, MyISAM中的索引方案, MyISAM索引的原理, MyISAM 与 InnoDB对比, 索引的代价, MySQL数据结构选择的合理性, 全表查询, Hash查询, 加快查找速度的数据结构常见的有两类, Hash结构效率高那为什么索引结构要设计成树型呢？, Hash索引的适用性, 二叉搜索树, 二叉搜索树的特点, 查找规则, 平衡树（AVL树）, B-Tree, B+Tree, R树, 附录：算法的时间复杂度, 常见的时间复杂度, 如何计算时间复杂度, 总结在线视频数据库入门到大牛安装到优化百科全书级全网天花板官方资料尚硅谷入门到高级宋红康版代码仓库为什么使用索引索引是存储引擎用于快速找到数据记录的一种数据结构就好比一本教科书的目录部分通过目录中找到对应文章的页码便可快速定位到需要的文章中也是一样的道理进行数据查找时首先查看查询条件是否命中某条索引符合则通过索引查找相关数据如果不符合则需要全表扫描即需要一条一条地查找记录直到找到与条件符合的记录如上图所示数据库没有索引的情况下数据分布在硬盘不同的位置上面读取数据时摆臂需要前后摆动查询数据这样操作非常消耗时间如果数据顺序摆放那么也需要从到行按顺序读取这样就相当于进行了次操作依旧非常耗时如果我们不借助任何索引结构帮助我们快速定位数据的话我们查找这条记录就要逐行去查找去比较从开始进行比较发现不是继续下一行我们当前的表只有不到行数据但如果表很大的话有上千万条数据就意味着要做很多很多次硬盘才能找到现在要查找这条记录必须先去磁盘查找这条记录找到之后加载到内存再对数据进行处理这个过程最耗时间就是磁盘涉及到磁盘的旋转时间速度较快磁头的寻道时间速度慢费时假如给数据使用二叉树这样的数据结构进行存储如下图所示对字段添加了索引就相当于在硬盘上为维护了一个索引的数据结构即这个二叉搜索树二叉搜索树的每个结点存储的是结构是是该所在行的文件指针地址比如该二叉搜索树的根节点就是现在对添加了索引这时再去查找这条记录的时候会先去查找该二叉搜索树二叉树的遍历查找读到内存继续右侧数据读到内存找到数据返回找到之后就根据当前结点的快速定位到要查找的记录对应的地址我们可以发现只需要查找两次就可以定位到记录的地址查询速度就提高了这就是我们为什么要建索引目的就是为了减少磁盘的次数加快查询速率索引及其优缺点索引概述官方对索引的定义为索引是帮助高效获取数据的数据结构索引的本质索引是数据结构你可以简单理解为排好序的快速查找数据结构满足特定查找算法这些数据结构以某种方式指向数据这样就可以在这些数据结构的基础上实现高级查找算法索引是在存储引擎中实现的因此每种存储引擎的索引不一定完全相同并且每种存储引擎不一定支持所有索引类型同时存储引擎可以定义每个表的最大索引数和最大索引长度所有存储引擎支持每个表至少个索引总索引长度至少为字节有些存储引擎支持更多的索引数和更大的索引长度优点类似大学图书馆建书目索引提高数据检索的效率降低数据库的成本这也是创建索引最主要的原因通过创建唯一索引可以保证数据库表中每一行数据的唯一性在实现数据的参考完整性方面可以加速表和表之间的连接换句话说对于有依赖关系的子表和父表联合查询时可以提高查询速度在使用分组和排序子句进行数据查询时可以显著减少查询中分组和排序的时间降低了的消耗缺点增加索引也有许多不利的方面主要表现在如下几个方面创建索引和维护索引要耗费时间并且随着数据量的增加所耗费的时间也会增加索引需要占磁盘空间除了数据表占数据空间之外每一个索引还要占一定的物理空间存储在磁盘上如果有大量的索引索引文件就可能比数据文件更快达到最大文件尺寸虽然索引大大提高了查询速度同时却会降低更新表的速度当对表中的数据进行增加删除和修改的时候索引也要动态地维护这样就降低了数据的维护速度因此选择使用索引时需要综合考虑索引的优点和缺点因此选择使用索引时需要综合考虑索引的优点和缺点提示索引可以提高查询的速度但是会影响插入记录的速度这种情况下最好的办法是先删除表中的索引然后插入数据插入完成后再创建索引中索引的推演索引之前的查找先来看一个精确匹配的例子列名列表表名列名在一个页中的查找在中数据页是存储引擎如用于存储数据的基本单位数据页是磁盘和内存之间数据交换的基本单位通常大小为假设目前表中的记录比较少所有的记录都可以被存放到一个页中在查找记录的时候可以根据搜索条件的不同分为两种情况以主键为搜索条件可以在页目录中使用二分法快速定位到对应的槽然后再遍历该槽对用分组中的记录即可快速找到指定记录以其他列作为搜索条件因为在数据页中并没有对非主键列简历所谓的页目录所以我们无法通过二分法快速定位相应的槽这种情况下只能从最小记录开始依次遍历单链表中的每条记录然后对比每条记录是不是符合搜索条件很显然这种查找的效率是非常低的在很多页中查找在很多页中查找记录的活动可以分为两个步骤定位到记录所在的页从所在的页内中查找相应的记录在没有索引的情况下不论是根据主键列或者其他列的值进行查找由于我们并不能快速的定位到记录所在的页所以只能从第一个页沿着双向链表一直往下找在每一个页中根据我们上面的查找方式去查找指定的记录因为要遍历所有的数据页所以这种方式显然是超级耗时的如果一个表有一亿条记录呢此时索引应运而生设计索引建一个表这个新建的表中有个类型的列个类型的列而且我们规定了列为主键这个表使用行格式来实际存储记录的这里我们简化了表的行格式示意图我们只在示意图里展示记录的这几个部分记录头信息的一项属性表示记录的类型表示普通记录表示最小记录表示最大记录暂时还没用过下面讲记录头信息的一项属性表示下一条地址相对于本条记录的地址偏移量我们用箭头来表明下一条记录是谁各个列的值这里只记录在表中的三个列分别是和其他信息除了上述种信息以外的所有信息包括其他隐藏列的值以及记录的额外信息将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样把一些记录放到页里的示意图就是一个简单的索引设计方案数据页的连续性数据页内的连续性在同一个数据页内数据行通常是连续存储的每个数据行按照一定的格式存储在数据页的行数据区域中数据页内的数据行按照插入顺序存储新插入的数据行会优先使用数据页中的空闲空间数据页间的连续性数据页之间通常不是连续存储的使用树结构来组织数据页每个数据页通过指针相互连接树的叶子节点数据页通过双向链表连接形成一个有序的数据页链表我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢因为各个页中的记录并没有规律我们并不知道我们的搜索条件匹配哪些页中的记录所以不得不依次遍历所有的数据页所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办我们可以为快速定位记录所在的数据页而建立一个目录建这个目录必须完成下边这些事下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值假设每个数据结构最多能存放条记录实际上一个数据页非常大可以存放下好多记录那么这些记录以及按照主键值的大小串联成一个单向链表了如图所示从图中可以看出来表中的条记录都被插入到了编号为的数据页中了此时我们再来插入一条记录因为页最多只能放条记录所以我们不得不再分配一个新页注意新分配的数据页编号可能并不是连续的它们只是通过维护者上一个页和下一个页的编号而建立了链表关系另外页中用户记录最大的主键值是而页中有一条记录的主键值是因为所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求所以在插入主键值为的记录的时候需要伴随着一次记录移动也就是把主键值为的记录移动到页中然后再把主键值为的记录插入到页中这个过程的示意图如下这个过程表明了在对页中的记录进行增删改查操作的过程中我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值这个过程称为页分裂给所有的页建立一个目录项由于数据页的编号可能是不连续的所以在向表中插入许多条记录后可能是这样的效果我们需要给它们做个目录每个页对应一个目录项每个目录项包括下边两个部分页的用户记录中最小的主键值我们用来表示页号我们用表示以页为例它对应目录项这个目录项中包含着该页的页号以及该页中用户记录的最小主键值我们只需要把几个目录项在物理存储器上连续存储比如数组就可以实现根据主键值快速查找某条记录的功能了比如查找主键值为的记录具体查找过程分两步先从目录项中根据二分法快速确定出主键值为的记录在目录项中因为它对应的页是页再根据前边说的在页中查找记录的方式去页中定位具体的记录至此针对数据页做的简易目录就搞定了这个目录有一个别名称为索引中的索引方案迭代次目录项纪录的页怎么区分一条记录是普通的用户记录还是目录项记录呢使用记录头信息里的属性它的各自取值代表的意思如下普通的用户记录目录项记录最小记录最大记录我们把前边使用到的目录项放到数据页中的样子就是这样从图中可以看出来我们新分配了一个编号为的页来专门存储目录项记录这里再次强调目录项记录和普通的用户记录的不同点目录项记录的值是而普通用户记录的值是目录项记录只有主键值和页的编号两个列而普通的用户记录的列是用户自己定义的可能包含很多列另外还有自己添加的隐藏列了解记录头信息里还有一个叫的属性只有在存储目录项记录的页中的主键值最小的目录项记录的值为其他别的记录的值都是相同点两者用的是一样的数据页都会为主键值生成页目录从而在按照主键值进行查找时可以使用二分法来加快查询速度现在以查找主键为的记录为例根据某个主键值去查找记录的步骤就可以大致拆分成下边两步先到存储目录项记录的页也就是页中通过二分法快速定位到对应目录项因为所以定位到对应的记录所在的页就是页再到存储用户记录的页中根据二分法快速定位到主键值为的用户记录迭代次多个目录项纪录的页从图中可以看出我们插入了一条主键值为的用户记录之后需要两个新的数据页为存储该用户记录而新生成了页因为原先存储目录项记录的页的容量已满我们前边假设只能存储条目录项记录所以不得不需要一个新的页来存放页对应的目录项现在因为存储目录项记录的页不止一个所以如果我们想根据主键值查找一条用户记录大致需要个步骤以查找主键值为的记录为例确定目录项记录页我们现在的存储目录项记录的页有两个即页和页又因为页表示的目录项的主键值的范围是页表示的目录项的主键值不小于所以主键值为的记录对应的目录项记录在页中通过目录项记录页确定用户记录真实所在的页在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了在真实存储用户记录的页中定位到具体的记录迭代次目录项记录页的目录页如果我们表中的数据非常多则会产生很多存储目录项记录的页那我们怎么根据主键值快速定位一个存储目录项记录的页呢那就为这些存储目录项记录的页再生成一个更高级的目录就像是一个多级目录一样大目录里嵌套小目录小目录里才是实际的数据所以现在各个页的示意图就是这样子如图我们生成了一个存储更高级目录项的页这个页中的两条记录分别代表页和页如果用户记录的主键值在之间则到页中查找更详细的目录项记录如果主键值不小于的话就到页中查找更详细的目录项记录我们可以用下边这个图来描述它这个数据结构它的名称是树一个树的节点其实可以分成好多层规定最下边的那层也就是存放我们用户记录的那层为第层之后依次往上加之前我们做了一个非常极端的假设存放用户记录的页最多存放条记录存放目录项记录的页最多存放条记录其实真实环境中一个页存放的记录数量是非常大的假设所有存放用户记录的叶子节点代表的数据页可以存放条用户记录所有存放目录项记录的内节点代表的数据页可以存放条目录项记录那么如果树只有层也就是只有个用于存放用户记录的节点最多能存放条记录如果树有层最多能存放条记录如果树有层最多能存放条记录如果树有层最多能存放条记录相当多的记录你的表里能存放条记录吗所以一般情况下我们用到的树都不会超过层那我们通过主键值去查找某条记录最多只需要做个页面内的查找查找个目录项页和一个用户记录页又因为在每个页面内有所谓的页目录所以在页面内也可以通过二分法实现快速定位记录常见索引概念索引按照物理实现方式索引可以分为种聚簇聚集和非聚簇非聚集索引我们也把非聚集索引称为二级索引或者辅助索引聚簇索引聚簇索引并不是一种单独的索引类型而是一种数据存储方式所有的用户记录都存储在了叶子结点也就是所谓的索引即数据数据即索引术语聚簇表示当前数据行和相邻的键值聚簇的存储在一起特点使用记录主键值的大小进行记录和页的排序这包括三个方面的含义页内的记录是按照主键的大小顺序排成一个单向链表各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表存放目录项记录的页分为不同的层次在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表树的叶子节点存储的是完整的用户记录所谓完整的用户记录就是指这个记录中存储了所有列的值包括隐藏列我们把具有这两种特性的树称为聚簇索引所有完整的用户记录都存放在这个聚簇索引的叶子节点处这种聚簇索引并不需要我们在语句中显式的使用语句去创建存储引擎会自动的为我们创建聚簇索引优点数据访问更快因为聚簇索引将索引和数据保存在同一个树中因此从聚簇索引中获取数据比非聚簇索引更快聚簇索引对于主键的排序查找和范围查找速度非常快按照聚簇索引排列顺序查询显示一定范围数据的时候由于数据都是紧密相连数据库不用从多个数据块中提取数据所以节省了大量的操作缺点插入速度严重依赖于插入顺序按照主键的顺序插入是最快的方式否则将会出现页分裂严重影响性能因此对于表我们一般都会定义一个自增的列为主键更新主键的代价很高因为将会导致被更新的行移动因此对于表我们一般定义主键为不可更新二级索引访问需要两次索引查找第一次找到主键值第二次根据主键值找到行数据限制对于数据库目前只有数据引擎支持聚簇索引而并不支持聚簇索引由于数据物理存储排序方式只能有一种所以每个的表只能有一个聚簇索引一般情况下就是该表的主键如果没有定义主键会选择非空的唯一索引代替如果没有这样的索引会隐式的定义一个主键来作为聚簇索引为了充分利用聚簇索引的聚簇的特性所以表的主键列尽量选用有序的顺序而不建议用无序的比如字符串列作为主键无法保证数据的顺序增长二级索引辅助索引非聚簇索引上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用因为树中的数据都是按照主键进行排序的那如果我们想以别的列作为搜索条件该怎么办肯定不能是从头到尾沿着链表依次遍历记录一遍答案我们可以多建几颗树不同的树中的数据采用不同的排列规则比方说我们用列的大小作为数据页页中记录的排序规则再建一课树效果如下图所示这个树与上边介绍的聚簇索引有几处不同使用记录列的大小进行记录和页的排序这包括三个方面的含义页内的记录是按照列的大小顺序排成一个单向链表各个存放用户记录的页也是根据页中记录的列大小顺序排成一个双向链表存放目录项记录的页分为不同的层次在同一层次中的页也是根据页中目录项记录的列大小顺序排成一个双向链表树的叶子节点存储的并不是完整的用户记录而只是列主键这两个列的值目录项记录中不再是主键页号的搭配而变成了列页号的搭配所以如果我们现在想通过列的值查找某些记录的话就可以使用我们刚刚建好的这个树了以查找列的值为的记录为例查找过程如下确定目录项记录页根据根页面也就是页可以快速定位到目录项记录所在的页为页因为通过目录项记录页确定用户记录真实所在的页在页中可以快速定位到实际存储用户记录的页但是由于列并没有唯一性约束所以列值为的记录可能分布在多个数据页中又因为所以确定实际存储用户记录的页在页和页中在真实存储用户记录的页中定位到具体的记录到页和页中定位到具体的记录但是这个树的叶子节点中的记录只存储了和主键两个列所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录说明按照列的大小作为数据页根据列的大小进行排序数据页中仅包含列和主键列如果要查询非列的数据需要再根据记录的主键即列去聚簇索引获取回表概念我们根据这个以列大小排序的树只能确定我们要查找记录的主键值所以如果我们想根据列的值查找到完整的用户记录的话仍然需要到聚簇索引中再查一遍这个过程称为回表也就是根据列的值查询一条完整的用户记录需要使用到棵树问题为什么我们还需要一次回表操作呢直接把完整的用户记录放到叶子节点不吗如果把完整的用户记录放到叶子结点是可以不用回表但是太占地方了相当于每建立一课树都需要把所有的用户记录再都拷贝一遍这就有点太浪费存储空间了因为这种按照非主键列建立的树需要一次回表操作才可以定位到完整的用户记录所以这种树也被称为二级索引英文名或者辅助索引由于使用的是列的大小作为树的排序规则所以我们也称这个树为列建立的索引非聚簇索引的存在不影响数据在聚簇索引中的组织所以一张表可以有多个非聚簇索引小结聚簇索引与非聚簇索引的原理不同在使用上也有一些区别聚簇索引的叶子节点存储的就是我们的数据记录非聚簇索引的叶子节点存储的是数据位置非聚簇索引不会影响数据表的物理存储顺序一个表只能有一个聚簇索引因为只能有一种排序存储的方式但可以有多个非聚簇索引也就是多个索引目录提供数据检索使用聚簇索引的时候数据的查询效率高但如果对数据进行插入删除更新等操作效率会比非聚簇索引低联合索引我们也可以同时以多个列的大小作为排序规则也就是同时为多个列建立索引比方说我们想让树按照和列的大小进行排序这个包含两层含义先把各个记录和页按照列进行排序在记录的列相同的情况下采用列进行排序为和建立的索引的示意图如下如图所示我们需要注意以下几点每条目录项都有页号这三个部分组成各条记录先按照列的值进行排序如果记录的列相同则按照列的值进行排序树叶子节点处的用户记录由和主键列组成注意一点以和列的大小为排序规则建立的树称为联合索引本质上也是一个二级索引它的意思与分别为和列分别建立索引的表述是不同的不同点如下建立联合索引只会建立如上图一样的棵树为和列分别建立索引会分别以和列的大小为排序规则建立棵树的树索引的注意事项根页面位置万年不动实际上树的形成过程是这样的每当为某个表创建一个树索引聚簇索引不是人为创建的默认就有的时候都会为这个索引创建一个根结点页面最开始表中没有数据的时候每个树索引对应的根结点中既没有用户记录也没有目录项记录随后向表中插入用户记录时先把用户记录存储到这个根节点中当根节点中的可用空间用完时继续插入记录此时会将根节点中的所有记录复制到一个新分配的页比如页中然后对这个新页进行页分裂的操作得到另一个新页比如页这时新插入的记录根据键值也就是聚簇索引中的主键值二级索引中对应的索引列的值的大小就会被分配到页或者页中而根节点便升级为存储目录项记录的页这个过程特别注意的是一个树索引的根节点自诞生之日起便不会再移动这样只要我们对某个表建议一个索引那么它的根节点的页号便会被记录到某个地方然后凡是存储引擎需要用到这个索引的时候都会从哪个固定的地方取出根节点的页号从而来访问这个索引内节点中目录项记录的唯一性我们知道树索引的内节点中目录项记录的内容是索引列页号的搭配但是这个搭配对于二级索引来说有点不严谨还拿表为例假设这个表中的数据是这样的如果二级索引中目录项记录的内容只是索引列页号的搭配的话那么为列简历索引后的树应该长这样如果我们想新插入一行记录其中的值分别是那么在修改这个为列建立的二级索引对应的树时便碰到了个大问题由于页中存储的目录项记录是由列页号的值构成的页中的两条目录项记录对应的列的值都是而我们新插入的这条记录的列的值也是那我们这条新插入的记录到底应该放在页中还是应该放在页中答案对不起懵了为了让新插入记录找到自己在那个页面我们需要保证在树的同一层页节点的目录项记录除页号这个字段以外是唯一的所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的索引列的值主键值页号也就是我们把主键值也添加到二级索引内节点中的目录项记录这样就能保住树每一层节点中各条目录项记录除页号这个字段外是唯一的所以我们为建立二级索引后的示意图实际上应该是这样子的这样我们再插入记录时由于页中存储的目录项记录是由列主键页号的值构成的可以先把新纪录的列的值和页中各目录项记录的列的值作比较如果列的值相同的话可以接着比较主键值因为树同一层中不同目录项记录的列主键的值肯定是不一样的所以最后肯定能定位唯一的一条目录项记录在本例中最后确定新纪录应该被插入到页中一个页面最少存储条记录一个树只需要很少的层级就可以轻松存储数亿条记录查询速度相当不错这是因为树本质上就是一个大的多层级目录每经过一个目录时都会过滤掉许多无效的子目录直到最后访问到存储真实数据的目录那如果一个大的目录中只存放一个子目录是个啥效果呢那就是目录层级非常非常多而且最后的那个存放真实数据的目录中只存放一条数据所以的一个数据页至少可以存放两条记录中的索引方案树索引使用存储引擎如表所示索引存储引擎索引支持支持支持即使多个存储引擎支持同一种类型的索引但是他们的实现原理也是不同的和默认的索引是索引而默认的索引是索引引擎使用作为索引结构叶子节点的域存放的是数据记录的地址索引的原理我们知道中索引即数据也就是聚簇索引的那棵树的叶子节点中已经把所有完整的用户记录都包含了而的索引方案虽然也使用树形结构但是却将素引和数据分开存储将表中的记录按照记录的插入顺序单独存储在一个文件中称之为数据文件这个文件并不划分为若干个数据页有多少记录就往这个文件中塞多少记录就成了由于在插入数据的时候并没有刻意按照主键大小排序所以我们并不能在这些数据上使用二分法进行查找使用存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中会单独为表的主键创建一个索引只不过在索引的叶子节点中存储的不是完整的用户记录而是主键值数据记录地址的组合这里设表一共有三列假设我们以为主键上图是一个表的主索引示意可以看出的索引文件仅仅保存数据记录的地址在中主键索引和二级索引在结构上没有任何区别只是主键索引要求是唯一的而二级索引的可以重复如果我们在上建立一个二级索引则此索引的结构如下图所示同样也是一棵域保存数据记录的地址因此中索引检索的算法为首先按照搜索算法搜索索引如果指定的存在则取出其域的值然后以域的值为地址读取相应数据记录与对比的索引方式都是非聚簇的与包含个聚簇索引是不同的小结两种引擎中索引的区别在存储引擎中我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录而在中却需要进行一次回表操作意味着中建立的索引相当于全部都是二级索引的数据文件本身就是索引文件而索引文件和数据文件是分离的索引文件仅保存数据记录的地址的非聚簇索引域存储相应记录主键的值而索引记录的是地址换句话说的所有非聚簇索引都引用主键作为域的回表操作是十分快速的因为是拿着地址偏移量直接到文件中取数据的反观是通过获取主键之后再去聚簇索引里找记录虽然说也不慢但还是比不上直接用地址去访问要求表必须有主键可以没有如果没有显式指定则系统会自动选择一个可以非空且唯一标识数据记录的列作为主键如果不存在这种列则自动为表生成一个隐含字段作为主键这个字段长度为个字节类型为长整型小结了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助比如举例知道了的索引实现后就很容易明白为什么不建议使用过长的字段作为主键因为所有二级索引都引用主键索引过长的主键索引会令二级索引变得过大举例用非单调的字段作为主键在中不是个好主意因为数据文件本身是一棵非单调的主键会造成在插入新记录时数据文件为了维持的特性而频繁的分裂调整十分低效而使用自增字段作为主键则是一个很好的选择索引的代价一个表上索引建的越多就会占用越多的存储空间在增删改记录的时候性能就越差为了能建立又好又少的索引我们得学学这些索引在哪些条件下起作用的索引是个好东西可不能乱建它在空间和时间上都会有消耗空间上的代价每建立一个索引都要为它建立一棵树每一棵树的每一个节点都是一个数据页一个页默认会占用的存储空间一棵很大的树由许多数据页组成那就是很大的一片存储空间时间上的代价每次对表中的数据进行增删改操作时都需要去修改各个树索引而且我们讲过树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表不论是叶子节点中的记录还是内节点中的记录也就是不论是用户记录还是目录项记录都是按照索引列的值从小到大的顺序而形成了一个单向链表而增删改操作可能会对节点和记录的排序造成破坏所以存储引擎需要额外的时间进行一些记录移位页面分裂页面回收等操作来维护好节点和记录的排序如果我们建了许多索引每个索引对应的树都要进行相关的维护操作会给性能拖后腿数据结构选择的合理性从的角度讲不得不考虑一个现实问题就是磁盘如果我们能让索引的数据结构尽量减少硬盘的操作所消耗的时间也就越小可以说磁盘的操作次数对索引的使用效率至关重要查找都是索引操作一般来说索引非常大尤其是关系型数据库当数据量比较大的时候索引的大小有可能几个甚至更多为了减少索引在内存的占用数据库索引是存储在外部磁盘上的当我们利用索引查询的时候不可能把整个索引全部加载到内存只能逐一加载那么衡量查询效率的标准就是磁盘次数全表查询全表查询是指数据库在执行查询时需要扫描整个表中的所有数据行以找到满足查询条件的数据全表查询通常发生在没有合适的索引可用或者查询条件无法利用索引的情况下查询本身是一个函数又被称为散列函数它可以帮助我们大幅提升检索数据的效率算法是通过某种确定性的算法比如将输入转变为输出相同的输入永远可以得到相同的输出假设输入内容有微小偏差在输出中通常会有不同的结果举例如果你想要验证两个文件是否相同那么你不需要把两份文件直接拿来比对只需要让对方把函数计算得到的结果告诉你即可然后在本地同样对文件进行函数的运算最后通过比较这两个函数的结果是否相同就可以知道这两个文件是否相同加快查找速度的数据结构常见的有两类树例如平衡二叉搜索树查询插入修改删除的平均时间复杂度都是哈希例如查询插入修改删除的平均时间复杂度都是采用进行检索效率非常高基本上一次检索就可以找到数据而树需要自顶向下依次查找多次访问节点才能找到数据中间需要多次操作从效率来说比树更快在哈希的方式下一个元素处于中即利用哈希函数根据关键字计算出槽的位置函数将关键字域映射到哈希表的槽位上上图中哈希函数有可能将两个不同的关键字映射到相同的位置这叫做碰撞在数据库中一般采用链接法来解决在链接法中将散列到同一槽位的元素放在一个链表中如下图所示实验体会数组和表的查找方面的效率区别算法复杂度为算法复杂度为结构效率高那为什么索引结构要设计成树型呢原因索引仅能满足和查询如果进行范围查询哈希型的索引时间复杂度会退化为而树型的有序特性依然能够保持的高效率原因索引还有一个缺陷数据的存储是没有顺序的在的情况下使用索引还需要对数据重新排序原因对于联合索引的情况值是将联合索引键合并后一起来计算的无法对单独的一个键或者几个索键进行查询原因对于等值查询来说通常索引的效率更高不过也存在一种情况就是索引列的重复值如果很多效率就会降低这是因为遇到冲突时需要遍历桶中的行指针来进行比较找到查询的关键字非常耗时所以索引通常不会用到重复值多的列上比如列为性别年龄的情况等索引适用存储引擎如表所示索引存储引擎索引不支持不支持支持索引的适用性索存在着很多限制相比之下在数据库中树索引的使用面会更广不过也有一些场景采用索引效率更高比如在键值型数据库中存储的核心就是表中的存储引擎支持存储如果我们需要用到查询的临时表时就可以选择存储引擎把某个字段设置为索引比如字符串类型的字段进行计算之后长度可以缩短到几个字节当字段的重复度低而且经常需要进行等值查询的时候采用索引是个不错的选择另外本身不支持索引但是提供自适应索引什么情况下才会使用自适应索呢如果某个数据经常被访问当满足一定条件的时候就会将这个数据页的地址存放到表中这样下次查询的时候就可以直接找到这个页面的所在位置这样让树也具备了索引的优点采用自适应索引目的是方便根据的查询条件加速定位到叶子节点特别是当树比较深的时候通过自适应索引可以明显提高数据的检索效率我们可以通过变量来查看是否开启了自适应比如二叉搜索树如果我们利用二叉树作为索引结构那么磁盘的次数和索引树的高度是相关的二叉搜索树的特点一个节点只能有两个子节点也就是一个节点度不能超过左子节点本节点右子节点本节点比我大的向右比我小的向左查找规则我们先来看下最基础的二叉搜索树搜索某个节点和插入节点的规则一样我们假设搜索插入的数值为如果大于根节点则在右子树中进行查找如果小于根节点则在左子树中进行查找如果等于根节点也就是找到了这个节点返回根节点即可举个例子我们对数列创造出来的二分查找树如下图所示但是特殊情况就是有时候二叉树的深度非常大比如上面第二棵树也属于二分查找树但是性能上已经退化成了一条链表查找数据的时间复杂度变成了你能看出来第一个树的深度是也就是说最多只需次比较就可以找到节点而第二个树的深度是最多需要次比较才能找到节点为了提高查询效率就需要减少磁盘数为了减少磁盘的次数就需要尽量降低树的高度需要把原来瘦高的树结构变的矮胖树的每层的分叉越多越好平衡树树为了解决上面二叉查找树退化成链表的问题人们提出了平衡二叉搜索树又称为树有别于算法它在二叉搜索树的基础上增加了约束具有以下性质它是一棵空树或它的左右两个子树的高度差的绝对值不超过并且左右两个子树都是一棵平衡二叉树常见的平衡二叉树有很多种包括了平衡二叉搜索树红黑树数堆伸展树平衡二叉搜索树是最早提出来的自平衡二叉搜索树当我们提到平衡二叉树时一般指的就是平衡二叉搜索树事实上第一棵树就属于平衡二叉搜索树搜索时间复杂度就是数据查询的时间主要依赖于磁盘的次数如果我们采用二叉树的形式即使通过平衡二叉搜索树进行了改进树的深度也是当比较大时深度也是比较高的比如下图的情况树的英文是也就是多路平衡查找树简写为它的高度远小于平衡二叉树的高度树的结构如下图所示树作为多路平衡查找树它的每一个节点最多可以包括个子节点称为树的阶每个磁盘块中包括了关键字和子节点的指针如果一个磁盘块中包括了个关键字那么指针数就是对于一个阶的树来说如果有层的话最多可以存储约万的索引数据对于大量的索引数据来说采用树的结构是非常适合的因为树的高度要远小于二叉树的高度一个阶的树有以下的特性根节点的儿子数的范围是每个中间节点包含个关键字和个孩子孩子的数量关键字的数量的取值范围为叶子节点包括个关键字叶子节点没有孩子的取值范围为假设中间节点节点的关键字为且关键字按照升序排序即此时个关键字相当于划分了个范围也就是对应着个指针即为其中指向关键字小于的子树指向关键字属于的子树指向关键字大于的子树所有叶子节点位于同一层上面那张图所表示的树就是一棵阶的树我们可以看下磁盘块里面的关键字为它有个孩子和你能看到小于在和之间而大于刚好符合刚才我们给出的特征然后我们来看下如何用树进行查找假设我们想要查找的关键字是那么步骤可以分为以下几步我们与根节点的关键字进行比较小于那么得到指针按照指针找到磁盘块关键字为因为在和之间所以我们得到指针按照指针找到磁盘块关键字为然后我们找到了关键字你能看出来在树的搜索过程中我们比较的次数并不少但如果把数据读取出来然后在内存中进行比较这个时间就是可以忽略不计的而读取磁盘块本身需要进行操作消耗的时间比在内存中进行比较所需要的时间要多是数据查找用时的重要因素树相比于平衡二叉树来说磁盘操作要少在数据查询中比平衡二叉树效率要高所以只要树的高度足够低次数足够少就可以提高查询性能小结树在插入和删除节点的时候如果导致树不平衡就通过自动调整节点的位置来保持树的自平衡关键字集合分布在整棵树中即叶子节点和非叶子节点都存放数据搜索有可能在非叶子节点结束其搜索性能等价于在关键字全集内做一次二分查找再举例树也是一种多路搜索树基于树做出了改进主流的都支持树的索引方式比如相比于适合文件索引系统官网说明树和树的差异在于以下几点有个孩子的节点就有个关键字也就是孩子数量关键字数而树中孩子数量关键字数非叶子节点的关键字也会同时存在在子节点中并且是在子节点中所有关键字的最大或最小非叶子节点仅用于索引不保存数据记录跟记录有关的信息都放在叶子节点中而树中非叶子节点既保存索引也保存数据记录所有关键字都在叶子节点出现叶子节点构成一个有序链表而且叶子节点本身按照关键字的大小从小到大顺序链接下图就是一棵树阶数为根节点中的关键字分别是子节点和中的最小值每一层父节点的关键字都会出现在下一层的子节点的关键字中因此在叶子节点中包括了所有的关键字信息并且每一个叶子节点都有一个指向下一个节点的指针这样就形成了一个链表比如我们想要查找关键字树会自顶向下逐层进行查找与根节点的关键字进行比较在和之间得到指针指向磁盘块找到磁盘块关键字为因为大于所以得到指针指向磁盘块找到磁盘块关键字为然后我们找到了关键字所以可以找到关键字所对应的数据整个过程一共进行了次操作看起来树和树的查询过程差不多但是树和树有个根本的差异在于树的中间节点并不直接存储数据这样的好处都有什么呢首先树查询效率更稳定因为树每次只有访问到叶子节点才能找到对应的数据而在树中非叶子节点也会存储数据这样就会造成查询效率不稳定的情况有时候访问到了非叶子节点就可以找到关键字而有时需要访问到叶子节点才能找到关键字其次树的查询效率更高这是因为通常树比树更矮胖阶数更大深度更低查询所需要的磁盘也会更少同样的磁盘页大小树可以存储更多的节点关键字不仅是对单个关键字的查询上在查询范围上树的效率也比树高这是因为所有关键字都出现在树的叶子节点中叶子节点之间会有指针数据又是递增的这使得我们范围查找可以通过指针连接查找而在树中则需要通过中序遍历才能完成查询范围的查找效率要低很多树和树都可以作为索引的数据结构在中采用的是树但树和树各有自己的应用场景不能说树完全比树好反之亦然思考题为了减少索引树会一次性加载吗数据库索引是存储在磁盘上的如果数据量很大必然导致索引的大小也会很大超过几个当我们利用索引查询时候是不可能将全部几个的索引都加载进内存的我们能做的只能是逐一加载每一个磁盘页因为磁盘页对应着索引树的节点思考题树的存储能力如何为何说一般查找行记录最多只需次磁盘存储引擎中页的大小为一般表的主键类型为占用个字节或占用个字节指针类型也一般为或个字节也就是说一个页中的一个节点中大概存储个键值因为是估值为方便计算这里的取值为也就是说一个深度为的索引可以维护亿条记录这里假定一个数据页也存储条行记录数据了实际情况中每个节点可能不能填充满因此在数据库中的高度一般都在层的存储引擎在设计时是将根节点常驻内存的也就是说查找某一键值的行记录时最多只需要次磁盘操作思考题为什么说树比树更适合实际应用中操作系统的文件索引和数据库索引树的磁盘读写代价更低树的内部结点并没有指向关键字具体信息的指针因此其内部结点相对树更小如果把所有同一内部结点的关键字存放在同一盘块中那么盘块所能容纳的关键字数量也越多一次性读入内存中的需要查找的关键字也就越多相对来说读写次数也就降低了树的查询效率更加稳定由于非终结点并不是最终指向文件内容的结点而只是叶子结点中关键字的索引所以任何关键字的查找必须走一条从根结点到叶子结点的路所有关键字查询的路径长度相同导致每一个数据的查询效率相当思考题索引与树索引的区别索引不能进行范围查询而树可以这是因为索指向的数据是无序的而树的叶子节点是个有序的链表索引不支持联合素引的最左侧原则即联合索引的部分索无法使用而树可以对于联合索引来说索引在计算值的时候是将索引键合并后再一起计算值所以不会针对每个索引单独计算值因此如果用到联合索引的一个或者几个索时联合索引无法被利用索引不支持排序因为索引指向的数据是无序的因此无法起到排序优化的作用而树索数据是有序的可以起到对该字段排序优化的作用同理我们也无法用索引进行模糊查询而树使用进行模醐查询的时候后面后模糊查询比如结尾的话就可以起到优化作用不支持哈希索引思考题索引与树索引是在建索引的时候手动指定的吗如果使用的是的话我们需要了解的存储引擎都支持哪些索引结构如下图所示参考来源如果是其他的可以参考相关的文档针对和存储引擎都会默认采用树索引无法使用索引提供的自适应是不需要手动指定的如果是和存储引擎是可以进行选择索引的树在很少使用仅支持数据类型支持该类型的存储引擎只有几种举个树在现实领域中能够解决的例子查找英里以内所有的餐厅如果没有树你会怎么解决一般情况下我们会把餐厅的坐标分为两个字段存放在数据库中一个字段记录经度另一个字段记录纬度这样的话我们就需要遍历所有的餐厅获取其位置信息然后计算是否满足要求如果一个地区有家餐厅的话我们就要进行次位置计算操作了如果应用到谷歌百度地图这种超大数据库中这种方法便必定不可行了树就很好的解决了这种高维空间搜索问题它把树的思想很好的扩展到了多维空间采用了树分割空间的思想并在添加删除操作时采用合并分解结点的方法保证树的平衡性因此树就是一棵用来存储高维数据的平衡树相对于的优势在于范围查找索引存储引擎索引支持支持不支持附录算法的时间复杂度时间复杂度是算法分析中的一个重要概念用于衡量算法在输入规模增大时所需执行时间的增长趋势时间复杂度通常用大表示法来表示它描述了算法在最坏情况下的执行时间与输入规模之间的关系常见的时间复杂度以下是一些常见的时间复杂度及其对应的算法性能常数时间复杂度算法的执行时间与输入规模无关无论输入规模如何增大执行时间都是固定的例如访问数组中的某个元素插入删除链表中的某个节点对数时间复杂度算法的执行时间随输入规模的增大而增长但增长速度较慢通常是对数级别的增长例如二分查找线性时间复杂度算法的执行时间与输入规模成正比输入规模增大一倍执行时间也增大一倍例如遍历数组线性查找线性对数时间复杂度算法的执行时间介于线性和平方之间通常是一些高效排序算法的时间复杂度例如快速排序归并排序平方时间复杂度算法的执行时间与输入规模的平方成正比输入规模增大一倍执行时间增大四倍例如冒泡排序选择排序立方时间复杂度算法的执行时间与输入规模的立方成正比输入规模增大一倍执行时间增大八倍例如矩阵乘法指数时间复杂度算法的执行时间随输入规模的增大呈指数级增长通常是一些暴力搜索算法的时间复杂度例如求解旅行商问题的暴力解法阶乘时间复杂度算法的执行时间随输入规模的增大呈阶乘级增长通常是一些组合问题的暴力解法例如求解全排列问题的暴力解法如何计算时间复杂度计算时间复杂度通常需要分析算法中的基本操作次数并找出其与输入规模之间的关系以下是一些常见的计算方法循环结构单层循环的时间复杂度通常为嵌套循环的时间复杂度通常为其中是循环的层数递归结构递归算法的时间复杂度通常需要通过递归关系式来求解例如使用主定理分治法分治法的时间复杂度通常可以通过递归关系式来求解例如归并排序的时间复杂度为总结时间复杂度是衡量算法性能的重要指标它描述了算法在最坏情况下的执行时间与输入规模之间的关系了解常见的时间复杂度及其对应的算法性能有助于选择合适的算法来解决问题并优化算法的执行效率',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-17 12:55:13',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script async="" defer="" src="https://umami.shiguangdev.cn/script.js" data-website-id="bc279f56-9a19-416a-a035-58c0abed887b"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="時光" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar.png"><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.shiguang666.eu.org" title="時光主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光主页"><span class="back-menu-item-text">時光主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://nav.shiguang666.eu.org" title="時光导航站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光导航站"><span class="back-menu-item-text">時光导航站</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://game.shiguang666.eu.org" title="怀旧游戏机"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="怀旧游戏机"><span class="back-menu-item-text">怀旧游戏机</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://umami.shiguangdev.cn/share/1CY8KW6pqM0UBUIL/blog.shiguangdev.cn" title="访客统计"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://umami.shiguangdev.cn/favicon.ico" alt="访客统计"><span class="back-menu-item-text">访客统计</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">后台管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://img.shiguangdev.cn/" title="時光图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/favicon.ico" alt="時光图床"><span class="back-menu-item-text">時光图床</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.shiguang666.eu.org/" title="Hexo管理面板"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://qexo.shiguang666.eu.org/favicon.ico" alt="Hexo管理面板"><span class="back-menu-item-text">Hexo管理面板</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">時光</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随机</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/news/"><i class="fa fa-calendar faa-tada"></i><span> 早报亭</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=10051718332&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/xjj/"><i class="fa fa-rocket faa-tada"></i><span> 养生堂</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/flink/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comment/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechat.png"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.png"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">31</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">38</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">30</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">20</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/SQL/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>SQL</span></a><a class="article-meta__tags" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>尚硅谷</span></a></span></div></div><h1 class="post-title" itemprop="name headline">【尚硅谷】MySQL-索引的数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-20T01:51:42.000Z" title="发表于 2024-09-20 09:51:42">2024-09-20</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-12-17T04:55:13.183Z" title="更新于 2024-12-17 12:55:13">2024-12-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">16.9k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/09/20/4ee543fd05bd/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope="" itemtype="https://blog.shiguang666.eu.org/2024/09/20/4ee543fd05bd/"><header><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a><a href="/tags/SQL/" tabindex="-1" itemprop="url">SQL</a><a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" tabindex="-1" itemprop="url">尚硅谷</a><h1 id="CrawlerTitle" itemprop="name headline">【尚硅谷】MySQL-索引的数据结构</h1><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">時光</span><time itemprop="dateCreated datePublished" datetime="2024-09-20T01:51:42.000Z" title="发表于 2024-09-20 09:51:42">2024-09-20</time><time itemprop="dateCreated datePublished" datetime="2024-12-17T04:55:13.183Z" title="更新于 2024-12-17 12:55:13">2024-12-17</time></header><div id="postchat_postcontent"><blockquote>
<p>在线视频:<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=115">MySQL数据库入门到大牛，mysql安装到优化，百科全书级，全网天花板</a><br>官方资料: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ztbzMVF9qRJ2xCOpySXl3Q?pwd=yyds">尚硅谷MySQL入门到高级-宋红康版</a></p>
<p>代码仓库<br>Gitee：<a target="_blank" rel="noopener" href="https://gitee.com/an_shiguang/learn-mysql">https://gitee.com/an_shiguang/learn-mysql</a></p>
</blockquote>
<h1 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h1><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ece985c56f2.png" alt="image-20240920111828163"></p>
<p>如上图所示，数据库没有索引的情况下，数据<code>分布在硬盘不同的位置上面</code>，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果<code>数据顺序摆放</code>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，<code>依旧非常耗时</code>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 = 89 这条记录，就要逐行去查找、去比较。从Col 2 = 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<code>上千万条数据</code>，就意味着要做<code>很多很多次硬盘I/0</code>才能找到。现在要查找 Col 2 = 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I/O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）</p>
<p>假如给数据使用 <code>二叉树</code> 这样的数据结构进行存储，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ece99be6b54.png" alt="image-20240920111850546"></p>
<p>对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 <code>二叉搜索树</code>。二叉搜索树的每个结点存储的是 <code>(K, V) 结构</code>，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：<code>(34, 0x07)</code>。现在对 Col 2 添加了索引，这时再去查找 Col 2 = 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34 到内存，89 &gt; 34; 继续右侧数据，读 89 到内存，89==89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 <code>查找两次</code> 就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是我们为什么要建索引，目的就是为了 <code>减少磁盘I/O的次数</code>，加快查询速率。</p>
<h1 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a>索引及其优缺点</h1><h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
<p><strong>索引的本质</strong>：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <code>高级查找算法</code> 。</p>
<p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 <code>最大索引数</code>和 <code>最大索引长度</code>。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主 要的原因。 </p>
<p>（2）通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。 </p>
<p>（3）在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。 </p>
<p>（4）在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>增加索引也有许多不利的方面，主要表现在如下几个方面： </p>
<p>（1）创建索引和维护索引要 <strong>耗费时间</strong> ，并 且随着数据量的增加，所耗费的时间也会增加。 </p>
<p>（2）索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 </p>
<p>（3）虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
</blockquote>
<h1 id="InnoDB中索引的推演"><a href="#InnoDB中索引的推演" class="headerlink" title="InnoDB中索引的推演"></a>InnoDB中索引的推演</h1><h2 id="索引之前的查找"><a href="#索引之前的查找" class="headerlink" title="索引之前的查找"></a>索引之前的查找</h2><p>先来看一个精确匹配的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="在一个页中的查找"><a href="#在一个页中的查找" class="headerlink" title="在一个页中的查找"></a>在一个页中的查找</h3><blockquote>
<p>在 MySQL 中，数据页（Data Page）是存储引擎（如 InnoDB）用于存储数据的基本单位。数据页是磁盘和内存之间数据交换的基本单位，通常大小为 16KB</p>
</blockquote>
<p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li><p>以主键为搜索条件</p>
<p>可以在页目录中使用 <code>二分法</code> 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。</p>
</li>
<li><p>以其他列作为搜索条件</p>
<p>因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 <code>最小记录</code> 开始 <code>依次遍历单链表中的每条记录</code>， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p>
</li>
</ul>
<h3 id="在很多页中查找"><a href="#在很多页中查找" class="headerlink" title="在很多页中查找"></a>在很多页中查找</h3><p>在很多页中查找记录的活动可以分为两个步骤：</p>
<ol>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ol>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页沿着双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。</p>
<h2 id="设计索引"><a href="#设计索引" class="headerlink" title="设计索引"></a>设计索引</h2><p>建一个表：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">-&gt; c1 INT,</span><br><span class="line">-&gt; c2 INT,</span><br><span class="line">-&gt; c3 CHAR(1),</span><br><span class="line">-&gt; PRIMARY KEY(c1)</span><br><span class="line">-&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></tbody></table></figure>

<p>这个新建的 <strong>index_demo</strong> 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 <strong>Compact</strong> 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecf0078a576.png" alt="image-20240920114614130"></p>
<p>我们只在示意图里展示记录的这几个部分：</p>
<ul>
<li><code>record_type</code> ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过，下面讲。 </li>
<li><code>next_record</code> ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。 </li>
<li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。 </li>
<li>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecf01f0947e.png" alt="image-20240920114637732"></p>
<p>把一些记录放到页里的示意图就是：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecf02bd57d9.png" alt="image-20240920114650609"></p>
<h3 id="一个简单的索引设计方案"><a href="#一个简单的索引设计方案" class="headerlink" title="一个简单的索引设计方案"></a>一个简单的索引设计方案</h3><blockquote>
<h4 id="数据页的连续性"><a href="#数据页的连续性" class="headerlink" title="数据页的连续性"></a>数据页的连续性</h4><ol>
<li><strong>数据页内的连续性</strong>：<ul>
<li><strong>在同一个数据页内，数据行（Row Data）通常是连续存储的</strong>。每个数据行按照一定的格式存储在数据页的行数据区域中。</li>
<li>数据页内的数据行按照插入顺序存储，新插入的数据行会优先使用数据页中的空闲空间。</li>
</ul>
</li>
<li><strong>数据页间的连续性</strong>：<ul>
<li><strong>数据页之间通常不是连续存储的</strong>。InnoDB 使用 B+ 树结构来组织数据页，每个数据页通过指针（Page Pointer）相互连接。</li>
<li>B+ 树的叶子节点（数据页）通过双向链表连接，形成一个有序的数据页链表。</li>
</ul>
</li>
</ol>
</blockquote>
<p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录 ，建这个目录必须完成下边这些事：</p>
<ul>
<li><p><strong><font color="red">下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</font></strong></p>
<p>假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>​       那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecf12d09471.png" alt="image-20240920115107387"></p>
<p>从图中可以看出来， index_demo 表中的3条记录都被插入到了编号为10的数据页中了。</p>
<p>此时我们再来插入一条记录：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO index_demo VALUES(4, 4, 'a');</span><br></pre></td></tr></tbody></table></figure>

<p>因为 <strong>页10</strong> 最多只能放3条记录，所以我们不得不再分配一个新页：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecf28278c39.png" alt="image-20240920115649194"></p>
<p>注意：新分配的 <strong>数据页编号可能并不是连续的</strong>。它们只是通过维护者上一个页和下一个页的编号而建立了 <strong>链表</strong> 关系。另外，<strong>页10</strong>中用户记录最大的主键值是5，而<strong>页28</strong>中有一条记录的主键值是4，因为5&gt;4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次 <strong>记录移动</strong>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecf2f06f0a7.png" alt="image-20240920115839103"></p>
<p>这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 <strong>记录移动</strong> 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为 <strong>页分裂</strong>。</p>
<ul>
<li><strong>给所有的页建立一个目录项。</strong></li>
</ul>
<p>由于数据页的 <strong>编号可能是不连续</strong> 的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecf3376ca0e.png" alt="image-20240920115950089"></p>
<p>我们需要给它们做个 <strong>目录</strong>，每个页对应一个目录项，每个目录项包括下边两个部分：</p>
<p>1）页的用户记录中最小的主键值，我们用 <strong>key</strong> 来表示。</p>
<p>2）页号，我们用 <strong>page_on</strong> 表示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecf35d0c76b.png" alt="image-20240920120027819"></p>
<p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p>
<ol>
<li>先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页9 。 </li>
<li>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</li>
</ol>
<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong> 。</p>
<h3 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h3><h4 id="①-迭代1次：目录项纪录的页"><a href="#①-迭代1次：目录项纪录的页" class="headerlink" title="①  迭代1次：目录项纪录的页"></a>①  迭代1次：目录项纪录的页</h4><p>InnoDB怎么区分一条记录是普通的 <strong>用户记录</strong> 还是 <strong>目录项记录</strong> 呢？使用记录头信息里的 <strong>record_type</strong> 属性，它的各自取值代表的意思如下：</p>
<ul>
<li>0：普通的用户记录</li>
<li>1：目录项记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
<p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecfb373a189.png" alt="image-20220616162944404"></p>
<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 <strong>目录项记录</strong> 和普通的 <strong>用户记录</strong> 的不同点：</p>
<ul>
<li><strong>目录项记录</strong> 的 record_type 值是1，而 <strong>普通用户记录</strong> 的 record_type 值是0。 </li>
<li>目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含 <strong>很多列</strong> ，另外还有InnoDB自己添加的隐藏列。 </li>
<li>了解：记录头信息里还有一个叫 <strong>min_rec_mask</strong> 的属性，只有在存储 <strong>目录项记录</strong> 的页中的主键值最小的 <strong>目录项记录</strong> 的 <strong>min_rec_mask</strong> 值为 <strong>1</strong> ，其他别的记录的 <strong>min_rec_mask</strong> 值都是 <strong>0</strong> 。</li>
</ul>
<p><strong>相同点</strong>：两者用的是一样的数据页，都会为主键值生成 <strong>Page Directory （页目录）</strong>，从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。</p>
<p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol>
<li>先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。 </li>
<li>再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。</li>
</ol>
<h4 id="②-迭代2次：多个目录项纪录的页"><a href="#②-迭代2次：多个目录项纪录的页" class="headerlink" title="② 迭代2次：多个目录项纪录的页"></a>② 迭代2次：多个目录项纪录的页</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecfb71a898c.png" alt="image-20240920123456400"></p>
<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了 页31 。 </li>
<li>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。</li>
</ul>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：</p>
<ol>
<li>确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。 </li>
<li>通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。 </li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ol>
<h4 id="③-迭代3次：目录项记录页的目录页"><a href="#③-迭代3次：目录项记录页的目录页" class="headerlink" title="③ 迭代3次：目录项记录页的目录页"></a>③ 迭代3次：目录项记录页的目录页</h4><p>如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个<code>更高级的目录</code>，就像是一个多级目录一样，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecfb81df455.png" alt="image-20220616173512780"></p>
<p>如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。</p>
<p>我们可以用下边这个图来描述它：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ecfb81c643d.png" alt="image-20220616173717538"></p>
<p>这个数据结构，它的名称是 B+树 。</p>
<h4 id="④-B-Tree"><a href="#④-B-Tree" class="headerlink" title="④ B+Tree"></a>④ B+Tree</h4><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 <code>100</code>条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 <code>1000</code>条目录项记录 ，那么：</p>
<ul>
<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li>
<li>如果B+树有2层，最多能存放 <code>1000×100=10,0000</code> 条记录。 </li>
<li>如果B+树有3层，最多能存放 <code>1000×1000×100=1,0000,0000</code> 条记录。 </li>
<li>如果B+树有4层，最多能存放 <code>1000×1000×1000×100=1000,0000,0000</code> 条记录。相当多的记录！</li>
</ul>
<p>你的表里能存放 <strong>100000000000</strong> 条记录吗？所以 <font color="red"><strong>一般情况下，我们用到的B+树都不会超过4层</strong></font> ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 <strong><code>Page Directory</code></strong> （页目录），所以在页面内也可以通过 <strong><code>二分法</code></strong> 实现快速 定位记录。</p>
<h2 id="常见索引概念"><a href="#常见索引概念" class="headerlink" title="常见索引概念"></a>常见索引概念</h2><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。  </p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>**<font color="red">聚簇索引</font><strong>并不是一种单独的索引类型，而是</strong><font color="red">一种数据存储方式</font>**（所有的用户记录都存储在了叶子结点），也就是所谓的 <code>索引即数据，数据即索引</code>。</p>
<blockquote>
<p>术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起</p>
</blockquote>
<p><strong>特点：</strong></p>
<ol>
<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</li>
</ol>
<ul>
<li><code>页内</code> 的记录是按照主键的大小顺序排成一个 <code>单向链表</code> 。 </li>
<li>各个存放 <code>用户记录的页</code> 也是根据页中用户记录的主键大小顺序排成一个 <code>双向链表</code> 。 </li>
<li>存放 <code>目录项记录的页</code> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <code>双向链表</code> 。</li>
</ul>
<ol start="2">
<li>B+树的 叶子节点 存储的是**<font color="red">完整的用户记录</font>**。</li>
</ol>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， <code>InnDB</code> 存储引擎会 <code>自动</code> 的为我们创建聚簇索引。</p>
<p><strong>优点：</strong></p>
<ul>
<li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 </li>
<li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快 </li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 <code>节省了大量的io操作</code> 。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现**<code>页分裂</code>**，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<font color="red"><strong>自增的ID列为主键</strong></font></li>
<li><code>更新主键的代价很高</code> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**<font color="red">主键为不可更新</font>**</li>
<li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li><p>对于MySQL数据库目前只有<code>InnoDB</code>数据引擎支持聚簇索引，而<code>MyISAM</code>并不支持聚簇索引。</p>
</li>
<li><p>由于数据物理存储排序方式只能有一种，所以每个MySQL的<code>表只能有一个聚簇索引</code>。一般情况下就是该表的主键。</p>
</li>
<li><p>如果没有定义主键，Innodb会选择<code>非空的唯一索引</code>代替。如果没有这样的索引，Innodb会隐式的定义一个主键<br>来作为聚簇索引。</p>
</li>
<li><p>为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量<code>选用有序的顺序id</code>,而不建议用无序的id,<br>比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</p>
</li>
</ul>
<h3 id="二级索引（辅助索引、非聚簇索引）"><a href="#二级索引（辅助索引、非聚簇索引）" class="headerlink" title="二级索引（辅助索引、非聚簇索引）"></a>二级索引（辅助索引、非聚簇索引）</h3><p>上边介绍的<code>聚簇索引</code>只能在搜索条件是<code>主键值</code>时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以<code>多建几颗B+树</code>，不同的B+树中的数据采用不同的排列规则。比方说<strong>我们用<code>c2</code>列的大小作为数据页</strong>、页中记录的排序规则，再建一课B+树，效果如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed08eddeb3d.png" alt="image-20240920133228120"></p>
<p>这个B+树与上边介绍的聚簇索引有几处不同：</p>
<ul>
<li><p>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><p>页内的记录是按照c2列的大小顺序排成一个<code>单向链表</code>。</p>
</li>
<li><p>各个存放<code>用户记录的页</code>也是根据页中记录的c2列大小顺序排成一个<code>双向链表</code>。</p>
</li>
<li><p>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个<code>双向链表</code>。</p>
</li>
</ul>
</li>
<li><p><font color="red">B+树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列</code>+<code>主键</code>这两个列的值</font>。</p>
</li>
<li><p>目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。</p>
</li>
</ul>
<p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为<br><code>4</code>的记录为例，查找过程如下：</p>
<ol>
<li>确定目录项记录页<br>根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为页<code>42</code>（因为<code>2&lt;4&lt;9</code>）。</li>
<li>通过目录项记录页确定用户记录真实所在的页。<br>在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2</code>列并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的<br>记录可能分布在多个数据页中，又因为<code>2&lt;4≤4</code>，所以确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</li>
<li>在真实存储用户记录的页中定位到具体的记录。<br>到<code>页34</code>和<code>页35</code>中定位到具体的记录。</li>
<li>但是这个B+树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>(<strong>主键</strong>)两个列，所以我们必须再根据主键值<br>去聚簇索引中再查找一遍完整的用户记录。</li>
</ol>
<p><strong>说明：</strong></p>
<p>按照<code>c2</code>列的大小作为数据页，根据<code>c2</code>列的大小进行排序，数据页中仅包含<code>c2</code>列和主键列，如果要查询非<code>c2</code>列的数据，需要再根据记录的主键（即c1列）去聚簇索引获取。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed0c11a9a03.png" alt="image-20240920134552477"></p>
<p><strong>回表概念</strong></p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 <strong><code>回表</code></strong> 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 <strong>2 棵B+树</strong>！</p>
<p> <strong>问题</strong>：为什么我们还需要一次 <code>回表</code> 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p>
<p>如果把完整的用户记录放到叶子结点是可以不用回表。但是<code>太占地方</code>了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p>
<p>因为这种按照<code>非主键列</code>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<code>二级索引</code>（英文名<code>secondary index</code>），或者<code>辅助索引</code>。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列建立的索引。</p>
<p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed1a0bea6ac.png" alt="image-20240920144529477"></p>
<p>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<ol>
<li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>, 非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的<code>查询效率高</code>，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li>
</ol>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义： </p>
<ul>
<li>先把各个记录和页按照c2列进行排序。 </li>
<li>在记录的c2列相同的情况下，采用c3列进行排序</li>
</ul>
<p>为c2和c3建立的索引的示意图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed1b0980395.png" alt="image-20240920144944061"></p>
<p>如图所示，我们需要注意以下几点：</p>
<ul>
<li>每条<code>目录项</code>都有<code>c2、c3、页号</code>这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序</li>
<li>B+树<code>叶子节点</code>处的用户记录由<code>c2、c3和主键c1列</code>组成</li>
</ul>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code> ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下： </p>
<ul>
<li>建立 <code>联合索引</code> 只会建立如上图一样的1棵B+树。 </li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
<h2 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h2><h3 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h3><p>实际上B+树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 <code>根结点</code> 页面。最开始表中没有数据的时候，每个B+树索引对应的 <code>根结点</code> 中既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code> 中。</li>
<li>当根节点中的可用 <code>空间用完时</code> 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 <code>页a</code> 中，然后对这个新页进行 <code>页分裂</code> 的操作，得到另一个新页，比如<code>页b</code> 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 <code>页a</code> 或者 <code>页b</code> 中，而 <code>根节点</code> 便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 <code>InnoDB</code> 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<h3 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h3><p>我们知道B+树索引的内节点中目录项记录的内容是 <code>索引列 + 页号</code> 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 <code>index_demo</code> 表为例，假设这个表中的数据是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed1c0606d5c.png" alt="image-20220617151918786"></p>
<p>如果二级索引中目录项记录的内容只是 <code>索引列 + 页号</code> 的搭配的话，那么为 <code>c2</code> 列简历索引后的B+树应该长这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed1c061eff4.png" alt="image-20220617152906690"></p>
<p>如果我们想新插入一行记录，其中 <code>c1</code> 、<code>c2</code> 、<code>c3</code> 的值分别是: <code>9</code>、<code>1</code>、<code>c</code>, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 页号</code> 的值构成的，<code>页3</code> 中的两条目录项记录对应的 c2 列的值都是1，而我们 <code>新插入的这条记录</code> 的 c2 列的值也是 <code>1</code>，那我们这条新插入的记录到底应该放在 <code>页4</code> 中，还是应该放在 <code>页5</code> 中？答案：对不起，懵了</p>
<p>为了让新插入记录找到自己在那个页面，我们需要<strong>保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed1c06278c7.png" alt="image-20220617154135258"></p>
<p>这样我们再插入记录<code>(9, 1, 'c')</code> 时，由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 主键 + 页号</code> 的值构成的，可以先把新纪录的 <code>c2</code> 列的值和 <code>页3</code> 中各目录项记录的 <code>c2</code> 列的值作比较，如果 <code>c2</code> 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 <code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到 <code>页5</code> 中。</p>
<h3 id="3-一个页面最少存储-2-条记录"><a href="#3-一个页面最少存储-2-条记录" class="headerlink" title="3. 一个页面最少存储 2 条记录"></a>3. 一个页面最少存储 2 条记录</h3><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 <strong>InnoDB 的一个数据页至少可以存放两条记录</strong>。</p>
<h1 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h1><p>B树索引使用存储引擎如表所示：</p>
<table>
<thead>
<tr>
<th>索引 / 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B-Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。</p>
<p>MyISAM引擎使用 <code>B+Tree</code> 作为索引结构，叶子节点的data域存放的是 <code>数据记录的地址</code> 。</p>
<h2 id="MyISAM索引的原理"><a href="#MyISAM索引的原理" class="headerlink" title="MyISAM索引的原理"></a>MyISAM索引的原理</h2><p>我们知道<code>InnoDB中索引即数据</code>，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，<br>而<code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将素引和数据分开存储;</p>
<ul>
<li>将表中的记录<code>按照记录的插入顺序</code>单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并<code>没有刻意按照主键大小排序</code>，所以我们并不能在这些数据上使用二分法进行查找。</li>
<li>使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值+数据记录地址</code><br>的组合</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed264fca0bf.png" alt="image-20240920153750554"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引(Primary key)示意。可以看出<br><font color="red">MyISAM的索引文件仅仅保存数据记录的地址</font>。在MyISAM中，主键索引和二级索引(Secondary key)在结构上没<br>有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在Col2上建立一个二级索<br>引，则此索引的结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed274b1cf06.png" alt="image-20240920154201690"></p>
<p>同样也是一棵B+Tree,data域保存数据记录的地址。因此，MyISAM中索引检索的算法为：首先按照B+Tree搜索算<br>法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<h2 id="MyISAM-与-InnoDB对比"><a href="#MyISAM-与-InnoDB对比" class="headerlink" title="MyISAM 与 InnoDB对比"></a>MyISAM 与 InnoDB对比</h2><p><strong><font color="red">MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：</font></strong></p>
<ol>
<li>在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在 <code>MyISAM</code>中却需要进行一次 回表 操作，意味着<strong>MyISAM中建立的索引相当于全部都是 <code>二级索引</code></strong> 。</li>
<li>InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 <code>分离的</code> ，索引文件仅保存数据记录的地址。</li>
<li>InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code> ，而MyISAM索引记录的是 <code>地址</code> 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。</li>
<li>MyISAM的回表操作是十分<code>快速</code> 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。 </li>
<li>InnoDB要求表 <code>必须有主键</code> （ <strong>MyISAM可以没有</strong> ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</li>
</ol>
<p><strong>小结：</strong></p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如：<br>举例1：知道了InnoDB的索引实现后，就很容易明白<code>为什么不建议使用过长的字段作为主键</code>，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</p>
<p>举例2：用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree,非单调的<br>主键会造成在插入新记录时，数据文件为了维持B+Tre的特性而频繁的分裂调整，十分低效，而使用<code>自增字段作 为主键则是一个很好的选择</code>。</p>
<h1 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h1><blockquote>
<p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p>
</blockquote>
<p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li><p>空间上的代价</p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 <code>16KB</code> 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
</li>
<li><p>时间上的代价</p>
<p>每次对表中的数据进行 <code>增、删、改 </code>操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 <code>从小到大的顺序排序</code> 而组成了 双向链表 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code> ，<code>页面分裂</code>、<code> 页面回收</code> 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
</li>
</ul>
<h1 id="MySQL数据结构选择的合理性"><a href="#MySQL数据结构选择的合理性" class="headerlink" title="MySQL数据结构选择的合理性"></a>MySQL数据结构选择的合理性</h1><p>从MySQL的角度讲，不得不考虑一个现实问题就是磁盘1O。如果我们能让索引的数据结构尽量减少硬盘的/O操<br>作，所消耗的时间也就越小。可以说，<code>磁盘的I/0操作次数</code>对索引的使用效率至关重要。</p>
<p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几<br>个G甚至更多，为了减少索引在内存的占用，<font color="red">数据库索引是存储在外部磁盘上的</font>。当我们利用索引查询的时候，<br>不可能把整个索引全部加载到内存，只能<code>逐一加载</code>，那么MySQL衡量查询效率的标准就是磁盘IO次数。</p>
<h2 id="全表查询"><a href="#全表查询" class="headerlink" title="全表查询"></a>全表查询</h2><p>全表查询（Full Table Scan）是指数据库在执行查询时，需要扫描整个表中的所有数据行，以找到满足查询条件的数据。全表查询通常发生在没有合适的索引可用，或者查询条件无法利用索引的情况下。</p>
<h2 id="Hash查询"><a href="#Hash查询" class="headerlink" title="Hash查询"></a>Hash查询</h2><p>Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。<br>Hash算法是通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3)将输入转变为输出。<code>相同的输入永远可以 得到相同的输出</code>，假设输入内容有微小偏差，在输出中通常会有不同的结果。</p>
<p>举例：如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把Hash函数<br>计算得到的结果告诉你即可，然后在本地同样对文件进行Hash函数的运算，最后通过比较这两个Hash函数的结<br>果是否相同，就可以知道这两个文件是否相同。</p>
<h3 id="加快查找速度的数据结构，常见的有两类"><a href="#加快查找速度的数据结构，常见的有两类" class="headerlink" title="加快查找速度的数据结构，常见的有两类"></a><strong>加快查找速度的数据结构，常见的有两类</strong></h3><p>(1) 树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是 <code>O(log2N)</code>;</p>
<p>(2)哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是 <code>O(1)</code>; </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed35aedf0bd.png" alt="image-20240920164325649"></p>
<p>采用Hash进行检索效率非常高，基本上一次检索就可以找到数据，而B+树需要自顶向下依次查找，多次访问节<br>点才能找到数据，中间需要多次I/O操作，<code>从效率来说Hash比B+树更快</code>。</p>
<p>在哈希的方式下，一个元素k处于h(k)中，即利用哈希函数h,根据关键字k计算出槽的位置。函数h将关键字域映<br>射到哈希表T[0…m-1]的槽位上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed36e3ef828.png" alt="image-20240920164834783"></p>
<p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链 接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed370072f7d.png" alt="image-20240920164903370"></p>
<p>实验：体会数组和hash表的查找方面的效率区别</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(n)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++){</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=<span class="number">100000</span>;j++){</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++){</span><br><span class="line">            <span class="keyword">if</span>(temp == arr[i]){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"time： "</span> + (end - start)); <span class="comment">//time： 823</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(1)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>{</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++){</span><br><span class="line">    	set.add(i + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=<span class="number">100000</span>;j++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> set.contains(temp);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"time： "</span> + (end - start)); <span class="comment">//time： 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Hash结构效率高，那为什么索引结构要设计成树型呢？"><a href="#Hash结构效率高，那为什么索引结构要设计成树型呢？" class="headerlink" title="Hash结构效率高，那为什么索引结构要设计成树型呢？"></a><strong>Hash结构效率高，那为什么索引结构要设计成树型呢？</strong></h3><p>原因1：Hash索引仅能满足 (=) (&lt;&gt;)和IN查询。如果进行<code>范围查询</code>，哈希型的索引，时间复杂度会退化为<br>O(n)；而树型的“有序”特性，依然能够保持0(log2N)的高效率。</p>
<p>原因2：Hash索引还有一个缺陷，数据的存储是<code>没有顺序的</code>，在ORDER BY的情况下，使用Hash索引还需要对数<br>据重新排序。</p>
<p>原因3：对于联合索引的情况，Hsh值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索<br>键进行查询。</p>
<p>原因4：对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是<code>索引列的重复值如果很多，效率就会降低</code>。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所<br>以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</p>
<p><strong>Hash索引适用存储引擎如表所示：</strong></p>
<table>
<thead>
<tr>
<th>索引 / 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>HASH索引</td>
<td>不支持</td>
<td>不支持</td>
<td><code>支持</code></td>
</tr>
</tbody></table>
<h3 id="Hash索引的适用性"><a href="#Hash索引的适用性" class="headerlink" title="Hash索引的适用性"></a><strong>Hash索引的适用性</strong></h3><p>Hash索存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash索引效率更高，比如在键值型(Key-Value)数据库中，<code>Redis存储的核心就是Hash表</code>。</p>
<p>MySQL中的Memory存储引擎支持Hash存储，如果我们需要用到查询的l临时表时，就可以选择Memory存储引<br>擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字<br>段的重复度低，而且经常需要进行<code>等值查询</code>的时候，采用Hash索引是个不错的选择。</p>
<p>另外，InnoDB本身不支持Hash索引，但是提供<code>自适应Hash索引</code>(Adaptive Hash Index)。什么情况下才会使用自适应Hsh索呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash索引的优点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed3a0932cf8.png" alt="image-20240920170200008"></p>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p>
<p>我们可以通过 <code>innodb_adaptive_hash_index</code> 变量来查看是否开启了自适应 Hash，比如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%adaptive_hash_index';</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p>
<h3 id="二叉搜索树的特点"><a href="#二叉搜索树的特点" class="headerlink" title="二叉搜索树的特点"></a>二叉搜索树的特点</h3><ul>
<li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li>
<li>左子节点 &lt; 本节点; 右子节点 &gt; 本节点，比我大的向右，比我小的向左</li>
</ul>
<h3 id="查找规则"><a href="#查找规则" class="headerlink" title="查找规则"></a>查找规则</h3><p>我们先来看下最基础的二叉搜索树(Binary Search Tree),搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为key:</p>
<ol>
<li>如果key大于根节点，则在右子树中进行查找；</li>
<li>如果key小于根节点，则在左子树中进行查找；</li>
<li>如果ky等于根节点，也就是找到了这个节点，返回根节点即可。</li>
</ol>
<p>举个例子，我们对数列(34,22,89,5,23,77,91)创造出来的二分查找树如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed3bace1f0e.png" alt="image-20240920170859808"></p>
<p>但是特殊情况，就是有时候二叉树的深度非常大，比如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed3be23ce5b.png" alt="image-20240920170953165"></p>
<p>上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了<code>0(n)</code>。你能看出来第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二个树的深度是7，最多需要7次比较才能找到节点。</p>
<p>为了提高查询效率，就需要<code>减少磁盘I0数</code>。为了减少磁盘IO的次数，就需要尽量<code>降低树的高度</code>，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p>
<h2 id="平衡树（AVL树）"><a href="#平衡树（AVL树）" class="headerlink" title="平衡树（AVL树）"></a>平衡树（AVL树）</h2><p>为了解决上面二叉查找树退化成链表的问题，人们提出了<code>平衡二叉搜索树(Balanced Binary Tree)</code>,又称为AVL树（有别于AVL算法），它在二叉搜索树的基础上增加了约束，具有以下性质：</p>
<p><font color="red"><strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></font></p>
<p>常见的平衡二叉树有很多种，包括了<code>平衡二叉搜索树</code>、<code>红黑树</code>、<code>数堆</code>、<code>伸展树</code>。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是<code>0(1og2n)</code>。</p>
<p>数据查询的时间主要依赖于磁盘I/O的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是O(log2n),当n比较大时，深度也是比较高的，比如下图的情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed3dd08fb80.png" alt="image-20240920171807429"></p>
<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>B 树的英文是 Balance Tree，也就是 <code>多路平衡查找树</code>。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p>
<p>B 树的结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed547499fff.png" alt="image-20240920185443430"></p>
<p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<code>M称为B树的阶</code>。每个磁盘块中包括了<code>关键字</code>和<code>子节点的指针</code>。如果一个磁盘块中包括了×个关键字，那么指针数就是x+1。对于一个100阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p>
<p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>
<ol>
<li>根节点的儿子数的范围是 [2,M]。 </li>
<li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 [ceil(M/2), M]。 </li>
<li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。 </li>
<li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li>
<li>所有叶子节点位于同一层。</li>
</ol>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。</p>
<p>然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：</p>
<ol>
<li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </li>
<li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； </li>
<li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li>
</ol>
<p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I/O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。</p>
<p><strong>小结：</strong></p>
<ol>
<li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
</ol>
<p><strong>再举例1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed56fc3fb5f.png" alt="image-20240920190531095"></p>
<h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>B+树也是一种多路搜索树，<code>基于B树做出了改进</code>，主流的DBMS都支持B+树的索引方式，比如MySQL。相比<br>于B-Tree，<code>B+Tree适合文件索引系统</code>。 </p>
<p>MySQL官网说明：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed57da7ba15.png" alt="image-20240920190913445"></p>
<p><strong>B+ 树和 B 树的差异在于以下几点：</strong></p>
<ol>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。 </li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。 </li>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。</li>
</ol>
<p>下图就是一棵B+树，阶数为3，根节点中的关键字1、18、35分别是子节点(1,8,14)，(18,24,31)和(35,41,53)中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个节点的指针，这样就形成了一个链表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed5c19dac77.png" alt="image-20240920192720737"></p>
<p>比如，我们想要查找关键字16，B+树会自顶向下逐层进行查找：</p>
<ol>
<li>与根节点的关键字(1,18,35)进行比较，16在1和18之间，得到指针P1(指向磁盘块2)</li>
<li>找到磁盘块2，关键字为(1,8,14)，因为16大于14，所以得到指针P3(指向磁盘块7)</li>
<li>找到磁盘块7，关键字为(14,16,17)，然后我们找到了关键字16，所以可以找到关键字16所对应的数据。</li>
</ol>
<p>整个过程一共进行了3次I/0操作，看起来B+树和B树的查询过程差不多，但是B+树和B树有个根本的差异在于，<font color="red"><strong>B+树的中间节点并不直接存储数据</strong></font>。这样的好处都有什么呢？</p>
<p>首先，<font color="red"><strong>B+树查询效率更稳定</strong></font>。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p>
<p>其次，<font color="red"><strong>B+树的查询效率更高</strong></font>。这是因为通常B+树比B树<code>更矮胖</code>(阶数更大，深度更低)，查询所需要的磁盘I/O也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</p>
<p>不仅是对单个关键字的查询上，<font color="red"><strong>在查询范围上，B+树的效率也比B树高</strong></font>。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>
</blockquote>
<p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p>
<blockquote>
<p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。<br>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p>
</blockquote>
<p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p>
<blockquote>
<p>InnoDB存储引擎中页的大小为16KB,一般表的主键类型为INT(占用4个字节)或B1GINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3*10^3 *10^3=10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在2~4层</code>。<font color="red">MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的</font>，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/0操作。</p>
</blockquote>
<p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<blockquote>
<p>1、B+树的磁盘读写代价更低<br>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结<br>点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关<br>键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>2、B+树的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必<br>须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p>
<blockquote>
<p>1、<code>Hash索引不能进行范围查询</code>，而B+树可以。这是因为Hash索指向的数据是无序的，而B+树的叶子节<br>点是个有序的链表。</p>
<p>2、<code>Hash索引不支持联合素引的最左侧原则</code>（即联合索引的部分索无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索时，联合索引无法被利用。</p>
<p>3、<code>Hash索引不支持ORDER BY排序</code>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也<code>无法用Hash索引进行模糊查询</code>，而B+树使用LKE进行模醐查询的时候，LKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。</p>
<p>4、<code>InnoDB不支持哈希索引</code></p>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</strong></p>
<blockquote>
<p>如果使用的是MySQL的话，我们需要了解MySQL的存储引擎都支持哪些索引结构，如下图所示（参考来源h<br>ttps://dev.mysql.com/doc/refman/8.O/en/create-index..html)。如果是其他的DBMS,可以参考相关的DBMS文档。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed659fa10b2.png" alt="image-20240920200758563"></p>
<p>针对InnoDB和MyISAM存储引擎，都会默认采用B+树索引，无法使用Hash索引。InnoDB提供的自适应Hash是不需要手动指定的。如果是Memory/Heap和NDB存储引擎，是可以进行选择Hash索引的。</p>
</blockquote>
<h2 id="R树"><a href="#R树" class="headerlink" title="R树"></a>R树</h2><p>R-Tree在MySQL很少使用，仅支持<code> geometry</code>数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果 没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满 足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度地图这种超大数据库中，这种方法便必定不可行了。<code>R树就很好的解决了这种高维空间搜索问题</code> 。它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，<code>R树就是一棵用来存储高维数据的平衡树</code> 。相对于B-Tree，R-Tree 的优势在于范围查找</p>
<table>
<thead>
<tr>
<th>索引 / 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>R-Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h1 id="附录：算法的时间复杂度"><a href="#附录：算法的时间复杂度" class="headerlink" title="附录：算法的时间复杂度"></a>附录：算法的时间复杂度</h1><p>时间复杂度（Time Complexity）是算法分析中的一个重要概念，用于衡量算法在输入规模增大时所需执行时间的增长趋势。时间复杂度通常用大 O 表示法（Big O Notation）来表示，它描述了算法在最坏情况下的执行时间与输入规模之间的关系。</p>
<h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/09/20/66ed6760beca4.png" alt="image-20240920201450963"></p>
<p>以下是一些常见的时间复杂度及其对应的算法性能：</p>
<ol>
<li><p><strong>O(1) - 常数时间复杂度</strong>：</p>
<ul>
<li>算法的执行时间与输入规模无关，无论输入规模如何增大，执行时间都是固定的。</li>
<li>例如：访问数组中的某个元素、插入/删除链表中的某个节点。</li>
</ul>
</li>
<li><p><strong>O(log n) - 对数时间复杂度</strong>：</p>
<ul>
<li>算法的执行时间随输入规模的增大而增长，但增长速度较慢，通常是对数级别的增长。</li>
<li>例如：二分查找（Binary Search）。</li>
</ul>
</li>
<li><p><strong>O(n) - 线性时间复杂度</strong>：</p>
<ul>
<li>算法的执行时间与输入规模成正比，输入规模增大一倍，执行时间也增大一倍。</li>
<li>例如：遍历数组、线性查找（Linear Search）。</li>
</ul>
</li>
<li><p><strong>O(n log n) - 线性对数时间复杂度</strong>：</p>
<ul>
<li>算法的执行时间介于线性和平方之间，通常是一些高效排序算法的时间复杂度。</li>
<li>例如：快速排序（Quick Sort）、归并排序（Merge Sort）。</li>
</ul>
</li>
<li><p><strong>O(n^2) - 平方时间复杂度</strong>：</p>
<ul>
<li>算法的执行时间与输入规模的平方成正比，输入规模增大一倍，执行时间增大四倍。</li>
<li>例如：冒泡排序（Bubble Sort）、选择排序（Selection Sort）。</li>
</ul>
</li>
<li><p><strong>O(n^3) - 立方时间复杂度</strong>：</p>
<ul>
<li>算法的执行时间与输入规模的立方成正比，输入规模增大一倍，执行时间增大八倍。</li>
<li>例如：矩阵乘法。</li>
</ul>
</li>
<li><p><strong>O(2^n) - 指数时间复杂度</strong>：</p>
<ul>
<li>算法的执行时间随输入规模的增大呈指数级增长，通常是一些暴力搜索算法的时间复杂度。</li>
<li>例如：求解旅行商问题（TSP）的暴力解法。</li>
</ul>
</li>
<li><p><strong>O(n!) - 阶乘时间复杂度</strong>：</p>
<ul>
<li>算法的执行时间随输入规模的增大呈阶乘级增长，通常是一些组合问题的暴力解法。</li>
<li>例如：求解全排列问题的暴力解法。</li>
</ul>
</li>
</ol>
<h2 id="如何计算时间复杂度"><a href="#如何计算时间复杂度" class="headerlink" title="如何计算时间复杂度"></a>如何计算时间复杂度</h2><p>计算时间复杂度通常需要分析算法中的基本操作次数，并找出其与输入规模之间的关系。以下是一些常见的计算方法：</p>
<ol>
<li><p><strong>循环结构</strong>：</p>
<ul>
<li>单层循环的时间复杂度通常为 O(n)。</li>
<li>嵌套循环的时间复杂度通常为 O(n^k)，其中 k 是循环的层数。</li>
</ul>
</li>
<li><p><strong>递归结构</strong>：</p>
<ul>
<li>递归算法的时间复杂度通常需要通过递归关系式来求解，例如使用主定理（Master Theorem）。</li>
</ul>
</li>
<li><p><strong>分治法</strong>：</p>
<ul>
<li>分治法的时间复杂度通常可以通过递归关系式来求解，例如归并排序的时间复杂度为 O(n log n)。</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>时间复杂度是衡量算法性能的重要指标，它描述了算法在最坏情况下的执行时间与输入规模之间的关系。了解常见的时间复杂度及其对应的算法性能，有助于选择合适的算法来解决问题，并优化算法的执行效率。</p>
</div></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">時光</div><div class="post-copyright__author_desc">心寄朗朗乾坤，胸怀真修之道。</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.shiguang666.eu.org/2024/09/20/4ee543fd05bd/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.shiguang666.eu.org/2024/09/20/4ee543fd05bd/')">【尚硅谷】MySQL-索引的数据结构</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.shiguang666.eu.org/2024/09/20/4ee543fd05bd/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=【尚硅谷】MySQL-索引的数据结构&amp;url=https://blog.shiguang666.eu.org/2024/09/20/4ee543fd05bd/&amp;pic=https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.shiguang666.eu.org" target="_blank">時光</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/SQL/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>SQL<span class="tagsPageCount">12</span></a><a class="post-meta__box__tags" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>尚硅谷<span class="tagsPageCount">42</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img.shiguangdev.cn/i/2024/12/18/6762e71b2e658.webp" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/19/53c5980f1822/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/10/15/670e7e8ddffb4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">解决【Could not retrieve mirrorlist】问题及YUM镜像源配置</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/20/dbfa846f2f03/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【尚硅谷】MySQL-InnoDB数据存储结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/09/25/076bbddc6716/" title="【尚硅谷】MySQL-MySQL事务日志"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-25</div><div class="title">【尚硅谷】MySQL-MySQL事务日志</div></div></a></div><div><a href="/2024/09/26/f7ad294f7377/" title="【尚硅谷】MySQL-主从复制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-26</div><div class="title">【尚硅谷】MySQL-主从复制</div></div></a></div><div><a href="/2024/09/24/5ff69d1c35a3/" title="【尚硅谷】MySQL-事务基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-24</div><div class="title">【尚硅谷】MySQL-事务基础知识</div></div></a></div><div><a href="/2024/09/26/8aeb9df6c710/" title="【尚硅谷】MySQL-多版本并发控制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-26</div><div class="title">【尚硅谷】MySQL-多版本并发控制</div></div></a></div><div><a href="/2024/09/26/922071561806/" title="【尚硅谷】MySQL-其他数据库日志"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-26</div><div class="title">【尚硅谷】MySQL-其他数据库日志</div></div></a></div><div><a href="/2024/09/26/e441e650956c/" title="【尚硅谷】MySQL-数据库备份与恢复"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-26</div><div class="title">【尚硅谷】MySQL-数据库备份与恢复</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display: none">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://emotion.acs.pw/emotion/Heo/送福.png" alt="status"></div></div><div class="author-info__description">代码成就万事基积沙镇海,<br>梦想永在凌云意意气风发。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">時光</h1><div class="author-info__desc">心寄朗朗乾坤，胸怀真修之道。</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/shiguang-coding" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content"><span>🌟欢迎光临時光的博客园子🌟</span><br> <span><a target="_blank" rel="noopener" href="https://blog.shiguangdev.cn"><b>blog.shiguangdev.cn</b></a></span><br> <span><a target="_blank" rel="noopener" href="https://blog.shiguang88.icu"><b>blog.shiguang88.icu</b></a></span><br> <span><a href="https://blog.shiguang666.eu.org"><b>blog.shiguang666.eu.org</b></a></span><br> <span>🤔 如有问题欢迎评论区交流！</span><br> <span>📧 如需联系我：<a href="mailto:an_shiguang@163.com"><b>发送邮件🚀</b></a></span> <div id="welcome-info"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">1.</span> <span class="toc-text">为什么使用索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">索引及其优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">索引概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94"><span class="toc-number">3.</span> <span class="toc-text">InnoDB中索引的推演</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B9%8B%E5%89%8D%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">3.1.</span> <span class="toc-text">索引之前的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%A1%B5%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">3.1.1.</span> <span class="toc-text">在一个页中的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%BE%88%E5%A4%9A%E9%A1%B5%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-number">3.1.2.</span> <span class="toc-text">在很多页中查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.</span> <span class="toc-text">设计索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.1.</span> <span class="toc-text">一个简单的索引设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">数据页的连续性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.2.</span> <span class="toc-text">InnoDB中的索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E8%BF%AD%E4%BB%A31%E6%AC%A1%EF%BC%9A%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%BA%AA%E5%BD%95%E7%9A%84%E9%A1%B5"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">①  迭代1次：目录项纪录的页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E8%BF%AD%E4%BB%A32%E6%AC%A1%EF%BC%9A%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%BA%AA%E5%BD%95%E7%9A%84%E9%A1%B5"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">② 迭代2次：多个目录项纪录的页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E8%BF%AD%E4%BB%A33%E6%AC%A1%EF%BC%9A%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E9%A1%B5%E7%9A%84%E7%9B%AE%E5%BD%95%E9%A1%B5"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">③ 迭代3次：目录项记录页的目录页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-B-Tree"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">④ B+Tree</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.</span> <span class="toc-text">常见索引概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%88%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E3%80%81%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">二级索引（辅助索引、非聚簇索引）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">联合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.4.</span> <span class="toc-text">InnoDB的B+树索引的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B9%E9%A1%B5%E9%9D%A2%E4%BD%8D%E7%BD%AE%E4%B8%87%E5%B9%B4%E4%B8%8D%E5%8A%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. 根页面位置万年不动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. 内节点中目录项记录的唯一性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%80%E5%B0%91%E5%AD%98%E5%82%A8-2-%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">3. 一个页面最少存储 2 条记录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyISAM%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">4.</span> <span class="toc-text">MyISAM中的索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">MyISAM索引的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM-%E4%B8%8E-InnoDB%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.</span> <span class="toc-text">MyISAM 与 InnoDB对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">5.</span> <span class="toc-text">索引的代价</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">MySQL数据结构选择的合理性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.1.</span> <span class="toc-text">全表查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.2.</span> <span class="toc-text">Hash查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%BF%AB%E6%9F%A5%E6%89%BE%E9%80%9F%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%89%E4%B8%A4%E7%B1%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text">加快查找速度的数据结构，常见的有两类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%BB%93%E6%9E%84%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%8C%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E6%A0%91%E5%9E%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">6.2.2.</span> <span class="toc-text">Hash结构效率高，那为什么索引结构要设计成树型呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%82%E7%94%A8%E6%80%A7"><span class="toc-number">6.2.3.</span> <span class="toc-text">Hash索引的适用性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">6.3.</span> <span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.3.1.</span> <span class="toc-text">二叉搜索树的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%A7%84%E5%88%99"><span class="toc-number">6.3.2.</span> <span class="toc-text">查找规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88AVL%E6%A0%91%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">平衡树（AVL树）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-Tree"><span class="toc-number">6.5.</span> <span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-Tree-1"><span class="toc-number">6.6.</span> <span class="toc-text">B+Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R%E6%A0%91"><span class="toc-number">6.7.</span> <span class="toc-text">R树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">7.</span> <span class="toc-text">附录：算法的时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">7.1.</span> <span class="toc-text">常见的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">7.2.</span> <span class="toc-text">如何计算时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/18/59743779c169/" title="【白嫖福利】注册US.KG免费域名"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/18/6762e71b2e658.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【白嫖福利】注册US.KG免费域名"></a><div class="content"><a class="title" href="/2024/12/18/59743779c169/" title="【白嫖福利】注册US.KG免费域名">【白嫖福利】注册US.KG免费域名</a><time datetime="2024-12-18T14:53:30.000Z" title="发表于 2024-12-18 22:53:30">2024-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/16/d5e9d59f93d4/" title="博客、论坛必备：一键填充评论区昵称、邮箱、网址"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/16/675fdff3aa4bb.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客、论坛必备：一键填充评论区昵称、邮箱、网址"></a><div class="content"><a class="title" href="/2024/12/16/d5e9d59f93d4/" title="博客、论坛必备：一键填充评论区昵称、邮箱、网址">博客、论坛必备：一键填充评论区昵称、邮箱、网址</a><time datetime="2024-12-16T06:35:35.000Z" title="发表于 2024-12-16 14:35:35">2024-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/15/a9c615a71d17/" title="【智能协同云图库】3-用户模块"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756ee980378a.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【智能协同云图库】3-用户模块"></a><div class="content"><a class="title" href="/2024/12/15/a9c615a71d17/" title="【智能协同云图库】3-用户模块">【智能协同云图库】3-用户模块</a><time datetime="2024-12-15T03:12:06.000Z" title="发表于 2024-12-15 11:12:06">2024-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/13/2ec3ab3954b3/" title="通过SSH密钥连接Linux"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/13/675c5996649aa.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="通过SSH密钥连接Linux"></a><div class="content"><a class="title" href="/2024/12/13/2ec3ab3954b3/" title="通过SSH密钥连接Linux">通过SSH密钥连接Linux</a><time datetime="2024-12-13T15:37:00.000Z" title="发表于 2024-12-13 23:37:00">2024-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/13/0616411766f4/" title="【Hexo】一键部署至远程服务器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/13/675c59eff34f4.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Hexo】一键部署至远程服务器"></a><div class="content"><a class="title" href="/2024/12/13/0616411766f4/" title="【Hexo】一键部署至远程服务器">【Hexo】一键部署至远程服务器</a><time datetime="2024-12-13T13:35:49.000Z" title="发表于 2024-12-13 21:35:49">2024-12-13</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/shiguang-coding" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" href="mailto:an_shiguang@163.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" size="50px"><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html">开往</a><a class="footer-item" title="异次元之旅" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on">异次元之旅</a><a class="footer-item" title="列表导航" target="_blank" rel="noopener" href="https://zhblogs.ohyee.cc/">列表导航</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a></div></div><div class="footer-group"><div class="footer-title">文章</div><div class="footer-links"><a class="footer-item" title="归档" href="/archives/">归档</a><a class="footer-item" title="分类" href="/categories/">分类</a><a class="footer-item" title="标签" href="/tags/">标签</a><a class="footer-item" title="RSS" href="/tom.xml">RSS</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="留言板" href="/comment/">留言板</a><a class="footer-item" title="关于我" href="/about/">关于我</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"></a><a class="github-badge" target="_blank" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=blog.shiguangdev.cn" style="margin-inline:5px" data-title="萌ICP备20246006号" title="萌ICP备20246006号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/%E8%90%8Cicp%E5%A4%87-20246006%E5%8F%B7-FF1485" alt="萌ICP备20246006号"></a><a class="github-badge" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">©2023 - 2024 By <a class="footer-bar-link" href="/" title="時光" target="_blank">時光</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = []
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://img.shiguangdev.cn/" title="图床">图床</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="豫ICP备2024070732号">豫ICP备2024070732号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">257</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">188</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">16</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.shiguang666.eu.org" title="時光主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光主页"><span class="back-menu-item-text">時光主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://nav.shiguang666.eu.org" title="時光导航站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光导航站"><span class="back-menu-item-text">時光导航站</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://game.shiguang666.eu.org" title="怀旧游戏机"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="怀旧游戏机"><span class="back-menu-item-text">怀旧游戏机</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://umami.shiguangdev.cn/share/1CY8KW6pqM0UBUIL/blog.shiguangdev.cn" title="访客统计"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://umami.shiguangdev.cn/favicon.ico" alt="访客统计"><span class="back-menu-item-text">访客统计</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">后台管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://img.shiguangdev.cn/" title="時光图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/favicon.ico" alt="時光图床"><span class="back-menu-item-text">時光图床</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.shiguang666.eu.org/" title="Hexo管理面板"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://qexo.shiguang666.eu.org/favicon.ico" alt="Hexo管理面板"><span class="back-menu-item-text">Hexo管理面板</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随机</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/news/"><i class="fa fa-calendar faa-tada"></i><span> 早报亭</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=10051718332&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/xjj/"><i class="fa fa-rocket faa-tada"></i><span> 养生堂</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/flink/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comment/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>9</sup></a><a href="/tags/Alist/" style="font-size: 0.88rem;">Alist<sup>3</sup></a><a href="/tags/CentOS/" style="font-size: 0.88rem;">CentOS<sup>1</sup></a><a href="/tags/ChatGPT/" style="font-size: 0.88rem;">ChatGPT<sup>13</sup></a><a href="/tags/ChatGPt/" style="font-size: 0.88rem;">ChatGPt<sup>1</sup></a><a href="/tags/Chrome/" style="font-size: 0.88rem;">Chrome<sup>1</sup></a><a href="/tags/CloudFlare/" style="font-size: 0.88rem;">CloudFlare<sup>3</sup></a><a href="/tags/DNS/" style="font-size: 0.88rem;">DNS<sup>1</sup></a><a href="/tags/Ecology/" style="font-size: 0.88rem;">Ecology<sup>1</sup></a><a href="/tags/GPT-4o/" style="font-size: 0.88rem;">GPT-4o<sup>2</sup></a><a href="/tags/Gemini/" style="font-size: 0.88rem;">Gemini<sup>2</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>8</sup></a><a href="/tags/GitHub/" style="font-size: 0.88rem;">GitHub<sup>6</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>24</sup></a><a href="/tags/IDEA/" style="font-size: 0.88rem;">IDEA<sup>3</sup></a><a href="/tags/KeyBoardTestUtility/" style="font-size: 0.88rem;">KeyBoardTestUtility<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>4</sup></a><a href="/tags/Lombok/" style="font-size: 0.88rem;">Lombok<sup>1</sup></a><a href="/tags/Markdown/" style="font-size: 0.88rem;">Markdown<sup>2</sup></a><a href="/tags/MindManager/" style="font-size: 0.88rem;">MindManager<sup>1</sup></a><a href="/tags/Mysql/" style="font-size: 0.88rem;">Mysql<sup>2</sup></a><a href="/tags/Perplexity-AI/" style="font-size: 0.88rem;">Perplexity AI<sup>1</sup></a><a href="/tags/PicGo/" style="font-size: 0.88rem;">PicGo<sup>1</sup></a><a href="/tags/QQ/" style="font-size: 0.88rem;">QQ<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem;">SQL<sup>12</sup></a><a href="/tags/SSL/" style="font-size: 0.88rem;">SSL<sup>3</sup></a><a href="/tags/Sqlserver/" style="font-size: 0.88rem;">Sqlserver<sup>1</sup></a><a href="/tags/Typora/" style="font-size: 0.88rem;">Typora<sup>5</sup></a><a href="/tags/drawio/" style="font-size: 0.88rem;">drawio<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/svn/" style="font-size: 0.88rem;">svn<sup>2</sup></a><a href="/tags/%E5%9B%BE%E5%90%A7%E5%B7%A5%E5%85%B7%E7%AE%B1/" style="font-size: 0.88rem;">图吧工具箱<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">图床<sup>7</sup></a><a href="/tags/%E5%BC%80%E6%BA%90%E5%88%86%E4%BA%AB/" style="font-size: 0.88rem;">开源分享<sup>6</sup></a><a href="/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/" style="font-size: 0.88rem;">搜索引擎<sup>2</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/" style="font-size: 0.88rem;">数据恢复<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">模板<sup>4</sup></a><a href="/tags/%E8%B8%A9%E5%9D%91/" style="font-size: 0.88rem;">踩坑<sup>6</sup></a><a href="/tags/%E9%B1%BC%E7%9A%AE/" style="font-size: 0.88rem;">鱼皮<sup>11</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="10051718332" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/my/m/music/playlist?id=10051718332&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async="" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("05/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 時光 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async="" src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.shiguangdev.eu.org',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.shiguangdev.eu.org',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async="" src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.shiguangdev.eu.org',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async="" data-pjax="" src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/custom/footer-animal.js" defer=""></script><script src="/api/card-welcome.js"></script><script id="click-heart" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><!-- hexo injector body_end start -->
  <script data-pjax="" src="/js/hexo_githubcalendar.js"></script>
  <script data-pjax="">
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://githubcalendarapi.shiguang666.eu.org/api?user=shiguang-coding";
            var git_color =['#ebedf0', '#a2f7af', '#6ce480', '#54ad63', '#469252', '#31753c', '#1f5f2a', '#13531f', '#084111', '#032b09', '#000000'];
            var git_user ="shiguang-coding";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar");
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end -->
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = '75439fb77e5551eacf54f0df75565616dcf2ad';
        let tianliGPT_postSelector = '#article-container';
        let tianliGPT_Title = '文章摘要';
        let tianliGPT_postURL = '/^https?://[^/]+/[0-9]{4}/[0-9]{2}/[0-9]{2}/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '1000';
        let tianliGPT_typingAnimate = true;
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: true,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "PostChat",
          userDesc: "如果你对网站的内容有任何疑问，可以来问我哦～",
          addButton: true,
          beginningText: "这篇文章介绍了"
        };
    </script>
    <script data-postchat_key="75439fb77e5551eacf54f0df75565616dcf2ad" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>
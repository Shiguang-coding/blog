<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>【尚硅谷】JUC基础篇(2021版) | 時光</title><meta name="keywords" content="JAVA,尚硅谷,JUC"><meta name="author" content="時光"><meta name="copyright" content="時光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="【尚硅谷】JUC基础篇(2021版)"><meta name="application-name" content="【尚硅谷】JUC基础篇(2021版)"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="【尚硅谷】JUC基础篇(2021版)"><meta property="og:url" content="https://blog.shiguang666.eu.org/2024/12/09/f69225d19caa/index.html"><meta property="og:site_name" content="時光"><meta property="og:description" content="大厂必备技术之JUC并发编程 B站直达 2021版: 【尚硅谷】大厂必备技术之JUC并发编程 2022版: 尚硅谷JUC并发编程（对标阿里P6-P7） 课程资料 2021版：尚硅谷高级技术之JUC高并发编程2021最新版 2022版：尚硅谷JUC并发编程与源码分析2022 代码仓库 GitHub:"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg"><meta property="article:author" content="時光"><meta property="article:tag" content="博客,時光,時光的博客,時光博客园子,实用博客,开源,共享"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg"><meta name="description" content="大厂必备技术之JUC并发编程 B站直达 2021版: 【尚硅谷】大厂必备技术之JUC并发编程 2022版: 尚硅谷JUC并发编程（对标阿里P6-P7） 课程资料 2021版：尚硅谷高级技术之JUC高并发编程2021最新版 2022版：尚硅谷JUC并发编程与源码分析2022 代码仓库 GitHub:"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.shiguang666.eu.org/2024/12/09/f69225d19caa/"><link rel="preconnect" href="//cdn.cbd.int"><meta name="google-site-verification" content="xxx"><meta name="baidu-site-verification" content="code-xxx"><meta name="msvalidate.01" content="xxx"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与各类博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.shiguangdev.eu.org',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🌟 技术分享领航人","📚 终身学习倡导者","💡 创新思维启发源","📈 成长路径引路人","🚀 科技趋势探索者","🤖️ AI技术探索先锋","🌈 技术创新推动手","💬 社区互动活跃家","🛠️ 代码经验传授师","📢 知识传播倡导员"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":300,"languages":{"author":"作者: 時光","link":"链接: ","source":"来源: 時光","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '時光',
  title: '【尚硅谷】JUC基础篇(2021版)',
  postAI: '',
  pageFillDescription: '大厂必备技术之JUC并发编程, 1、什么是JUC, 1.1、JUC简介, 1.2、进程与线程, 1.3、线程的状态, 1.3.1、线程状态枚举类, 1.3.2、wait和sleep的区别, 1.4、并发与并行, 1.4.1、串行模式, 1.4.2、并行模式, 1.4.3、并发, 1.4.4、小结（重点）, 1.5、管程, 1.6、用户线程和守护线程, 2、Lock接口, 2.1、Synchronized, 2.1.1 Synchronized关键字回顾, 2.1.2、使用synchronized实现售票案例, 2.2、什么是Lock, 2.3、ReentrantLock, 2.3.1、ReentrantLock介绍, 2.3.2、售票案例, 2.4、ReadWriteLock, 2.4.1、ReadWriteLock介绍, 2.4.2、售票案例, 2.5、 小结（重点）, 3、线程间通信, 3.1、线程间通信案例, 3.2、虚假唤醒问题, 3.3、ReentrantLock实现线程间通信, 4、线程间定制化通信, 4.1、案例分析, 4.2、案例实现, 5、集合的线程安全, 5.1、ArrayList集合线程不安全演示, 5.1.1、解决方案-Vector, 5.1.2、解决方案-Collections, 5.1.3、解决方案-CopyOnWriteArrayList, 5.2、HashSet集合线程不安全演示, 5.2.1、解决方案-CopyOnWriteArraySet, 5.3、HashMap集合线程不安全演示, 5.3.1、解决方案-Collections, 5.3.2、解决方案-ConcurrentHashMap, 6、多线程锁, 6.1、锁的8种情况, 6.2、公平锁和非公平锁, 6.2.1、公平锁（Fair Lock）, 6.2.2、非公平锁（Non-fair Lock）, 6.2.3、总结, 6.3、可重入锁（Reentrant Lock）, 6.3.1、synchronized可重用锁（隐式）, 6.3.2、Lock可重用锁（显示）, 6.4、死锁（Deadlock）, 6.4.1、死锁的示例, 6.4.2、如何避免死锁, 6.4.3、如何检测死锁, 7、Callable接口, 7.1、测试案例, 7.2、Callable接口的特点如下（重点）, 7.3、Callable 与 Runnable 的区别, 7.4、FutureTask介绍, 8、JUC强大的辅助类, 8.1、减少技术CountDownLatch, 8.1.1、锁门案例, 8.2、循环栅栏CyclicBarrier, 8.2.1、召唤神龙案例, 8.3、信号灯Semaphore, 8.3.1、案例, 9、ReentrantReadWriteLock读写锁, 9.1、乐观锁和悲观锁, 9.1.1、悲观锁（Pessimistic Locking）, 9.1.2、乐观锁（Optimistic Locking）, 9.1.3、乐观锁与悲观锁的对比, 9.1.4、乐观锁的实现示例（版本号机制）, 9.1.5、悲观锁的实现示例（synchronized）, 9.1.6、总结, 9.2、表锁和行锁, 9.2.1、表锁（Table Lock）, 9.2.2、行锁（Row Lock）, 9.2.3、 表锁与行锁的对比, 9.2.4、 表锁与行锁的使用示例, 9.2.5、 表锁与行锁的实际应用, 9.2.6、 总结, 9.3、读写锁, 9.3.1、读写锁的基本概念, 9.3.2、读写锁的优点, 9.3.3、读写锁的实现, 9.3.4、读写锁的使用示例, 9.3.5、读写锁的规则, 9.3.6、读写锁的适用场景, 9.3.7、读写锁的缺点, 9.3.8、读写锁与其他锁的对比, 9.3.9、读写锁降级, 3.9.10、读写锁演变, 10、阻塞队列（BlockingQueue）, 10.1、BlockingQueue简介, 10.2、阻塞队列的使用示例, 10.3、BlockingQueue核心方法, 10.4、常见的BlockingQueue, 10.4.1、ArrayBlockingQueue（常用）, 10.4.2、LinkedBlockingQueue（常用）, 10.4.3、PriorityBlockingQueue, 10.4.4、DelayQueue, 10.4.5、SynchronousQueue, 10.4.6、LinkedTransferQueue, 10.4.7、LinkedBlockingDeque, 11、线程池（ThreadPool), 11.1、 线程池的基本概念, 11.1.1、 为什么要使用线程池？, 11.1.2、 线程池的核心组件, 11.1.3、线程池的优缺点及使用场景, 11.2、 线程池的接口和实现类, 11.2.1、 Executor 接口, 11.2.2、 ExecutorService 接口, 11.2.3、 常见的实现类, 11.3、线程池的工作原理, 11.3.1、线程池的生命周期, 11.3.2、任务的执行流程, 11.4、线程池的参数及自定义线程池, 11.4.1、线程池的参数, 11.4.2、自定义线程池, 11.5、线程池的拒绝策略, 11.6、线程池的使用示例, 12、分支合并框架（Forkx2FJoin）, 12.1、Forkx2FJoin框架简介, 12.1.1、 分治算法, 12.1.2、工作窃取算法（Work-Stealing）, 12.1.3、Forkx2FJoin 框架的优缺点及适用场景, 12.2、Forkx2FJoin 框架的核心组件, 12.2.1、ForkJoinPool, 12.2.2、ForkJoinTask, 12.3、Forkx2FJoin 框架的工作原理, 12.3.1、任务拆分, 12.3.2、任务执行, 12.3.3、任务合并, 12.4、Forkx2FJoin 框架的使用示例, 12.4.1、课程案例, 12.4.2、计算数组元素的和, 12.4.3、归并排序, 13、异步回调（CompletableFuture）, 13.1、 CompletableFuture 的基本概念, 13.1.1、什么是 CompletableFuture？, 13.1.2、CompletableFuture 的优缺点及适用场景, 13.1.3、与传统 Future 的区别, 13.2、CompletableFuture 的核心功能, 13.2.1、创建 CompletableFuture, 13.2.2、完成任务, 13.2.3、获取结果, 13.2.4、链式调用, 13.2.5、任务组合, 13.2.6、异常处理, 13.3、 CompletableFuture 的使用示例, 13.3.1、课程案例, 13.3.2、简单异步任务, 13.3.3、任务组合大厂必备技术之并发编程站直达版尚硅谷大厂必备技术之并发编程版尚硅谷并发编程对标阿里课程资料版尚硅谷高级技术之高并发编程最新版版尚硅谷并发编程与源码分析代码仓库什么是简介中文在线文档在中线程部分是一个重点本篇文章说的也是关于线程的就是工具包的简称这是一个处理线程的工具包开始出现的进程与线程进程是计算机中的程序关于某数据集合上的一次运行活动是系统进行资源分配和调度的基本单位是操作系统结构的基础在早期面向进程设计的计算机结构中进程是程序的基本执行实体在当代面向线程设计的计算机结构中进程是线程的容器程序是指令数据及其组织形式的描述进程是程序的实体线程英语是操作系统能够进行运算调度的最小单位它被包含在进程之中是进程中的实际运作单位一条线程指的是进程中一个单一顺序的控制流一个进程中可以并发多个线程每条线程并行执行不同的任务总结来说进程指在系统中正在运行的一个应用程序程序一旦运行就是进程进程是资源分配的最小单位线程系统分配处理器时间资源的基本单元或者说进程之内独立执行的一个单元执行流线程是程序执行的最小单位线程的状态线程状态枚举类进入类找到内部类代码如下新建准备就绪阻塞等待不见不散带时间的等待过时不候终结和的区别是的静态方法是的方法任何对象实例都能调用不会释放锁它也不需要占用锁会释放锁但调用它的前提是当前线程占有锁即代码要在中它们都可以被方法中断并发与并行串行模式串行是一次只能取得一个任务并执行这个任务串行表示所有任务都一一按先后顺序进行串行意味看必须先装完一车柴才能运送这车柴只有运送到了才能卸下这车柴并且只有完成了这整个三个步骤才能进行下一个步骤并行模式并行意味着可以同时取得多个任务并同时去执行所取得的这些任务并行模式相当于将长长的一条队列划分成了多条短队列所以并行缩短了任务队列的长度并行的效率从代码层次上强依赖于多进程多线程代码从硬件角度上则依赖于多核并发并发指的是多个程序可以同时运行的现象更细化的是多进程可以同时运行或者多指令可以同时运行但这不是重点在描述并发的时候也不会去扣这种字眼是否精确并发的重点在于它是一种现象并发描述的是多进程同时运行的现象但实际上对于单核心来说同一时刻只能运行一个线程所以这里的同时运行表示的不是真的同一时刻有多个线程运行的现象这是并行的概念而是提供一种功能让用户看来多个程序同时运行起来了但实际上这些程序中的进程不是一直霸占的而是执行一会停一会线程的上下文切换要解决大并发问题通常是将大任务分解成多个小任务由于操作系统对进程的调度是随机的所以切分成多个小任务后可能会从任一小任务处执行这可能会出现一些现象可能出现一个小任务执行了多次还没开始下个任务的情况这时一般会采用队列或类似的数据结构来存放各个小任务的成果可能出现还没准备好第一步就执行第二步的可能这时一般采用多路复用或异步的方式比如只有准备好产生了事件通知才执行某个任务可以多进程多线程的方式并行执行这些小任务也可以单进程单线程执行这些小任务这时很可能要配合多路复用才能达到较高的效率小结重点并发同一时刻多个线程在访问同一个资源多个线程对一个点例子春运抢票电商秒杀并行多项工作一起执行之后再汇总例子泡方便面电水壶烧水一边撕调料倒入桶中管程即监视器即平时所说的锁是一种同步机制保证同一时间只有一个线程访问被保护的数据或代码中的同步基于进入和退出管程对象来实现的用户线程和守护线程用户线程即自定义线程平时所用到的线程基本都是用户线程主线程结束了用户线程还在运行存活守护线程是一种特殊的线程在后台运行的线程比如垃圾回收没有用户线程了都是守护线程结束举例说明是否为守护线程设置为守护线程在线程启动之前设置接口关键字回顾是中的关键字是一种同步锁它修饰的对象有以下几种修饰一个代码块被修饰的代码块称为同步语句块其作用的范围是大括号括起来的代码作用的对象是调用这个代码块的对象修饰一个方法被修饰的方法称为同步方法其作用的范围是整个方法作用的对象是调用这个方法的对象虽然可以使用来定义方法但并不属于方法定义的一部分因此关键字不能被继承如果在父类中的某个方法使用了关键字而在子类中覆盖了这个方法在子类中的这个方法默认情况下并不是同步的而必须显式地在子类的这个方法中加上关键字才可以当然还可以在子类方法中调用父类中相应的方法这样虽然子类中的方法不是同步的但子类调用了父类的同步方法因此子类的方法也就相当于同步了修饰一个静态的方法其作用的范围是整个静态方法作用的对象是这个类的所有对象修饰一个类其作用的范围是后面括号括起来的部分作用主的对象是这个类的所有对象使用实现售票案例多线程的编程步骤第一步创建一个资源类属性和操作方法第二步创建多个线程调用类里面的操作方法第一步创建资源类定义属性和操作方法票数卖票操作卖出了第张票剩余第二步创建多个线程调用资源类的操作方法创建对象创建三个线程什么是锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作它们允许更灵活的结构可能具有非常不同的属性并且可能支持多个关联的条件对象提供了比更多的功能与的区别不是语言内置的是语言的关键字因此是内置特性是一个类通过这个类可以实现同步访问和有一点非常大的不同采用不需要用户去手动释放锁当方法或者代码块执行完之后系统会自动让线程释放对锁的占用而则必须要用户去手动释放锁如果没有主动释放锁就有可能导致出现死锁现象介绍是中的一个可重入锁实现了接口可重入意味着同一个线程可以多次获取同一个锁而不会造成死锁每次获取锁时锁的持有计数会增加每次释放锁时持有计数会减少当持有计数为时锁被完全释放优点提供了比关键字更灵活的锁操作例如可中断的锁获取超时等待锁公平锁和非公平锁的选择等可以使用方法尝试获取锁避免了线程的无限期等待使用示例临界区代码需要同步的部分代码解释创建一个实例获取锁如果锁已被其他线程持有则当前线程会阻塞直到获取到锁在块中执行需要同步的代码确保在块中释放锁以防止死锁尝试获取锁如果锁可用则立即返回否则返回不会阻塞线程使用场景当需要更灵活的锁操作如可中断的锁获取超时等待锁公平锁等时使用比更合适在复杂的同步场景中如条件变量的使用提供了更强大的功能注意事项务必在块中释放锁以确保锁最终会被释放避免死锁对于简单的同步需求可能更简洁但对于复杂的同步需求提供了更多的控制和功能售票案例第一步创建资源类定义属性和操作方法票数创建可重用锁卖票操作加锁判断是否有票卖出了第张票剩余解锁第二步创建多个线程调用资源类的操作方法创建三个线程介绍是中的一个接口它维护了一对关联的锁一个用于只读操作一个用于写入操作其主要目的是在多线程环境下允许多个线程同时读取共享数据但在写入数据时需要独占访问以保证数据的一致性和完整性常见的实现类是它提供了可重入的读写锁功能优点提高并发性能在多读少写的场景下使用可以显著提高程序的并发性能因为多个读线程可以同时访问共享资源而不会互相阻塞数据一致性在写操作时通过独占锁保证数据的一致性避免了多个线程同时修改数据导致的数据不一致问题使用示例读操作多个读线程可以同时进入这里写操作只有一个写线程可以进入这里代码解释创建个实例获取读锁多个读线程可以同时获取读锁只要没有写线程特有写锁释放读锁获取写锁只有一个写线程可以获取写锁并且在写锁被持有时其他读线程和写线程都将被阻塞释放写锁售票案例将替换为使用进行写操作卖票操作因为卖票会修改票数属干写操作在方法中使用进行加锁和解锁操作其他部分代码保持不变第一步创建资源类定义属性和操作方法票数创建可重用读写锁卖票操作获取写锁判断是否有票卖出了第张票剩余释放写锁第二步创建多个线程调用资源类的操作方法创建三个线程使用场景适用于读操作颇繁写操作较少的场景例收如缓存系统配置信息读取等注意事项读锁和写锁的使用要注意正确的加锁和解锁顺序避免死锁写锁是独占的会阻塞其他读锁和写锁所以要确保写操作的时间尽量短以提高并发性能小结重点和有以下几点不同是一个接口而是中的关键字是内置的语言实现在发生异常时会自动释放线程占有的锁因此不会导致死锁现象发生而在发生异常时如果没有主动通过去释放锁则很可能造成死锁现象因此使用时需要在块中释放锁可以让等待锁的线程响应中断而却不行使用时等待的线程会一直等待下去不能够响应中断通过可以知道有没有成功获取锁而却无法办到可以提高多个线程进行读操作的效率在性能上来说如果竞争资源不激烈两者的性能是差不多的而当竞争资源非常激烈时即有大量线程同时竞争此时的性能要远远优于线程间通信线程间通信案例多线程编程步骤中可在写操作方法时再归纳一个步骤即判断干活通知示例如下第一步创建资源类定义属性和操作方法初始值的方法第二步判断干活通知判断值是否为不为则等待等待干活通知其他线程的方法第二步判断干活通知判断值是否为不为则等待等待干活通知其他线程第三步创建多个线程调用资源类的操作方法创建对象虚假唤醒问题我们多复制一份代码再引入两个线程分别两个线程进行加操作两个线程进行减操作第一步创建资源类定义属性和操作方法初始值的方法第二步判断干活通知判断值是否为不为则等待等待干活通知其他线程的方法第二步判断干活通知判断值是否为不为则等待等待干活通知其他线程第三步创建多个线程调用资源类的操作方法创建对象运行结果如下可见出现了错误情况数值超过一或者数值小于产生问题的原因是因为出现了虚假唤醒的情况在多线程编程中尤其是使用和或进行线程间通信时可能会出现虚假唤醒的情况虚假唤醒就是在多线程执行过程中线程间的通信未按照我们预想的顺序唤醒故出现数据不一致等不符合我们预期的结果例如我们的想法是加和减交替执行但执行结果出现了超过的数或者小于的数在上述代码中如果使用语句进行条件判断当线程被虚假唤醒时它会继续执行之后的代码而不重新检查条件这可能导致程序逻辑错误例如的值不符合预期这是因为方法在哪里等待就在哪里唤醒应该使用循环代替进行条件判断以防止虚假唤醒的方法第二步判断干活通知判断值是否为不为则等待等待干活通知其他线程的方法第二步判断干活通知判断值是否为不为则等待等待干活通知其他线程此时多线程编程步骤可再多加个步骤即使用循环代替进行条件判断防止虚假唤醒问题实现线程间通信第一步创建资源类定义属性和操作方法初始值创建的方法上锁判断干活通知解锁的方法上锁判断干活通知解锁创建对象线程间定制化通信案例分析案例实现第一步创建资源类定义属性和操作方法定义标志位创建锁创建三个打印次参数第几轮上锁判断干活轮数通知解锁打印次参数第几轮上锁判断干活轮数通知解锁打印次参数第几轮上锁判断干活轮数通知解锁创建对象集合的线程安全集合线程不安全演示中方法定义如下没有加关键字是非线程安全的方法问题代码案例集合线程不安全问题异常时终止程序表示正常终止非零值表示异常终止可能会出现的异常如下解决方案中方法定义如下添加了关键字是线程安全的方法代码示例异常时终止程序表示正常终止非零值表示异常终止多次执行未出现异常情况解决方案异常时终止程序表示正常终止非零值表示异常终止解决方案即写时复制写时复制一份在复制的这一份中写入新内容最后覆盖合并之前的内容即兼顾了并发读也照顾了独立的写操作代码示例异常时终止程序表示正常终止非零值表示异常终止集合线程不安全演示使用集合线程不安全问题异常时终止程序表示正常终止非零值表示异常终止多次执行可能出现如下异常解决方案异常时终止程序表示正常终止非零值表示异常终止集合线程不安全演示使用集合线程不安全问题异常时终止程序表示正常终止非零值表示异常终止多次执行可能出现如下异常解决方案异常时终止程序表示正常终止非零值表示异常终止解决方案异常时终止程序表示正常终止非零值表示异常终止多线程锁锁的种情况停秒发短信发邮件种锁的总结标准访问先打印短信还是邮件发短信发邮件停秒在短信方法内先打印短后还是邮件发短信发邮件新增誉通方法还是先打短后还是发短信现在有两部手机先打印短信还是邮件发邮件发短信两个静态同步方法部手机先打印短层还是邮件发短信发邮件两个静态同步方法部手机先打印短层还是邮件发短信发邮件个静态同步方法个普通同步方法部手机先打印短信后还是邮件发邮件发短信个静态同步方法个普通同步方法部手机先打印短信后还是邮件发邮件发短信结论实现同步的基础中的每一个对象都可以作为锁具体表现为以下种形式对于普通同步方法锁是当前实例对象对于静态同步方法锁是当前类的对象对于同步方法块锁是括号里配置的对象公平锁和非公平锁在并发编程中公平锁和非公平锁是两种常见的锁机制它们主要用于控制多个线程对共享资源的访问顺序公平锁定义公平锁是指多个线程按照请求锁的顺序来获取锁即先请求的线程先获得锁特点顺序性线程按照请求锁的顺序排队先到先得公平性避免了线程饥饿即某个线程长时间无法获得锁的情况性能开销由于需要维护一个有序的队列公平锁的性能通常比非公平锁差因为每次获取锁时都需要检查队列并进行相应的操作适用场景当系统对线程的执行顺序有严格要求时或者需要避免线程饥饿时可以使用公平锁示例在中可以通过构造函数指定为公平锁表示公平锁非公平锁定义非公平锁是指多个线程获取锁的顺序不一定是按照请求锁的顺序即线程可以插队获取锁特点无序性线程获取锁的顺序不固定新来的线程有可能在当前持有锁的线程释放锁后立即获取锁而不需要排队性能优势由于不需要维护有序队列非公平锁的性能通常比公平锁好尤其是在高并发环境下因为减少了线程上下文切换的开销可能的饥饿问题某些线程可能会长时间无法获得锁导致线程饥饿适用场景当系统对线程的执行顺序没有严格要求且希望提高并发性能时可以使用非公平锁示例在中默认是非公平锁表示非公平锁默认就是总结公平锁按照请求顺序获取锁避免线程饥饿但性能较差非公平锁不按照请求顺序获取锁性能较好但可能导致线程饥饿选择公平锁还是非公平锁取决于具体的应用场景和性能需求在大多数情况下非公平锁是更好的选择因为它提供了更好的性能但在某些需要严格顺序控制或避免线程饥饿的场景中公平锁可能更合适可重入锁定义可重入锁是一种特殊的锁机制它允许同一个线程多次获取同一个锁而不会导致死锁换句话说如果一个线程已经持有了某个锁它可以再次获取该锁而不会被阻塞特点可重入性同一个线程可以多次获取同一个锁而不会被自己阻塞计数机制每次线程获取锁时锁的计数器会加每次线程释放锁时计数器会减只有当计数器归零时锁才会被完全释放避免死锁可重入锁避免了线程在获取自己已经持有的锁时发生死锁的情况适用场景递归调用在递归方法中同一个线程可能会多次进入需要加锁的代码块嵌套锁在复杂的并发场景中同一个线程可能会在不同的代码块中多次获取同一个锁示例在中是一个典型的可重入锁实现调用另一个需要加锁的方法在这个例子中和都使用了同一个实例由于是可重入的可以在已经持有锁的情况下再次获取锁而不会导致死锁可重入锁的优势避免死锁可重入锁允许线程多次获取同一个锁避免了因递归调用或嵌套锁导致的死锁问题简化编程开发人员不需要担心同一个线程在不同代码块中多次获取锁的问题简化了并发编程的复杂性灵活性可重入锁提供了更高的灵活性适用于各种复杂的并发场景总结可重入锁是一种允许同一个线程多次获取同一个锁的机制它通过计数机制来管理锁的获取和释放避免了死锁问题简化了并发编程的复杂性在中是一个典型的可重入锁实现广泛应用于各种并发场景中可重用锁隐式可重用锁外层中层内层可重用锁显示演示可重用锁外层内层注意上锁与解锁需要配套使用若只有一个线程不释放锁也可以正常执行若有多个线程使用同一把锁不释放锁会阻塞其他线程正常执行死锁定义死锁是指两个或多个线程在执行过程中因争夺资源而造成的一种互相等待的现象若无外力作用这些线程将无法继续执行死锁的四个必要条件互斥条件资源不能被共享只能由一个线程使用请求与保持条件线程已经持有一个资源但又提出了新的资源请求而该资源被其他线程占用此时请求线程阻塞但对自己已获得的资源保持不放不剥夺条件线程已获得的资源在未使用完之前不能被其他线程强行剥夺只能由自己释放循环等待条件若干线程之间形成一种头尾相接的循环等待资源关系死锁的示例以下是一个简单的示例展示了如何通过不当的资源管理导致死锁模拟一些工作模拟一些工作在这个例子中和分别尝试获取和但由于它们的获取顺序不同最终会导致死锁先获取然后尝试获取先获取然后尝试获取由于两个线程都在等待对方释放资源因此它们都无法继续执行形成了死锁如何避免死锁避免嵌套锁尽量减少锁的嵌套使用避免多个线程同时持有多个锁统一锁顺序如果必须使用多个锁确保所有线程以相同的顺序获取锁避免循环等待使用定时锁在获取锁时设置超时时间如果无法在规定时间内获取锁则放弃并重试使用可重入锁可重入锁允许线程多次获取同一个锁避免了因递归调用或嵌套锁导致的死锁问题资源分级将资源进行分级高优先级的资源先获取低优先级的资源后获取以下是一个避免死锁的示例通过统一锁顺序来避免死锁模拟一些工作模拟一些工作在这个例子中和都以相同的顺序获取和从而避免了死锁如何检测死锁可以使用和命令检测需要将的目录添加到系统环境变量执行程序后在终端执行命令找到要检测的程序进程号例如此处我要查看的是这个类可以看到进程号是使用命令可以看到输出了接口目前我们学习了有两种创建线程的方法一种是通过创建类另一种是通过使用创建线程但是缺少的一项功能是当线程终止时即完成时我们无法使线程返回结果为了支持此功能中提供了接口测试案例比较和的区别不能直接通过调用方法需要借助是的实现类其构造可以接受的实现类表达式等待执行完成再次调用执行结果会直接返回缓存的结果不会重新调用接口的特点如下重点为了实现需要实现不返回任何内容的方法而对于需要实现在完成时返回结果的方法方法可以引发异常而则不能为实现而必须重写方法与的区别特性实现方式方法方法返回值可以返回结果通过方法无返回值方法无返回值异常处理可以抛出受检异常方法不能抛出受检异常方法使用场景需要返回结果或可能抛出异常的任务不需要返回结果的任务介绍是并发编程中的一个重要类位于包中它是接口的实现类同时也是接口的实现类的主要作用是封装一个可以异步执行的任务并提供对任务执行状态和结果的管理的定义实现了以下接口接口继承了和接口因此既可以作为任务被执行也可以管理任务的状态和结果的构造方法可以接受一个或对象构造方法构造方法的核心功能的主要功能包括任务执行可以封装一个或任务并由线程池或单独的线程执行状态管理管理任务的执行状态包括未启动任务还未开始执行运行中任务正在执行已完成任务执行完成正常完成异常完成或被取消结果获取通过接口的方法如获取任务的执行结果取消任务可以通过方法取消任务的执行的核心功能的主要功能包括任务执行可以封装一个或任务并由线程池或单独的线程执行状态管理管理任务的执行状态包括未启动任务还未开始执行运行中任务正在执行已完成任务执行完成正常完成异常完成或被取消结果获取通过接口的方法如获取任务的执行结果取消任务可以通过方法取消任务的执行强大的辅助类减少技术类可以设置一个计数器然后通过方法来进行减的操作使用方法等待计数器不大于然后继续执行方法之后的语句主要有两个方法当一个或多个线程调用方法时这些线程会阻塞其它线程调用方法会将计数器减调用方法的线程不会阻塞当计数器的值变为时因方法阻塞的线程会被唤醒继续执行锁门案例要求教室内有一个班长和名同学名同学陆续离开教室全部离开教室后班长进行锁门操作个同学陆续离开教室后班长才锁门号同学离开了教室班长锁门了执行结果可以看到其他同学还没有离开教室班长就已经锁门了不符合我们的预期要求接下来再看下使用来实现该案例个同学陆续离开教室后班长才锁门创建对象设置初始值为号同学离开了教室计数器减一等待计数器归零班长锁门了运行结果可以看到同学离开的顺序随机全部同学离开后班长锁门符合我们的预期循环栅栏看英文单词可以看出大概就是循环阻塞的意思在使用中的构造方法第一个参数是目标障碍数每次执行一次障碍数会加一如果达到了目标障碍数才会执行之后的语句可以将理解为加操作召唤神龙案例要求集齐颗龙珠后方可召唤神龙集齐颗龙珠后方可召唤神龙龙珠已集齐召唤神龙集齐颗龙珠的过程星龙被收集到了执行结果信号灯案例要求辆车停个车位辆车停个车位创建对象设置许可数量模拟辆车抢占抢到了车位设置随机停车时间离开了车位释放运行结果读写锁乐观锁和悲观锁在并发编程中乐观锁和悲观锁是两种常见的并发控制策略用于解决多个线程对共享资源的访问冲突问题它们的区别主要在于对资源竞争的态度和处理方式悲观锁基本概念悲观锁是一种悲观的并发控制策略假设在任何时候都可能发生资源竞争因此在访问共享资源时会立即加锁以防止其他线程访问工作原理加锁在访问共享资源之前先获取锁独占访问在持有锁的期间其他线程无法访问该资源解锁操作完成后释放锁允许其他线程获取锁实现方式悲观锁通常通过以下方式实现数据库锁如行锁表锁锁如关键字优点安全性高能够有效避免资源竞争问题保证数据一致性简单易用实现简单适合对资源竞争频繁的场景缺点性能开销频繁加锁和解锁会导致性能下降并发性低独占访问会降低系统的并发性能适用场景写操作频繁当写操作较多时悲观锁可以有效避免数据冲突资源竞争激烈当多个线程频繁竞争同一资源时乐观锁基本概念乐观锁是一种乐观的并发控制策略假设在大多数情况下不会发生资源竞争因此在访问共享资源时不会立即加锁而是在提交操作时检查是否有冲突工作原理无锁访问在访问共享资源时不加锁允许多个线程同时访问冲突检测在提交操作时检查资源是否被其他线程修改重试机制如果检测到冲突则回滚操作并重试实现方式乐观锁通常通过以下方式实现版本号机制在数据中添加一个版本号字段每次更新时检查版本号是否一致通过硬件级别的原子操作实现无锁更新优点性能高在资源竞争不激烈的情况下性能优于悲观锁并发性好允许多个线程同时访问资源提高了并发性能缺点复杂性高需要实现冲突检测和重试机制实现较为复杂适用性有限适用于读多写少的场景写操作频繁时性能可能下降适用场景读操作频繁当读操作远远多于写操作时乐观锁可以显著提高性能资源竞争不激烈当多个线程对同一资源的竞争较少时乐观锁与悲观锁的对比特性悲观锁乐观锁资源访问访问前加锁独占访问访问时不加锁允许多线程同时访问冲突处理通过加锁避免冲突通过冲突检测和重试机制处理冲突性能写操作频繁时性能较好读操作频繁时性能较好实现复杂性实现简单适合资源竞争频繁的场景实现复杂适合资源竞争不激烈的场景适用场景写操作频繁资源竞争激烈的场景读操作频繁资源竞争不激烈的场景乐观锁的实现示例版本号机制以下是一个使用版本号机制实现乐观锁的示例版本号匹配更新数据更新版本号版本号不匹配更新失败线程尝试更新数据线程尝试更新数据悲观锁的实现示例以下是一个使用实现悲观锁的示例加锁独占访问加锁独占访问线程更新数据线程读取数据总结悲观锁假设资源竞争频繁通过加锁避免冲突适合写操作频繁的场景乐观锁假设资源竞争不频繁通过冲突检测处理冲突适合读操作频繁的场景在实际应用中选择乐观锁还是悲观锁需要根据具体的业务场景和资源竞争情况来决定如果写操作较多悲观锁是更好的选择如果读操作较多乐观锁可以显著提高性能表锁和行锁在数据库管理系统中表锁和行锁是两种常见的锁机制用于控制并发事务对数据库表和行的访问它们的主要目的是确保数据的一致性和完整性同时避免并发操作导致的冲突问题表锁基本概念表锁是对整个数据库表加锁的机制当一个事务对某个表加锁时其他事务无法对该表进行某些操作直到锁被释放工作原理加锁事务在操作表之前先对整个表加锁独占访问在锁被持有的期间其他事务无法对该表进行某些操作如写操作解锁事务操作完成后释放锁允许其他事务访问表锁的类型表锁可以分为以下两种类型共享锁锁允许多个事务同时持有共享锁用于读操作持有共享锁的事务可以读取表但不能修改表排他锁锁只允许一个事务持有排他锁用于写操作持有排他锁的事务可以读取和修改表其他事务无法获取任何类型的锁优点简单易用实现简单适合对整个表的操作安全性高能够有效避免表级别的冲突缺点并发性低锁的粒度较大可能导致其他事务长时间等待性能开销频繁加锁和解锁会导致性能下降适用场景全表操作如批量插入删除或更新整个表资源竞争激烈当多个事务频繁竞争整个表时行锁基本概念行锁是对数据库表中的某一行或多行加锁的机制当一个事务对某一行加锁时其他事务无法对该行进行某些操作直到锁被释放工作原理加锁事务在操作某一行之前先对该行加锁独占访问在锁被持有的期间其他事务无法对该行进行某些操作如写操作解锁事务操作完成后释放锁允许其他事务访问行锁的类型行锁的类型与表锁类似分为以下两种共享锁锁允许多个事务同时持有共享锁用于读操作持有共享锁的事务可以读取行但不能修改行排他锁锁只允许一个事务持有排他锁用于写操作持有排他锁的事务可以读取和修改行其他事务无法获取任何类型的锁优点并发性高锁的粒度较小允许多个事务同时操作不同的行性能较好在大多数情况下行锁的性能优于表锁缺点复杂性高实现和管理行锁比表锁更复杂死锁风险由于锁的粒度较小可能导致死锁问题适用场景单行操作如更新删除或查询单行数据资源竞争不激烈当多个事务对不同行的竞争较少时表锁与行锁的对比特性表锁行锁锁的粒度锁的粒度较大对整个表加锁锁的粒度较小对单行或多行加锁并发性并发性较低可能导致其他事务长时间等待并发性较高允许多个事务同时操作不同行性能性能较低频繁加锁和解锁会导致性能下降性能较高锁的粒度较小性能较好复杂性实现简单管理较容易实现复杂管理较困难可能引发死锁适用场景全表操作资源竞争激烈的场景单行操作资源竞争不激烈的场景表锁与行锁的使用示例表锁示例在中可以通过语句显式地对表加锁对表加共享锁对表加排他锁解锁行锁示例在中行锁通常由事务自动管理例如在存储引擎中行锁会在事务执行时自动加锁开启事务对某一行加排他锁更新数据提交事务释放锁表锁与行锁的实际应用表锁的应用批量操作如批量插入删除或更新整个表数据备份在备份数据时对表加锁以确保数据一致性行锁的应用事务隔离在事务中对单行数据进行更新或删除操作并发控制在多用户并发访问数据库时确保单行数据的一致性总结表锁锁的粒度较大适合全表操作和资源竞争激烈的场景但并发性较低行锁锁的粒度较小适合单行操作和资源竞争不激烈的场景并发性较高在实际应用中选择表锁还是行锁需要根据具体的业务场景和资源竞争情况来决定如果需要对整个表进行操作表锁是更好的选择如果需要对单行数据进行操作行锁可以显著提高并发性能读写锁在并发编程中读锁和写锁是用于控制对共享资源的访问的机制它们通常用于实现读写锁这是一种特殊的锁机制允许多个线程同时读取共享资源但在写操作时需要独占访问读写锁的基本概念读写锁是一种分离锁它将锁的粒度分为两种读锁允许多个线程同时持有读锁又称为共享锁只要没有线程持有写锁写锁只允许一个线程持有写锁又称为排他锁且在持有写锁时其他线程无法持有读锁或写锁读写锁的核心思想是读操作通常是安全的允许多个线程并发读取共享资源写操作通常是独占的需要保证写操作的线程安全读写锁的优点提高并发性允许多个线程同时读取共享资源从而提高并发性能降低锁竞争读操作之间不需要互斥减少了锁的竞争灵活性适用于读多写少的场景能够更好地平衡性能和线程安全读写锁的实现在中读写锁的实现主要依赖于类它提供了读锁和写锁的实现类是提供的读写锁实现类它实现了接口获取读锁获取写锁读锁允许多个线程同时持有只要没有线程持有写锁获取读锁调用释放读锁调用写锁只允许一个线程持有在持有写锁时其他线程无法持有读锁或写锁获取写锁调用释放写锁调用读写锁的使用示例以下是一个使用的示例读操作获取读锁释放读锁写操作获取写锁释放写锁创建多个读线程创建一个写线程课程案例资源类写操作正在写入写入完成读操作正在读取读取完成存数据取数据读写锁的规则读锁规则允许多个线程同时持有读锁如果一个线程持有写锁其他线程无法获取读锁写锁规则只允许一个线程持有写锁如果一个线程持有写锁其他线程无法获取读锁或写锁读写互斥读锁和写锁是互斥的即持有读锁的线程无法获取写锁反之亦然读写锁的适用场景读写锁适用于以下场景读多写少当读操作远远多于写操作时读写锁可以显著提高并发性能共享资源访问需要对共享资源进行并发读写操作的场景缓存系统缓存系统通常需要频繁读取数据但写操作较少读写锁的缺点复杂性相比于普通锁如读写锁的实现和使用更复杂饥饿问题在某些情况下写锁可能会因为频繁的读操作而长时间无法获取锁导致写线程饥饿性能开销读写锁的实现比普通锁更复杂可能会带来一定的性能开销读写锁与其他锁的对比特性读写锁普通锁并发性允许多个线程同时读取共享资源只允许一个线程持有锁互斥性读锁之间不互斥读写锁之间互斥所有操作都需要互斥适用场景读多写少的场景读写操作均衡的场景性能在读多写少时性能更好在读写操作均衡时性能更好读写锁降级读写锁的降级是指在持有写锁的情况下将写锁降级为读锁的过程这种操作通常用于并发编程中以提高系统的并发性能和灵活性读写锁降级的概念在某些场景下一个线程可能需要先对共享资源进行写操作然后继续对该资源进行读操作为了避免在写操作完成后其他线程无法获取读锁可以通过降级操作将写锁转换为读锁降级过程线程先获取写锁完成写操作后释放写锁立即获取读锁继续进行读操作读写锁降级的优点提高并发性降级操作允许其他线程在写操作完成后立即获取读锁从而提高系统的并发性能灵活性降级操作提供了更灵活的锁管理方式适用于需要在写操作后继续读取资源的场景避免饥饿降级操作可以避免写锁长时间占用资源导致其他线程无法获取读锁或写锁读写锁降级的实现在中读写锁的降级可以通过实现以下是降级的基本步骤获取写锁调用执行写操作对共享资源进行写操作释放写锁调用获取读锁调用执行读操作对共享资源进行读操作释放读锁调用读写锁降级的示例以下是一个使用实现读写锁降级的示例获取写锁执行写操作降级为读锁释放写锁执行读操作释放读锁创建一个线程执行降级操作读写锁降级的适用场景写操作后需要读操作当一个线程在完成写操作后需要继续读取资源时提高并发性在写操作完成后允许其他线程获取读锁从而提高系统的并发性能避免锁竞争通过降级操作减少写锁的持有时间避免其他线程长时间等待读写锁降级的注意事项顺序问题必须先释放写锁再获取读锁否则会导致死锁线程安全降级操作必须在同一个线程中完成否则可能导致并发问题性能开销频繁的锁降级操作可能会带来一定的性能开销需要根据具体场景权衡读写锁降级是一种在持有写锁的情况下将写锁降级为读锁的操作它能够提高系统的并发性能避免锁竞争适用于写操作后需要继续读取资源的场景在实现降级操作时需要注意顺序问题和线程安全确保操作的正确性读写锁演变阻塞队列为什么需要好处是我们不需要关心什么时候需要阻塞线程什么时候需要唤醒线程因为这一切都给你一手包办了在包发布以前在多线程环境下我们每个程序员都必须去自己控制这些细节尤其还要兼顾效率和线程安全而这会给我们的程序带来不小的复杂度简介阻塞队列是并发编程中的一个重要工具位于包中它是一种特殊的队列支持在队列为空时阻塞消费者线程或在队列满时阻塞生产者线程阻塞队列常用于生产者消费者模型中能够有效解决线程间的协作问题阻塞队列是一种线程安全的队列它提供了以下核心功能阻塞操作队列为空时消费者线程尝试从队列中获取元素时会被阻塞直到队列中有可用元素队列满时生产者线程尝试向队列中添加元素时会被阻塞直到队列中有可用空间线程安全阻塞队列是线程安全的多个线程可以并发地进行操作边界性阻塞队列可以是有界的固定容量或无界的容量无限阻塞队列顾名思义首先它是一个队列通过一个共享的队列可以使得数据由队列的一端输入从另外一端输出当队列是空的从队列中获取元素的操作将会被阻塞直到其他线程往空的队列插入新的元素当队列是满的从队列中添加元素的操作将会被阻塞直到其他线程从队列中移除一个或多个元素或者完全清空使队列变得空闲常用的队列主要有以下两种先进先出先插入的队列的元素也最先出队列类似于排队的功能从某种程度上来说这种队列也体现了一种公平性后进先出后插入队列的元素最先出队列这种队列优先处理最近发生的事件栈阻塞队列的优点线程安全阻塞队列是线程安全的无需手动加锁简化并发编程提供了阻塞和超时机制简化了生产者消费者模型的实现高效协作能够有效解决生产者和消费者之间的协作问题灵活性提供了多种实现类适用于不同的场景阻塞队列的缺点性能开销阻塞队列的实现通常基于锁机制可能会带来一定的性能开销死锁风险在复杂的并发场景中可能会出现死锁问题适用性有限阻塞队列适用于生产者消费者模型但在其他场景中可能不够灵活阻塞队列的适用场景生产者消费者模型阻塞队列是实现生产者消费者模型的理想工具任务调度在任务调度系统中阻塞队列可以用于存储待执行的任务缓存系统在缓存系统中阻塞队列可以用于存储缓存数据消息队列在消息队列系统中阻塞队列可以用于存储消息阻塞队列与其他队列的对比特性阻塞队列普通队列线程安全是否阻塞机制支持阻塞和超时机制不支持适用场景生产者消费者模型任务调度等单线程场景性能在多线程场景下性能较好在单线程场景下性能较好阻塞队列的使用示例以下是一个使用的简单示例创建一个容量为的阻塞队列生产者线程队列已满阻塞消费者线程模拟消费延迟队列为空阻塞核心方法是阻塞队列的核心接口定义了阻塞队列的基本操作它的主要方法包括插入元素插入元素如果队列已满则抛出异常插入元素如果队列已满则返回插入元素如果队列已满则阻塞插入元素如果队列已满则等待指定时间移除元素移除元素如果队列为空则抛出异常移除元素如果队列为空则返回移除元素如果队列为空则阻塞移除元素如果队列为空则等待指定时间检查元素返回队列头部元素如果队列为空则抛出异常返回队列头部元素如果队列为空则返回示例代码第一组超出容量抛出异常队列为空时抛出异常第二组超出容量返回队列为空时返回第三组超出容量阻塞队列为空时阻塞第四组超出容量阻塞超时返回队列为空时阻塞超时返回常见的和是两个最普通也是最常用的阻塞队列一般情况下在处理多线程间的生产者消费者问题使用这两个类足以常用基于数组的阻塞队列实现在内部维护了一个定长数组以便缓存队列中的数据对象这是一个常用的阻塞队列除了一个定长数组外内部还保存着两个整形变量分别标识着队列的头部和尾部在数组中的位置在生产者放入数据和消费者获取数据都是共用同一个锁对象由此也意味着两者无法真正并行运行这点尤其不同于按照实现原理来分析完全可以采用分离锁从而实现生产者和消费者操作的完全并行运行之所以没这样去做也许是因为的数据写入和获取操作已经足够轻巧以至于引入独立的锁机制除了给代码带来额外的复杂性外其在性能上完全占不到任何便宜和间还有一个明显的不同之处在于前者在插入或删除元素时不会产生或销毁任何额外的对象实例而后者则会生成一个额外的对象这在长时间内需要高效并发地处理大批量数据的系统中其对于的影响还是存在一定的区别而在创建时我们还可以控制对象的内部锁是否采用公平锁默认采用非公平锁特点基于数组的有界阻塞队列容量固定支持公平性策略一句话总结由数组结构组成的有界阻塞队列常用基于链表的阻塞队列同类似其内部也维持着一个数据缓冲队列该队列由一个链表构成当生产者往队列中放入一个数据时队列会从生产者手中获取数据并缓存在队列内部而生产者立即返回只有当队列缓冲区达到最大值缓存容量时可以通过构造函数指定该值才会阻塞生产者队列直到消费者从队列中消费掉一份数据生产者线程会被唤醒反之对于消费者这端的处理也基于同样的原理而之所以能够高效的处理并发数据还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据以此来提高整个队列的并发性能特点基于链表的无界或固定容量的阻塞队列默认是无界的但可以指定容量一句话总结由链表结构组成的有界但大小默认值为阻塞队列基于优先级的阻塞队列优先级的判断通过构造函数传入的对象来决定但需要注意的是并不会阻塞数据生产者而只会在没有可消费的数据时阻塞数据的消费者因此使用的时候要特别注意生产者生产数据的速度绝对不能快于消费者消费数据的速度否则时间一长会最终耗尽所有的可用堆内存空间在实现时内部控制线程同步的锁采用的是公平锁特点基于优先级的无界阻塞队列元素按照优先级排序一句话总结支持优先级排序的无界阻塞队列中的元素只有当其指定的延迟时间到了才能够从队列中获取到该元素是一个没有大小限制的队列因此往队列中插入数据的操作生产者永远不会被阻塞而只有获取数据的操作消费者才会被阻塞特点延迟队列元素必须实现接口元素只有在延迟到期后才能被消费一句话总结使用优先级队列实现的延迟无界阻塞队列一种无缓冲的等待队列类似于无中介的直接交易有点像原始社会中的生产者和消费者生产者拿着产品去集市销售给产品的最终消费者而消费者必须亲自去集市找到所要商品的直接生产者如果一方没有找到合适的目标那么对不起大家都在集市等待相对于有缓冲的来说少了一个中间经销商的环节缓冲区如果有经销商生产者直接把产品批发给经销商而无需在意经销商最终会将这些产品卖给那些消费者由于经销商可以库存一部分商品因此相对于直接交易模式总体来说采用中间经销商的模式会吞吐量高一些可以批量买卖但另一方面又因为经销商的引入使得产品从生产者到消费者中间增加了额外的交易环节单个产品的及时响应性能可能会降低声明一个有两种不同的方式它们之间有着不太一样的行为公平模式和非公平模式的区别公平模式会采用公平锁并配合一个队列来阻塞多余的生产者和消费者从而体系整体的公平策略非公平模式默认采用非公平锁同时配合一个队列来管理多余的生产者和消费者而后一种模式如果生产者和消费者的处理速度有差距则很容易出现饥渴的情况即可能有某些生产者或者是消费者的数据永远都得不到处理特点同步队列容量为生产者和消费者必须配对出现一句话总结不存储元素的阻塞队列也即单个元素的队列是一个由链表结构组成的无界阻塞队列相对于其他阻塞队列多了和方法采用一种预占模式意思就是消费者线程取元素时如果队列不为空则直接取走数据若队列为空那就生成一个节点节点元素为入队然后消费者线程被等待在这个节点上后面生产者线程入队时发现有一个元素为的节点生产者线程就不入队了直接就将元素填充到该节点并唤醒该节点等待的线程被唤醒的消费者线程取走元素从调用的方法返回一句话总结由链表组成的无界阻塞队列是一个由链表结构组成的双向阻塞队列即可以从队列的两端插入和移除元素对于一些指定的操作在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作这里的阻塞一般有两种情况插入元素时如果当前队列已满将会进入阻塞状态一直等到队列有空的位置时再讲该元素插入该操作可以通过设置超时参数超时后返回表示操作失败也可以不设置超时参数一直阻塞中断后抛出异常读取元素时如果当前队列为空会阻塞直到队列不为空然后返回元素同样可以通过设置超时参数特点基于链表的双端阻塞队列支持从两端插入和移除元素一句话总结由链表组成的双向阻塞队列线程池线程池是并发编程中的一个重要概念位于包中线程池通过预先创建一组线程并复用它们避免了频繁创建和销毁线程的开销从而提高了系统的性能和资源利用率线程池广泛应用于服务器端编程任务调度并发处理等场景线程池的基本概念为什么要使用线程池性能优化创建和销毁线程是昂贵的操作线程池通过复用线程减少了这些开销资源管理线程池可以限制线程的数量避免系统资源被耗尽任务调度线程池可以管理和调度任务确保任务的执行顺序和优先级线程池的核心组件线程池管理器负责创建和管理线程池工作线程线程池中的线程负责执行任务任务队列用于存储待执行的任务拒绝策略当任务队列满且线程池无法处理更多任务时拒绝策略决定如何处理新任务线程池的优缺点及使用场景优点性能优化通过复用线程减少了创建和销毁线程的开销资源管理限制线程数量避免系统资源被耗尽任务调度管理和调度任务确保任务的执行顺序和优先级灵活性提供了多种参数和策略适用于不同的场景缺点复杂性线程池的配置和使用需要一定的经验配置不当可能导致性能问题死锁风险在复杂的并发场景中可能会出现死锁问题适用性有限线程池适用于任务执行时间较短的场景对于长时间运行的任务可能不够灵活适用场景服务器端编程如服务器数据库连接池等任务调度如定时任务批处理任务等并发处理如多线程下载并行计算等异步编程如异步任务处理事件驱动编程等线程池的接口和实现类接口是线程池的核心接口定义了任务提交的方法接口是的扩展接口提供了更丰富的功能如任务提交任务取消线程池关闭等常见的实现类提供了多种线程池的实现类适用于不同的场景最常用的线程池实现类支持自定义线程池的参数如核心线程数最大线程数任务队列拒绝策略等支持定时和周期性任务的线程池工厂类提供了创建常见线程池的便捷方法如创建固定大小的线程池创建可缓存的线程池创建单线程的线程池创建支持定时任务的线程池线程池的工作原理线程池的生命周期线程池的生命周期包括以下几个阶段创建初始化线程池创建核心线程运行线程池接收任务并分配给工作线程执行关闭调用或方法关闭线程池终止所有任务执行完毕线程池中的线程被销毁任务的执行流程提交任务通过或方法提交任务任务分配如果线程池中的线程数小于核心线程数创建新线程执行任务如果线程池中的线程数已达到核心线程数将任务放入任务队列如果任务队列已满且线程数小于最大线程数创建新线程执行任务如果任务队列已满且线程数已达到最大线程数执行拒绝策略任务执行工作线程从任务队列中获取任务并执行任务完成任务执行完毕后线程返回线程池等待下一个任务线程池的参数及自定义线程池线程池的参数提供了多个参数用于自定义线程池的行为核心线程数线程池中始终保持的线程数最大线程数线程池中允许的最大线程数非核心线程的空闲时间超过该时间后非核心线程会被销毁的时间单位任务队列用于存储待执行的任务线程工厂用于创建新线程拒绝策略用于处理无法执行的任务自定义线程池阿里巴巴开发手册要求不允许使用创建线程而是通过创建自定义线程池下面是一个简单的自定义线程池示例办理业务关闭线程池线程池的拒绝策略当任务队列满且线程池无法处理更多任务时拒绝策略决定如何处理新任务常见的拒绝策略包括默认策略直接抛出异常由提交任务的线程执行任务直接丢弃任务不抛出异常丢弃任务队列中最旧的任务然后尝试重新提交新任务线程池的使用示例以下是一个使用创建自定义线程池的示例创建自定义线程池核心线程数最大线程数非核心线程的空闲时间时间单位任务队列拒绝策略提交任务模拟任务执行时间关闭线程池课程案例第一种一池线程第二种一池一线程第三种一池可扩容线程办理业务关闭线程池分支合并框架框架简介框架是引入的一个并发编程框架位于包中它基于分治算法将一个大任务拆分为多个小任务并行执行这些小任务最后将结果合并框架特别适合处理递归和并行计算问题如归并排序快速排序并行数组处理等分治算法分治算法的核心思想是将一个大问题分解为多个小问题分别解决这些小问题然后将结果合并框架通过以下步骤实现分治算法拆分将大任务拆分为多个小任务合并等待所有小任务完成并将结果合并工作窃取算法框架使用工作窃取算法来提高任务的执行效率每个线程维护一个双端队列用于存储任务当一个线程的任务队列为空时它会从其他线程的任务队列末尾窃取任务这种机制减少了线程的空闲时间提高了资源利用率框架的优缺点及适用场景优点高效并行基于分治算法和工作窃取算法能够高效地并行处理任务简化并发编程提供了丰富的简化了并发任务的编写和组合资源管理通过线程池管理线程避免了频繁创建和销毁线程的开销适用性广适用于递归和并行计算问题如排序搜索矩阵运算等缺点复杂性较为丰富初学者可能需要一定时间熟悉性能开销相比于简单的线程池框架的实现较为复杂可能会带来一定的性能开销适用性有限适用于递归和并行计算问题但在简单的场景中可能显得过于复杂适用场景递归问题如归并排序快速排序树的遍历等并行计算如矩阵运算图像处理数据分析等大规模数据处理如大数据集的排序搜索聚合等任务拆分如任务调度批处理任务等框架的核心组件是框架的核心类它是一个特殊的线程池专门用于执行创建提交任务是框架的任务抽象类表示一个可以被拆分和执行的任务它有两个主要的子类表示没有返回值的任务适用于不需要返回结果的场景如文件处理数据清洗等表示有返回值的任务适用于需要返回结果的场景如并行计算排序等框架的工作原理任务拆分任务通过方法拆分为多个子任务子任务会被放入当前线程的任务队列中或者被其他线程窃取任务执行每个线程从自己的任务队列中获取任务并执行如果任务队列为空线程会从其他线程的任务队列末尾窃取任务任务合并任务通过方法等待子任务完成并将结果合并最终结果会被返回给调用者框架的使用示例课程案例要求计算计算时两个相邻的数值不能超过拆分差值不能超过拆分的开始值拆分的结束值结果有参构造拆分和合并两个数值相加是否大于相加操作进一步拆分获取中间值拆分左边拆分右边合并合并结果创建分支合并池对象获取最终合并后的结果关闭分支合并池计算数组元素的和以下是一个使用框架计算数组元素和的示例创建创建一个数组创建任务提交任务并获取结果定义任务拆分的阈值如果任务足够小直接计算拆分任务执行子任务合并结果归并排序以下是一个使用框架实现归并排序的示例创建创建一个数组创建任务提交任务输出排序结果定义任务拆分的阈值如果任务足够小直接排序拆分任务执行子任务等待子任务完成合并结果异步回调是引入的一个强大的异步编程工具位于包中它是接口的实现类提供了更丰富的功能支持链式调用组合任务异常处理等能够更方便地处理异步任务的基本概念什么是是一个可完成的它不仅表示一个异步计算的结果还允许你显式地完成它通过设置结果或异常它支持链式调用可以将多个异步任务串联起来形成一个任务链它提供了丰富的用于处理任务的完成组合转换和异常处理的优缺点及适用场景优点简化异步编程提供了丰富的简化了异步任务的编写和组合非阻塞操作支持非阻塞的链式调用避免了传统的阻塞问题任务组合支持任务之间的组合和依赖关系能够更灵活地处理复杂的异步任务异常处理提供了专门的处理异常简化了异常处理的逻辑缺点复杂性较为丰富初学者可能需要一定时间熟悉性能开销相比于简单的线程池的实现较为复杂可能会带来一定的性能开销适用性有限适用于复杂的异步任务处理但在简单的场景中可能显得过于复杂适用场景异步任务处理如网络请求数据库查询等任务组合如多个异步任务的依赖关系处理事件驱动编程如响应式编程事件处理等并发处理如并行计算批处理任务等与传统的区别特性异步任务只能通过获取结果阻塞线程支持非阻塞的链式调用和组合任务任务完成无法手动完成任务可以手动完成任务设置结果或异常异常处理不支持直接处理异常提供专门的处理异常任务组合不支持任务之间的组合支持任务的组合和依赖关系的核心功能创建空任务带返回值的任务完成任务手动完成任务手动设置结果手动抛出异常获取结果阻塞获取结果阻塞等待结果非阻塞获取结果如果未完成返回默认值链式调用转换结果消费结果执行后续任务任务组合顺序组合并行组合异常处理捕获异常处理异常和结果的使用示例课程案例异步调用无返回值执行异步任务异步调用有返回值执行异步任务模拟异常处理异步任务的结果异步任务结果异常信息处理异常异步任务异常简单异步任务创建一个异步任务模拟耗时操作获取结果防止主线程退出任务组合创建两个异步任务组合任务获取结果防止主线程退出',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-10 19:14:36',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script async="" defer="" src="https://umami.shiguangdev.cn/script.js" data-website-id="ac8d5698-b224-4ea4-aa79-eefb80c47eef"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="時光" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar.png"><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.shiguang666.eu.org" title="時光主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光主页"><span class="back-menu-item-text">時光主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://nav.shiguang666.eu.org" title="時光导航站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光导航站"><span class="back-menu-item-text">時光导航站</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://game.shiguang666.eu.org" title="怀旧游戏机"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="怀旧游戏机"><span class="back-menu-item-text">怀旧游戏机</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://games.shiguang666.eu.org" title="在线小游戏"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="在线小游戏"><span class="back-menu-item-text">在线小游戏</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">后台管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://img.shiguangdev.cn/" title="時光图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/favicon.ico" alt="時光图床"><span class="back-menu-item-text">時光图床</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.shiguang666.eu.org/" title="Hexo管理面板"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://qexo.shiguang666.eu.org/favicon.ico" alt="Hexo管理面板"><span class="back-menu-item-text">Hexo管理面板</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">時光</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随机</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/news/"><i class="fa fa-calendar faa-tada"></i><span> 早报亭</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=10051718332&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/xjj/"><i class="fa fa-rocket faa-tada"></i><span> 养生堂</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/flink/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comment/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechat.png"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.png"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">31</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">38</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">30</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">20</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JAVA/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JAVA</span></a><a class="article-meta__tags" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>尚硅谷</span></a><a class="article-meta__tags" href="/tags/JUC/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JUC</span></a></span></div></div><h1 class="post-title" itemprop="name headline">【尚硅谷】JUC基础篇(2021版)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-12-09T03:23:40.000Z" title="发表于 2024-12-09 11:23:40">2024-12-09</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-12-10T11:14:36.050Z" title="更新于 2024-12-10 19:14:36">2024-12-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">26.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>101分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/12/09/f69225d19caa/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope="" itemtype="https://blog.shiguang666.eu.org/2024/12/09/f69225d19caa/"><header><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a><a href="/tags/JAVA/" tabindex="-1" itemprop="url">JAVA</a><a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" tabindex="-1" itemprop="url">尚硅谷</a><a href="/tags/JUC/" tabindex="-1" itemprop="url">JUC</a><h1 id="CrawlerTitle" itemprop="name headline">【尚硅谷】JUC基础篇(2021版)</h1><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">時光</span><time itemprop="dateCreated datePublished" datetime="2024-12-09T03:23:40.000Z" title="发表于 2024-12-09 11:23:40">2024-12-09</time><time itemprop="dateCreated datePublished" datetime="2024-12-10T11:14:36.050Z" title="更新于 2024-12-10 19:14:36">2024-12-10</time></header><div id="postchat_postcontent"><h1 id="大厂必备技术之JUC并发编程"><a href="#大厂必备技术之JUC并发编程" class="headerlink" title="大厂必备技术之JUC并发编程"></a>大厂必备技术之JUC并发编程</h1><blockquote>
<p><strong>B站直达</strong></p>
<p>2021版: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kw411Z7dF/">【尚硅谷】大厂必备技术之JUC并发编程</a></p>
<p>2022版: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ar4y1x727">尚硅谷JUC并发编程（对标阿里P6-P7）</a></p>
<p><strong>课程资料</strong></p>
<p>2021版：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1c9vU7Gn9mbTIyPPJ-pnBzw?pwd=yyds">尚硅谷高级技术之JUC高并发编程2021最新版</a></p>
<p>2022版：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1R-9mDBNATs9By7gwR2czWw?pwd=yyds">尚硅谷JUC并发编程与源码分析2022</a></p>
<p><strong>代码仓库</strong></p>
<p>GitHub: <a target="_blank" rel="noopener" href="https://github.com/Shiguang-coding/learn-juc">https://github.com/Shiguang-coding/learn-juc</a></p>
<p>Gitee: <a target="_blank" rel="noopener" href="https://gitee.com/an_shiguang/learn-juc">https://gitee.com/an_shiguang/learn-juc</a></p>
</blockquote>
<h2 id="1、什么是JUC"><a href="#1、什么是JUC" class="headerlink" title="1、什么是JUC"></a>1、什么是JUC</h2><h3 id="1-1、JUC简介"><a href="#1-1、JUC简介" class="headerlink" title="1.1、JUC简介"></a>1.1、JUC简介</h3><blockquote>
<p>JDK6中文在线文档：<a target="_blank" rel="noopener" href="https://tool.oschina.net/apidocs/apidoc?api=jdk-zh">https://tool.oschina.net/apidocs/apidoc?api=jdk-zh</a></p>
</blockquote>
<p>在Jv中，线程部分是一个重点，本篇文章说的UC也是关于线程的。JUC就是java.util.concurrent工具包的简称。这是一个处理线程的工具包，JDK1.5开始出现的。</p>
<h3 id="1-2、进程与线程"><a href="#1-2、进程与线程" class="headerlink" title="1.2、进程与线程"></a>1.2、进程与线程</h3><p><strong>进程（Process）</strong>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p><strong>线程（英语：thread）</strong>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p>总结来说：</p>
<p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程是资源分配的最小单位。</p>
<p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程是程序执行的最小单位。</p>
<h3 id="1-3、线程的状态"><a href="#1-3、线程的状态" class="headerlink" title="1.3、线程的状态"></a>1.3、线程的状态</h3><h4 id="1-3-1、线程状态枚举类"><a href="#1-3-1、线程状态枚举类" class="headerlink" title="1.3.1、线程状态枚举类"></a>1.3.1、线程状态枚举类</h4><p>进入 <code>java.lang.Thread</code> 类，找到内部类 State ，代码如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">    	<span class="comment">// 新建</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    	<span class="comment">// 准备就绪</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * {<span class="doctag">@link</span> Object#wait() Object.wait}.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    	<span class="comment">// 阻塞</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;{<span class="doctag">@link</span> Object#wait() Object.wait} with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;{<span class="doctag">@link</span> #join() Thread.join} with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;{<span class="doctag">@link</span> LockSupport#park() LockSupport.park}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    	<span class="comment">// 等待(不见不散)</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;{<span class="doctag">@link</span> #sleep Thread.sleep}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;{<span class="doctag">@link</span> Object#wait(long) Object.wait} with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;{<span class="doctag">@link</span> #join(long) Thread.join} with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;{<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;{<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    	<span class="comment">// 带时间的等待(过时不候)</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    	<span class="comment">// 终结</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="1-3-2、wait和sleep的区别"><a href="#1-3-2、wait和sleep的区别" class="headerlink" title="1.3.2、wait和sleep的区别"></a>1.3.2、wait和sleep的区别</h4><ol>
<li>sleep是Thread的静态方法；wait是Object的方法，任何对象实例都能调用。</li>
<li>sleep不会释放锁，它也不需要占用锁；wait会释放锁，但调用它的前提是当前线程占有锁（即代码要在synchronized中）</li>
<li>它们都可以被interrupted方法中断</li>
</ol>
<h3 id="1-4、并发与并行"><a href="#1-4、并发与并行" class="headerlink" title="1.4、并发与并行"></a>1.4、并发与并行</h3><h4 id="1-4-1、串行模式"><a href="#1-4-1、串行模式" class="headerlink" title="1.4.1、串行模式"></a>1.4.1、串行模式</h4><p><strong>串行是一次只能取得一个任务，并执行这个任务。</strong></p>
<p>串行表示所有任务都一一按先后顺序进行。串行意味看必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤。</p>
<h4 id="1-4-2、并行模式"><a href="#1-4-2、并行模式" class="headerlink" title="1.4.2、并行模式"></a>1.4.2、并行模式</h4><p>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。并行的效率从代码层次上强依赖于多进程/多线程代码，从硬件角度上则依赖于多核CPU。</p>
<h4 id="1-4-3、并发"><a href="#1-4-3、并发" class="headerlink" title="1.4.3、并发"></a>1.4.3、并发</h4><p><strong>并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行。</strong>但这不是重点，在描述并发的时候也不会去扣这种字眼是否精确，并发的重点在于它是一种现象，并发描述<br>的是多进程同时运行的现象。但实际上，对于单核心CPU来说，同一时刻只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一会停一会（线程的上下文切换）。</p>
<p><strong>要解决大并发问题，通常是将大任务分解成多个小任务</strong>，由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象：</p>
<ul>
<li>可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用队列或类似的数据结构来存放各个小任务的成果。</li>
<li>可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或异步的方式，比如只有准备好产生了事件通知才执行某个任务。</li>
<li>可以多进程/多线程的方式并行执行这些小任务。也可以单进程/单线程执行这些小任务，这时很可能要配合多路复用才能达到较高的效率。</li>
</ul>
<h4 id="1-4-4、小结（重点）"><a href="#1-4-4、小结（重点）" class="headerlink" title="1.4.4、小结（重点）"></a>1.4.4、小结（重点）</h4><p><strong>并发</strong>：同一时刻多个线程在访问同一个资源，多个线程对一个点。<br>例子：春运抢票电商秒杀…</p>
<p><strong>并行</strong>：多项工作一起执行，之后再汇总<br>例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p>
<h3 id="1-5、管程"><a href="#1-5、管程" class="headerlink" title="1.5、管程"></a>1.5、管程</h3><p>即Monitor（监视器），即平时所说的锁，是一种同步机制，保证同一时间只有一个线程访问被保护的数据或代码</p>
<p>JVM中的同步基于进入和退出管程对象来实现的。</p>
<h3 id="1-6、用户线程和守护线程"><a href="#1-6、用户线程和守护线程" class="headerlink" title="1.6、用户线程和守护线程"></a>1.6、用户线程和守护线程</h3><p><strong>用户线程</strong>：即自定义线程，平时所用到的线程基本都是用户线程。主线程结束了，用户线程还在运行，jvm存活。</p>
<p><strong>守护线程</strong>：是一种特殊的线程，在后台运行的线程，比如垃圾回收，没有用户线程了，都是守护线程，jvm结束。</p>
<p>举例说明：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 是否为守护线程: "</span> + Thread.currentThread().isDaemon());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"myThread"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置为守护线程,在线程启动之前设置</span></span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" over"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2、Lock接口"><a href="#2、Lock接口" class="headerlink" title="2、Lock接口"></a>2、Lock接口</h2><h3 id="2-1、Synchronized"><a href="#2-1、Synchronized" class="headerlink" title="2.1、Synchronized"></a>2.1、Synchronized</h3><h4 id="2-1-1-Synchronized关键字回顾"><a href="#2-1-1-Synchronized关键字回顾" class="headerlink" title="2.1.1 Synchronized关键字回顾"></a>2.1.1 Synchronized关键字回顾</h4><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>
<ol>
<li><p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号括起来的代码，作用的对象是调用这个代码块的对象；</p>
</li>
<li><p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p>
<p>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p>
</li>
<li><p>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象</p>
</li>
<li><p>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p>
</li>
</ol>
<h4 id="2-1-2、使用synchronized实现售票案例"><a href="#2-1-2、使用synchronized实现售票案例" class="headerlink" title="2.1.2、使用synchronized实现售票案例"></a>2.1.2、使用synchronized实现售票案例</h4><p><strong>多线程的编程步骤：</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/67569b290a6ca.webp" alt="image-20241209152423704"></p>
<p><strong>第一步：创建一个资源类，属性和操作方法</strong></p>
<p><strong>第二步：创建多个线程，调用类里面的操作方法</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 13:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步 创建资源类，定义属性和操作方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> {</span><br><span class="line">    <span class="comment">// 票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 卖票操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 卖出了第 "</span> + (number--) + <span class="string">" 张票, 剩余: "</span> + number);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> {</span><br><span class="line">    <span class="comment">// 第二步 创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建 Ticket 对象</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">                ticket.sale();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">                ticket.sale();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">                ticket.sale();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"C"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2、什么是Lock"><a href="#2-2、什么是Lock" class="headerlink" title="2.2、什么是Lock"></a>2.2、什么是Lock</h3><p>Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock提供了比synchronized更多的功能。</p>
<p><strong>Lock与的Synchronized区别</strong></p>
<ul>
<li>Lcck不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li>
<li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而L0ck则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li>
</ul>
<h3 id="2-3、ReentrantLock"><a href="#2-3、ReentrantLock" class="headerlink" title="2.3、ReentrantLock"></a>2.3、ReentrantLock</h3><h4 id="2-3-1、ReentrantLock介绍"><a href="#2-3-1、ReentrantLock介绍" class="headerlink" title="2.3.1、ReentrantLock介绍"></a>2.3.1、ReentrantLock介绍</h4><p><code>ReentrantLock</code>是Java中的一个可重入锁，实现了<code>Lock</code>接口。<br>可重入意味着同一个线程可以多次获取同一个锁而不会造成死锁，每次获取锁时，锁的持有计数会增<br>加，每次释放锁时，持有计数会减少，当持有计数为0时，锁被完全释放。</p>
<p>优点：</p>
<ul>
<li>提供了比<code>synchronized</code>关键字更灵活的锁操作，例如可中断的锁获取、超时等待锁、公平锁和非<br>公平锁的选择等。</li>
<li>可以使用<code>tryLock0</code>方法尝试获取锁，避免了线程的无限期等待。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 临界区代码，需要同步的部分</span></span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getName() + <span class="string">" is performing the task."</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReentrantLockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockExample</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::performTask);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::performTask);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码解释：<br><code>ReentrantLock lock = new ReentrantLock();</code>:创建一个ReentrantLock实例。</p>
<p><code>lock.lock();</code>:获取锁，如果锁已被其他线程持有，则当前线程会阻塞直到获取到锁。</p>
<p><code>try{...} finally {lock.unlock();}</code>:在tny块中执行需要同步的代码，确保在finally块中释放锁，<br>以防止死锁。</p>
<p><code>lock.tryLock()</code>:尝试获取锁，如果锁可用则立即返回true,否则返回false,不会阻塞线程。</p>
<p><strong>使用场景：</strong><br>当需要更灵活的锁操作，如可中断的锁获取、超时等待锁、公平锁等时，使用ReentrantLock比<br>synchronized更合适。<br>在复杂的同步场景中，如条件变量(Condition)的使用，ReentrantLock提供了更强大的功能.</p>
<p><strong>注意事项：</strong><br>务必在finally块中释放锁，以确保锁最终会被释放，避免死锁。<br>对于简单的同步需求，synchronized可能更简洁，但对于复杂的同步需求，ReentrantLock提供<br>了更多的控制和功能。</p>
<h4 id="2-3-2、售票案例"><a href="#2-3-2、售票案例" class="headerlink" title="2.3.2、售票案例"></a>2.3.2、售票案例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.lock.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 14:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步 创建资源类，定义属性和操作方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LTicket</span> {</span><br><span class="line">    <span class="comment">// 票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可重用锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断是否有票</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 卖出了第 "</span> + (number--) + <span class="string">" 张票, 剩余: "</span> + number);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LSaleTicket</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步 创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LTicket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LTicket</span>();</span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">                ticket.sale();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">                ticket.sale();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">                ticket.sale();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"C"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-4、ReadWriteLock"><a href="#2-4、ReadWriteLock" class="headerlink" title="2.4、ReadWriteLock"></a>2.4、ReadWriteLock</h3><h4 id="2-4-1、ReadWriteLock介绍"><a href="#2-4-1、ReadWriteLock介绍" class="headerlink" title="2.4.1、ReadWriteLock介绍"></a>2.4.1、ReadWriteLock介绍</h4><p>ReadWriteLock是Java中的一个接口，它维护了一对关联的锁，一个用于只读操作，一个用于写<br>入操作。</p>
<p>其主要目的是在多线程环境下，允许多个线程同时读取共享数据，但在写入数据时，需要独占访问，<br>以保证数据的一致性和完整性。</p>
<p>常见的实现类是 ReentrantReadWriteLock,它提供了可重入的读写锁功能。</p>
<p>优点：</p>
<ul>
<li>提高并发性能：在多读少写的场景下，使用ReadWriteLock可以显著提高程序的并发性能，因为多<br>个读线程可以同时访问共享资源，而不会互相阻塞。</li>
<li>数据一致性：在写操作时，通过独占锁保证数据的一致性，避免了多个线程同时修改数据导致的数据<br>不一致问题。</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readData</span><span class="params">()</span> {</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 多个读线程可以同时进入这里</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(<span class="type">int</span> newData)</span> {</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 只有一个写线程可以进入这里</span></span><br><span class="line">            data = newData;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码解释：<br><code>ReadWriteLock lock=new ReentrantReadWriteLock();</code>：创建-个ReentrantReadWriteLock<br>实例。</p>
<p><code> lock.readLock().lock();</code>：获取读锁，多个读线程可以同时获取读锁，只要没有写线程特有写锁。</p>
<p><code>lock.readLock().unlock();</code>:释放读锁</p>
<p><code>lock.writeLock().lock();</code>:获取写锁，只有一个写线程可以获取写锁，并且在写锁被持有时，其他读<br>线程和写线程都将被阻塞。</p>
<p><code>lock.writeLock().unlock();</code>:释放写锁。</p>
<h4 id="2-4-2、售票案例"><a href="#2-4-2、售票案例" class="headerlink" title="2.4.2、售票案例"></a>2.4.2、售票案例</h4><p>将 ReentrantLock 替换为 ReentrantReadWriteLock 。<br>使用writeLock进行写操作（卖票操作），因为卖票会修改票数，属干写操作，在sale方法中，使用writeLock进行加锁和解锁操作。其他部分代码保持不变。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.lock.reentrantlock.readwritelock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 14:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步 创建资源类，定义属性和操作方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LTicket</span> {</span><br><span class="line">    <span class="comment">// 票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可重用读写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断是否有票</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 卖出了第 "</span> + (number--) + <span class="string">" 张票, 剩余: "</span> + number);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 释放写锁</span></span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LSaleTicket</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步 创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LTicket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LTicket</span>();</span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">                ticket.sale();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">                ticket.sale();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">                ticket.sale();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"C"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用场景：</strong><br>适用于读操作颇繁，写操作较少的场景，例收如缓存系统、配置信息读取等。</p>
<p><strong>注意事项：</strong><br>读锁和写锁的使用要注意正确的加锁和解锁顺序，避免死锁。<br>写锁是独占的，会阻塞其他读锁和写锁，所以要确保写操作的时间尽量短，以提高并发性能。</p>
<h3 id="2-5、-小结（重点）"><a href="#2-5、-小结（重点）" class="headerlink" title="2.5、 小结（重点）"></a>2.5、 小结（重点）</h3><p>Lock和synchronized有以下几点不同：</p>
<ol>
<li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内<br>置的语言实现；</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过<code>unLock()</code>去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li>
<li>Lock可以提高多个线程进行读操作的效率。</li>
</ol>
<p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。</p>
<h2 id="3、线程间通信"><a href="#3、线程间通信" class="headerlink" title="3、线程间通信"></a>3、线程间通信</h2><h3 id="3-1、线程间通信案例"><a href="#3-1、线程间通信案例" class="headerlink" title="3.1、线程间通信案例"></a>3.1、线程间通信案例</h3><p>多线程编程步骤中可在写操作方法时再归纳一个步骤，即<strong>判断，干活，通知</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/67569b66e8588.webp" alt="image-20241209152525546"></p>
<p>示例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 15:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 第一步 创建资源类，定义属性和操作方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> {</span><br><span class="line">    <span class="comment">//初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +1 的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 第二步：判断, 干活, 通知</span></span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) {<span class="comment">// 判断number值是否为0,不为0则等待</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 干活</span></span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -1 的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 第二步：判断, 干活, 通知</span></span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">1</span>) {<span class="comment">// 判断number值是否为1,不为0则等待</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 干活</span></span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> {</span><br><span class="line">    <span class="comment">//第三步 创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建 Share 对象</span></span><br><span class="line">        <span class="type">Share</span> <span class="variable">share</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.incr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.decr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2、虚假唤醒问题"><a href="#3-2、虚假唤醒问题" class="headerlink" title="3.2、虚假唤醒问题"></a>3.2、虚假唤醒问题</h3><p>我们多复制一份代码，再引入两个线程，分别两个线程进行加操作，两个线程进行减操作</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 15:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 第一步 创建资源类，定义属性和操作方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> {</span><br><span class="line">    <span class="comment">//初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +1 的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 第二步：判断, 干活, 通知</span></span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) {<span class="comment">// 判断number值是否为0,不为0则等待</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 干活</span></span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -1 的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 第二步：判断, 干活, 通知</span></span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">1</span>) {<span class="comment">// 判断number值是否为1,不为0则等待</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 干活</span></span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> {</span><br><span class="line">    <span class="comment">//第三步 创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建 Share 对象</span></span><br><span class="line">        <span class="type">Share</span> <span class="variable">share</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.incr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.decr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.incr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.decr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"D"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下：</p>
<p>可见出现了错误情况（数值超过一或者数值小于0）</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">A : 1</span><br><span class="line">D : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">C : 1</span><br><span class="line">B : 0</span><br><span class="line">D : -1</span><br><span class="line">A : 0</span><br><span class="line">A : 1</span><br><span class="line">D : 0</span><br><span class="line">A : 1</span><br><span class="line">D : 0</span><br><span class="line">A : 1</span><br><span class="line">D : 0</span><br><span class="line">A : 1</span><br><span class="line">D : 0</span><br><span class="line">A : 1</span><br><span class="line">D : 0</span><br><span class="line">A : 1</span><br><span class="line">D : 0</span><br><span class="line">A : 1</span><br><span class="line">D : 0</span><br><span class="line">A : 1</span><br><span class="line">D : 0</span><br></pre></td></tr></tbody></table></figure>

<p>产生问题的原因是因为出现了虚假唤醒的情况，在多线程编程中，尤其是使用<code>wai()</code>和<code>notify()</code>或<code>notifyAll()</code>进行线程间通信时，可能会出现虚假唤醒的情况。</p>
<p>虚假唤醒就是在多线程执行过程中，线程间的通信未按照我们预想的顺序唤醒，故出现数据不一致等不符合我们预期的结果。例如我们的想法是：加1和减1交替执行，但执行结果出现了超过1的数或者小于0的数。</p>
<p>在上述代码中，如果使用f语句进行条件判断，当线程被虚假唤醒时，它会继续执行<code>wait()</code>之后的<br>代码，而不重新检查条件。这可能导致程序逻辑错误，例如vaue的值不符合预期。这是因为<code>wait()</code>方法在哪里等待，就在哪里唤醒。</p>
<p>应该使用while循环代替if进行条件判断，以防止虚假唤醒</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +1 的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="comment">// 第二步：判断, 干活, 通知</span></span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">0</span>) {<span class="comment">// 判断number值是否为0,不为0则等待</span></span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 干活</span></span><br><span class="line">    number++;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line">    <span class="comment">// 通知其他线程</span></span><br><span class="line">    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="comment">// 第二步：判断, 干活, 通知</span></span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">1</span>) {<span class="comment">// 判断number值是否为1,不为0则等待</span></span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 干活</span></span><br><span class="line">    number--;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line">    <span class="comment">// 通知其他线程</span></span><br><span class="line">    <span class="built_in">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，多线程编程步骤可再多加个步骤，即使用while循环代替if进行条件判断防止虚假唤醒问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/67569bc3cabaf.webp" alt="image-20241209152659459"></p>
<h3 id="3-3、ReentrantLock实现线程间通信"><a href="#3-3、ReentrantLock实现线程间通信" class="headerlink" title="3.3、ReentrantLock实现线程间通信"></a>3.3、ReentrantLock实现线程间通信</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.lock.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 15:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步 创建资源类，定义属性和操作方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> {</span><br><span class="line">    <span class="comment">// 初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Lock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +1 的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) {</span><br><span class="line">                condition.await();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number++;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -1 的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) {</span><br><span class="line">                condition.await();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建 Share 对象</span></span><br><span class="line">        <span class="type">Share</span> <span class="variable">share</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.incr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.decr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.incr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    share.decr();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4、线程间定制化通信"><a href="#4、线程间定制化通信" class="headerlink" title="4、线程间定制化通信"></a>4、线程间定制化通信</h2><h3 id="4-1、案例分析"><a href="#4-1、案例分析" class="headerlink" title="4.1、案例分析"></a>4.1、案例分析</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756a73a63ca7.webp" alt="image-20241209161554013"></p>
<h3 id="4-2、案例实现"><a href="#4-2、案例实现" class="headerlink" title="4.2、案例实现"></a>4.2、案例实现</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.lock.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 16:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 第一步 创建资源类，定义属性和操作方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shareResource</span> {</span><br><span class="line">    <span class="comment">// 定义标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 1 A ,2 B,3 C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三个Condition</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印5次,参数第几轮</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) {</span><br><span class="line">                c1.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i + <span class="string">" , "</span> + <span class="string">"轮数:"</span> + loop);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            c2.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印10次,参数第几轮</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) {</span><br><span class="line">                c2.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i + <span class="string">" , "</span> + <span class="string">"轮数:"</span> + loop);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            c3.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印15次,参数第几轮</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) {</span><br><span class="line">                c3.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i + <span class="string">" , "</span> + <span class="string">"轮数:"</span> + loop);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            c1.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建 Share 对象</span></span><br><span class="line">        <span class="type">shareResource</span> <span class="variable">shareResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">shareResource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareResource.print5(i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareResource.print10(i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareResource.print15(i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"C"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5、集合的线程安全"><a href="#5、集合的线程安全" class="headerlink" title="5、集合的线程安全"></a>5、集合的线程安全</h2><h3 id="5-1、ArrayList集合线程不安全演示"><a href="#5-1、ArrayList集合线程不安全演示" class="headerlink" title="5.1、ArrayList集合线程不安全演示"></a>5.1、ArrayList集合线程不安全演示</h3><p>ArrayList中<code>add()</code>方法定义如下，没有加<code>synchronized</code>关键字，是非线程安全的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This helper method split out from add(E) to keep method</span></span><br><span class="line"><span class="comment"> * bytecode size under 35 (the -XX:MaxInlineSize default value),</span></span><br><span class="line"><span class="comment"> * which helps when add(E) is called in a C1-compiled loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> {</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>问题代码案例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 16:36</span></span><br><span class="line"><span class="comment"> * List集合线程不安全问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo4</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                    System.out.println(list);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 异常时终止程序, 0表示正常终止，非零值表示异常终止</span></span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可能会出现的异常如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756b0972d414.webp" alt="image-20241209165550785"></p>
<h4 id="5-1-1、解决方案-Vector"><a href="#5-1-1、解决方案-Vector" class="headerlink" title="5.1.1、解决方案-Vector"></a>5.1.1、解决方案-Vector</h4><p>Vector中<code>add()</code>方法定义如下，添加了<code>synchronized</code>关键字，是线程安全的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this Vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, elementCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 异常时终止程序, 0表示正常终止，非零值表示异常终止</span></span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>多次执行未出现异常情况</p>
<h4 id="5-1-2、解决方案-Collections"><a href="#5-1-2、解决方案-Collections" class="headerlink" title="5.1.2、解决方案-Collections"></a>5.1.2、解决方案-Collections</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 异常时终止程序, 0表示正常终止，非零值表示异常终止</span></span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-1-3、解决方案-CopyOnWriteArrayList"><a href="#5-1-3、解决方案-CopyOnWriteArrayList" class="headerlink" title="5.1.3、解决方案-CopyOnWriteArrayList"></a>5.1.3、解决方案-CopyOnWriteArrayList</h4><p>CopyOnWrite 即 写时复制，写时复制一份，在复制的这一份中写入新内容，最后覆盖合并之前的内容，即兼顾了并发读，也照顾了独立的写操作</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        es[len] = e;</span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 异常时终止程序, 0表示正常终止，非零值表示异常终止</span></span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-2、HashSet集合线程不安全演示"><a href="#5-2、HashSet集合线程不安全演示" class="headerlink" title="5.2、HashSet集合线程不安全演示"></a>5.2、HashSet集合线程不安全演示</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Set集合线程不安全问题</span></span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 异常时终止程序, 0表示正常终止，非零值表示异常终止</span></span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>多次执行可能出现如下异常：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756b9a40bc01.webp" alt="image-20241209173427827"></p>
<h4 id="5-2-1、解决方案-CopyOnWriteArraySet"><a href="#5-2-1、解决方案-CopyOnWriteArraySet" class="headerlink" title="5.2.1、解决方案-CopyOnWriteArraySet"></a>5.2.1、解决方案-CopyOnWriteArraySet</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 异常时终止程序, 0表示正常终止，非零值表示异常终止</span></span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-3、HashMap集合线程不安全演示"><a href="#5-3、HashMap集合线程不安全演示" class="headerlink" title="5.3、HashMap集合线程不安全演示"></a>5.3、HashMap集合线程不安全演示</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Map集合线程不安全问题</span></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                map.put(key, UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 异常时终止程序, 0表示正常终止，非零值表示异常终止</span></span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>多次执行可能出现如下异常：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756bb367e831.webp" alt="image-20241209174110324"></p>
<h4 id="5-3-1、解决方案-Collections"><a href="#5-3-1、解决方案-Collections" class="headerlink" title="5.3.1、解决方案-Collections"></a>5.3.1、解决方案-Collections</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                map.put(key, UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 异常时终止程序, 0表示正常终止，非零值表示异常终止</span></span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-3-2、解决方案-ConcurrentHashMap"><a href="#5-3-2、解决方案-ConcurrentHashMap" class="headerlink" title="5.3.2、解决方案-ConcurrentHashMap"></a>5.3.2、解决方案-ConcurrentHashMap</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                map.put(key, UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 异常时终止程序, 0表示正常终止，非零值表示异常终止</span></span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6、多线程锁"><a href="#6、多线程锁" class="headerlink" title="6、多线程锁"></a>6、多线程锁</h2><h3 id="6-1、锁的8种情况"><a href="#6-1、锁的8种情况" class="headerlink" title="6.1、锁的8种情况"></a>6.1、锁的8种情况</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 17:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">        <span class="comment">//停4秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">","</span> + <span class="string">"发短信"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">","</span> + <span class="string">"发邮件"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8种锁的总结：</span></span><br><span class="line"><span class="comment"> * 1 标准访问，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> *      A,发短信</span></span><br><span class="line"><span class="comment"> *      B,发邮件</span></span><br><span class="line"><span class="comment"> * 2 停4秒在短信方法内，先打印短后还是邮件</span></span><br><span class="line"><span class="comment"> *      A,发短信</span></span><br><span class="line"><span class="comment"> *      B,发邮件</span></span><br><span class="line"><span class="comment"> * 3 新增誉通heLLo方法还是先打短后还是hello</span></span><br><span class="line"><span class="comment"> *      hello</span></span><br><span class="line"><span class="comment"> *      A,发短信</span></span><br><span class="line"><span class="comment"> * 4 现在有两部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> *      B,发邮件</span></span><br><span class="line"><span class="comment"> *      A,发短信</span></span><br><span class="line"><span class="comment"> * 5 两个静态同步方法，1部手机，先打印短层还是邮件</span></span><br><span class="line"><span class="comment"> *      A,发短信</span></span><br><span class="line"><span class="comment"> *      B,发邮件</span></span><br><span class="line"><span class="comment"> * 6 两个静态同步方法，2部手机，先打印短层还是邮件</span></span><br><span class="line"><span class="comment"> *      A,发短信</span></span><br><span class="line"><span class="comment"> *      B,发邮件</span></span><br><span class="line"><span class="comment"> * 7 1个静态同步方法，1个普通同步方法，1部手机，先打印短信后还是邮件</span></span><br><span class="line"><span class="comment"> *      B,发邮件</span></span><br><span class="line"><span class="comment"> *      A,发短信</span></span><br><span class="line"><span class="comment"> * 8 1个静态同步方法，1个普通同步方法，2部手机，先打印短信后还是邮件</span></span><br><span class="line"><span class="comment"> *      B,发邮件</span></span><br><span class="line"><span class="comment"> *      A,发短信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//                phone.sendEmail();</span></span><br><span class="line"><span class="comment">//                phone.getHello();</span></span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>结论</strong>：</p>
<p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁，具体表现为以下3种形式。<br><strong>对于普通同步方法，锁是当前实例对象。</strong><br><strong>对于静态同步方法，锁是当前类的c1ass对象。</strong><br><strong>对于同步方法块，锁是Synchonized括号里配置的对象</strong></p>
<h3 id="6-2、公平锁和非公平锁"><a href="#6-2、公平锁和非公平锁" class="headerlink" title="6.2、公平锁和非公平锁"></a>6.2、公平锁和非公平锁</h3><p>在并发编程中，公平锁（Fair Lock）和非公平锁（Non-fair Lock）是两种常见的锁机制，它们主要用于控制多个线程对共享资源的访问顺序。</p>
<h4 id="6-2-1、公平锁（Fair-Lock）"><a href="#6-2-1、公平锁（Fair-Lock）" class="headerlink" title="6.2.1、公平锁（Fair Lock）"></a>6.2.1、公平锁（Fair Lock）</h4><p><strong>定义</strong>：公平锁是指多个线程按照请求锁的顺序来获取锁，即先请求的线程先获得锁。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>顺序性</strong>：线程按照请求锁的顺序排队，先到先得。</li>
<li><strong>公平性</strong>：避免了线程饥饿（Starvation），即某个线程长时间无法获得锁的情况。</li>
<li><strong>性能开销</strong>：由于需要维护一个有序的队列，公平锁的性能通常比非公平锁差，因为每次获取锁时都需要检查队列并进行相应的操作。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>当系统对线程的执行顺序有严格要求时，或者需要避免线程饥饿时，可以使用公平锁。</li>
</ul>
<p><strong>示例</strong>：<br>在Java中，<code>ReentrantLock</code>可以通过构造函数指定为公平锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">// true表示公平锁</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="6-2-2、非公平锁（Non-fair-Lock）"><a href="#6-2-2、非公平锁（Non-fair-Lock）" class="headerlink" title="6.2.2、非公平锁（Non-fair Lock）"></a>6.2.2、非公平锁（Non-fair Lock）</h4><p><strong>定义</strong>：非公平锁是指多个线程获取锁的顺序不一定是按照请求锁的顺序，即线程可以插队获取锁。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>无序性</strong>：线程获取锁的顺序不固定，新来的线程有可能在当前持有锁的线程释放锁后立即获取锁，而不需要排队。</li>
<li><strong>性能优势</strong>：由于不需要维护有序队列，非公平锁的性能通常比公平锁好，尤其是在高并发环境下，因为减少了线程上下文切换的开销。</li>
<li><strong>可能的饥饿问题</strong>：某些线程可能会长时间无法获得锁，导致线程饥饿。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>当系统对线程的执行顺序没有严格要求，且希望提高并发性能时，可以使用非公平锁。</li>
</ul>
<p><strong>示例</strong>：<br>在Java中，<code>ReentrantLock</code>默认是非公平锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">nonFairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>); <span class="comment">// false表示非公平锁，默认就是false</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="6-2-3、总结"><a href="#6-2-3、总结" class="headerlink" title="6.2.3、总结"></a>6.2.3、总结</h4><ul>
<li><strong>公平锁</strong>：按照请求顺序获取锁，避免线程饥饿，但性能较差。</li>
<li><strong>非公平锁</strong>：不按照请求顺序获取锁，性能较好，但可能导致线程饥饿。</li>
</ul>
<p>选择公平锁还是非公平锁取决于具体的应用场景和性能需求。在大多数情况下，非公平锁是更好的选择，因为它提供了更好的性能。但在某些需要严格顺序控制或避免线程饥饿的场景中，公平锁可能更合适。</p>
<h3 id="6-3、可重入锁（Reentrant-Lock）"><a href="#6-3、可重入锁（Reentrant-Lock）" class="headerlink" title="6.3、可重入锁（Reentrant Lock）"></a>6.3、可重入锁（Reentrant Lock）</h3><p><strong>定义</strong>：可重入锁是一种特殊的锁机制，它允许同一个线程多次获取同一个锁，而不会导致死锁。换句话说，如果一个线程已经持有了某个锁，它可以再次获取该锁而不会被阻塞。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>可重入性</strong>：同一个线程可以多次获取同一个锁，而不会被自己阻塞。</li>
<li><strong>计数机制</strong>：每次线程获取锁时，锁的计数器会加1；每次线程释放锁时，计数器会减1。只有当计数器归零时，锁才会被完全释放。</li>
<li><strong>避免死锁</strong>：可重入锁避免了线程在获取自己已经持有的锁时发生死锁的情况。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>递归调用</strong>：在递归方法中，同一个线程可能会多次进入需要加锁的代码块。</li>
<li><strong>嵌套锁</strong>：在复杂的并发场景中，同一个线程可能会在不同的代码块中多次获取同一个锁。</li>
</ul>
<p><strong>示例</strong>：<br>在Java中，<code>ReentrantLock</code>是一个典型的可重入锁实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"Outer method acquired the lock."</span>);</span><br><span class="line">            innerMethod(); <span class="comment">// 调用另一个需要加锁的方法</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"Inner method acquired the lock."</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReentrantLockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockExample</span>();</span><br><span class="line">        example.outerMethod();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，<code>outerMethod</code>和<code>innerMethod</code>都使用了同一个<code>ReentrantLock</code>实例。由于<code>ReentrantLock</code>是可重入的，<code>innerMethod</code>可以在<code>outerMethod</code>已经持有锁的情况下再次获取锁，而不会导致死锁。</p>
<p><strong>可重入锁的优势</strong></p>
<ol>
<li><strong>避免死锁</strong>：可重入锁允许线程多次获取同一个锁，避免了因递归调用或嵌套锁导致的死锁问题。</li>
<li><strong>简化编程</strong>：开发人员不需要担心同一个线程在不同代码块中多次获取锁的问题，简化了并发编程的复杂性。</li>
<li><strong>灵活性</strong>：可重入锁提供了更高的灵活性，适用于各种复杂的并发场景。</li>
</ol>
<p><strong>总结</strong></p>
<p>可重入锁是一种允许同一个线程多次获取同一个锁的机制，它通过计数机制来管理锁的获取和释放，避免了死锁问题，简化了并发编程的复杂性。在Java中，<code>ReentrantLock</code>是一个典型的可重入锁实现，广泛应用于各种并发场景中。</p>
<h4 id="6-3-1、synchronized可重用锁（隐式）"><a href="#6-3-1、synchronized可重用锁（隐式）" class="headerlink" title="6.3.1、synchronized可重用锁（隐式）"></a>6.3.1、synchronized可重用锁（隐式）</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/9 20:09</span></span><br><span class="line"><span class="comment"> * 可重用锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncLockDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>{</span><br><span class="line">        add();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        Object obj = new Object();</span></span><br><span class="line"><span class="comment">//        new Thread(() -&gt; {</span></span><br><span class="line"><span class="comment">//            synchronized (obj) {</span></span><br><span class="line"><span class="comment">//                System.out.println(Thread.currentThread().getName() + " 外层");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                synchronized (obj) {</span></span><br><span class="line"><span class="comment">//                    System.out.println(Thread.currentThread().getName() + " 中层");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    synchronized (obj) {</span></span><br><span class="line"><span class="comment">//                        System.out.println(Thread.currentThread().getName() + " 内层");</span></span><br><span class="line"><span class="comment">//                    }</span></span><br><span class="line"><span class="comment">//                }</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//        }, "t1").start();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SyncLockDemo</span>().add();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="6-3-2、Lock可重用锁（显示）"><a href="#6-3-2、Lock可重用锁（显示）" class="headerlink" title="6.3.2、Lock可重用锁（显示）"></a>6.3.2、Lock可重用锁（显示）</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// Lock演示可重用锁</span></span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 外层"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 内层"</span>);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>注意：上锁与解锁需要配套使用，若只有一个线程，不释放锁也可以正常执行，若有多个线程使用同一把锁，不释放锁会阻塞其他线程正常执行。</p>
<h3 id="6-4、死锁（Deadlock）"><a href="#6-4、死锁（Deadlock）" class="headerlink" title="6.4、死锁（Deadlock）"></a>6.4、死锁（Deadlock）</h3><p><strong>定义</strong>：死锁是指两个或多个线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，这些线程将无法继续执行。</p>
<p><strong>死锁的四个必要条件</strong>：</p>
<ol>
<li><strong>互斥条件</strong>：资源不能被共享，只能由一个线程使用。</li>
<li><strong>请求与保持条件</strong>：线程已经持有一个资源，但又提出了新的资源请求，而该资源被其他线程占用，此时请求线程阻塞，但对自己已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只能由自己释放。</li>
<li><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h4 id="6-4-1、死锁的示例"><a href="#6-4-1、死锁的示例" class="headerlink" title="6.4.1、死锁的示例"></a>6.4.1、死锁的示例</h4><p>以下是一个简单的Java示例，展示了如何通过不当的资源管理导致死锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) {</span><br><span class="line">                System.out.println(<span class="string">"Thread 1 acquired lock1"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟一些工作</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) {</span><br><span class="line">                    System.out.println(<span class="string">"Thread 1 acquired lock2"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) {</span><br><span class="line">                System.out.println(<span class="string">"Thread 2 acquired lock2"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟一些工作</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) {</span><br><span class="line">                    System.out.println(<span class="string">"Thread 2 acquired lock1"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，<code>thread1</code>和<code>thread2</code>分别尝试获取<code>lock1</code>和<code>lock2</code>，但由于它们的获取顺序不同，最终会导致死锁：</p>
<ul>
<li><code>thread1</code>先获取<code>lock1</code>，然后尝试获取<code>lock2</code>。</li>
<li><code>thread2</code>先获取<code>lock2</code>，然后尝试获取<code>lock1</code>。</li>
</ul>
<p>由于两个线程都在等待对方释放资源，因此它们都无法继续执行，形成了死锁。</p>
<h4 id="6-4-2、如何避免死锁"><a href="#6-4-2、如何避免死锁" class="headerlink" title="6.4.2、如何避免死锁"></a>6.4.2、如何避免死锁</h4><ol>
<li><strong>避免嵌套锁</strong>：尽量减少锁的嵌套使用，避免多个线程同时持有多个锁。</li>
<li><strong>统一锁顺序</strong>：如果必须使用多个锁，确保所有线程以相同的顺序获取锁，避免循环等待。</li>
<li><strong>使用定时锁</strong>：在获取锁时设置超时时间，如果无法在规定时间内获取锁，则放弃并重试。</li>
<li><strong>使用可重入锁</strong>：可重入锁允许线程多次获取同一个锁，避免了因递归调用或嵌套锁导致的死锁问题。</li>
<li><strong>资源分级</strong>：将资源进行分级，高优先级的资源先获取，低优先级的资源后获取。</li>
</ol>
<p>以下是一个避免死锁的示例，通过统一锁顺序来避免死锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockAvoidanceExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) {</span><br><span class="line">                System.out.println(<span class="string">"Thread 1 acquired lock1"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟一些工作</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) {</span><br><span class="line">                    System.out.println(<span class="string">"Thread 1 acquired lock2"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) {</span><br><span class="line">                System.out.println(<span class="string">"Thread 2 acquired lock1"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟一些工作</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) {</span><br><span class="line">                    System.out.println(<span class="string">"Thread 2 acquired lock2"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，<code>thread1</code>和<code>thread2</code>都以相同的顺序获取<code>lock1</code>和<code>lock2</code>，从而避免了死锁。</p>
<h4 id="6-4-3、如何检测死锁"><a href="#6-4-3、如何检测死锁" class="headerlink" title="6.4.3、如何检测死锁"></a>6.4.3、如何检测死锁</h4><p>可以使用 <code>jsp</code> 和 <code>jstack</code> 命令检测，需要将jdk的bin目录添加到系统环境变量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756e67d8c7b0.webp" alt="image-20241209204549535"></p>
<p>执行java程序后，在终端执行命令<code>jps -l</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756e6261864b.webp" alt="image-20241209204421998"></p>
<p>找到要检测的程序进程号，例如此处我要查看的是<code>com.shiguang.sync.DeadlockExample</code>这个类，可以看到进程号是<code>11012</code>,使用<code> jstack 11012</code> 命令，可以看到输出了<code>Found 1 deadlock.</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756e732b2824.webp" alt="image-20241209204850678"></p>
<h2 id="7、Callable接口"><a href="#7、Callable接口" class="headerlink" title="7、Callable接口"></a>7、Callable接口</h2><p>目前我们学习了有两种创建线程的方法-一种是通过创建Thread类，另一种是通过使用Runnable创建线程。但是，Runnable缺少的一项功能是，当线程终止时（即run()完成时），我们无法使线程返回结果。为了支持此功能，Java中提供了Callable接口。</p>
<h3 id="7-1、测试案例"><a href="#7-1、测试案例" class="headerlink" title="7.1、测试案例"></a>7.1、测试案例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created By Shiguang On 2024/12/10 9:34</span></span><br><span class="line"><span class="comment"> * 比较Runnable和Callable的区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" come in callable"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line"><span class="comment">//        new Thread(new MyThread1(), "A").start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能直接通过new Thread 调用call方法，</span></span><br><span class="line">        <span class="comment">// 需要借助FutureTask,FutureTask是Runnable的实现类，其构造可以接受Callable的实现类</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread2</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" come in callable"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2, <span class="string">"lucy"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1, <span class="string">"mary"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        while (!futureTask2.isDone()) {</span></span><br><span class="line"><span class="comment">//            // 等待callable执行完成</span></span><br><span class="line"><span class="comment">//            System.out.println("waiting...");</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"></span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次调用执行结果，会直接返回缓存的结果，不会重新调用callable</span></span><br><span class="line"><span class="comment">//        System.out.println(futureTask2.get());</span></span><br><span class="line"></span><br><span class="line">        System.out.println(futureTask1.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" come in main over"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="7-2、Callable接口的特点如下（重点）"><a href="#7-2、Callable接口的特点如下（重点）" class="headerlink" title="7.2、Callable接口的特点如下（重点）"></a>7.2、Callable接口的特点如下（重点）</h3><ul>
<li>为了实现Runnable,需要实现不返回任何内容的run()方法，而对于Callable,需要实现在完成时返回结果的call()方法。</li>
<li>cal()方法可以引发异常，而run()则不能。</li>
<li>为实现Callable而必须重写call方法。</li>
</ul>
<h3 id="7-3、Callable-与-Runnable-的区别"><a href="#7-3、Callable-与-Runnable-的区别" class="headerlink" title="7.3、Callable 与 Runnable 的区别"></a>7.3、Callable 与 Runnable 的区别</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Callable</code></th>
<th align="left"><code>Runnable</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left"><code>call()</code>方法</td>
<td align="left"><code>run()</code>方法</td>
</tr>
<tr>
<td align="left"><strong>返回值</strong></td>
<td align="left">可以返回结果（通过 <code>call()</code> 方法）</td>
<td align="left">无返回值（<code>run()</code> 方法无返回值）</td>
</tr>
<tr>
<td align="left"><strong>异常处理</strong></td>
<td align="left">可以抛出受检异常（<code>call()</code> 方法）</td>
<td align="left">不能抛出受检异常（<code>run()</code> 方法）</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">需要返回结果或可能抛出异常的任务</td>
<td align="left">不需要返回结果的任务</td>
</tr>
</tbody></table>
<h3 id="7-4、FutureTask介绍"><a href="#7-4、FutureTask介绍" class="headerlink" title="7.4、FutureTask介绍"></a>7.4、FutureTask介绍</h3><p><code>FutureTask</code> 是 Java 并发编程中的一个重要类，位于 <code>java.util.concurrent</code> 包中。它是 <code>Future</code> 接口的实现类，同时也是 <code>Runnable</code> 接口的实现类。<code>FutureTask</code> 的主要作用是封装一个可以异步执行的任务，并提供对任务执行状态和结果的管理。</p>
<p><code>FutureTask</code> 的定义**</p>
<p><code>FutureTask</code> 实现了以下接口：</p>
<ul>
<li><code>RunnableFuture</code>：<code>RunnableFuture</code> 接口继承了 <code>Runnable</code> 和 <code>Future</code> 接口，因此 <code>FutureTask</code> 既可以作为任务被执行，也可以管理任务的状态和结果。</li>
</ul>
<p><code>FutureTask</code> 的构造方法可以接受一个 <code>Callable</code> 或 <code>Runnable</code> 对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> {</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> {</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><code>FutureTask</code> 的核心功能**</p>
<p><code>FutureTask</code> 的主要功能包括：</p>
<ol>
<li><strong>任务执行</strong>：<code>FutureTask</code> 可以封装一个 <code>Callable</code> 或 <code>Runnable</code> 任务，并由线程池或单独的线程执行。</li>
<li><strong>状态管理</strong>：<code>FutureTask</code> 管理任务的执行状态，包括：<ul>
<li><strong>未启动</strong>：任务还未开始执行。</li>
<li><strong>运行中</strong>：任务正在执行。</li>
<li><strong>已完成</strong>：任务执行完成（正常完成、异常完成或被取消）。</li>
</ul>
</li>
<li><strong>结果获取</strong>：通过 <code>Future</code> 接口的方法（如 <code>get()</code>）获取任务的执行结果。</li>
<li><strong>取消任务</strong>：可以通过 <code>cancel()</code> 方法取消任务的执行。</li>
</ol>
<p><code>FutureTask</code> 的核心功能**</p>
<p><code>FutureTask</code> 的主要功能包括：</p>
<ol>
<li><strong>任务执行</strong>：<code>FutureTask</code> 可以封装一个 <code>Callable</code> 或 <code>Runnable</code> 任务，并由线程池或单独的线程执行。</li>
<li><strong>状态管理</strong>：<code>FutureTask</code> 管理任务的执行状态，包括：<ul>
<li><strong>未启动</strong>：任务还未开始执行。</li>
<li><strong>运行中</strong>：任务正在执行。</li>
<li><strong>已完成</strong>：任务执行完成（正常完成、异常完成或被取消）。</li>
</ul>
</li>
<li><strong>结果获取</strong>：通过 <code>Future</code> 接口的方法（如 <code>get()</code>）获取任务的执行结果。</li>
<li><strong>取消任务</strong>：可以通过 <code>cancel()</code> 方法取消任务的执行。</li>
</ol>
<h2 id="8、JUC强大的辅助类"><a href="#8、JUC强大的辅助类" class="headerlink" title="8、JUC强大的辅助类"></a>8、JUC强大的辅助类</h2><h3 id="8-1、减少技术CountDownLatch"><a href="#8-1、减少技术CountDownLatch" class="headerlink" title="8.1、减少技术CountDownLatch"></a>8.1、减少技术CountDownLatch</h3><p>CountDownLatch类可以设置一个计数器，然后通过<code>countDown()</code>方法来进行减1的操作，使用<code>await()</code>方法等待计数器不大于0，然后继续执行<code>await()</code>方法之后的语句。</p>
<ul>
<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li>
<li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)。</li>
<li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</li>
</ul>
<h4 id="8-1-1、锁门案例"><a href="#8-1-1、锁门案例" class="headerlink" title="8.1.1、锁门案例"></a>8.1.1、锁门案例</h4><p>要求：教室内有一个班长和6名同学，6名同学陆续离开教室，全部离开教室后班长进行锁门操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="comment">// 6个同学陆续离开教室后，班长才锁门</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 号同学离开了教室"</span>);</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">" 班长锁门了"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757a808be30a.webp" alt="image-20241210103136378"></p>
<p>可以看到，其他同学还没有离开教室班长就已经锁门了，不符合我们的预期要求，接下来再看下使用CountDownLatch来实现该案例</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="comment">// 6个同学陆续离开教室后，班长才锁门</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建CountDownLatch对象，设置初始值为6</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 号同学离开了教室"</span>);</span><br><span class="line">            <span class="comment">// 计数器减一</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待计数器归零</span></span><br><span class="line">    countDownLatch.await();</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" 班长锁门了"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757a94408d3a.webp" alt="image-20241210103652803"></p>
<p>可以看到，同学离开的顺序随机，全部同学离开后班长锁门，符合我们的预期。</p>
<h3 id="8-2、循环栅栏CyclicBarrier"><a href="#8-2、循环栅栏CyclicBarrier" class="headerlink" title="8.2、循环栅栏CyclicBarrier"></a>8.2、循环栅栏CyclicBarrier</h3><p>CyclicBarrier看英文单词可以看出大概就是循环阻塞的意思，在使用中CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier.await(之后的语句。可以将CyclicBarrier理解为加1操作。</p>
<h4 id="8-2-1、召唤神龙案例"><a href="#8-2-1、召唤神龙案例" class="headerlink" title="8.2.1、召唤神龙案例"></a>8.2.1、召唤神龙案例</h4><p>要求：集齐7颗龙珠后方可召唤神龙</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 集齐7颗龙珠后方可召唤神龙</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, () -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"龙珠已集齐,召唤神龙"</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集齐7颗龙珠的过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span> ; i++) {</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">" 星龙被收集到了"</span>);</span><br><span class="line">               <span class="keyword">try</span> {</span><br><span class="line">                   cyclicBarrier.await();</span><br><span class="line">               } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">           }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757ac8d37afe.webp" alt="image-20241210105053980"></p>
<h3 id="8-3、信号灯Semaphore"><a href="#8-3、信号灯Semaphore" class="headerlink" title="8.3、信号灯Semaphore"></a>8.3、信号灯Semaphore</h3><h4 id="8-3-1、案例"><a href="#8-3-1、案例" class="headerlink" title="8.3.1、案例"></a>8.3.1、案例</h4><p>要求：6辆车，停3个车位</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="comment">// 6辆车，停3个车位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Semaphore对象,设置许可数量</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟6辆车</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 抢占</span></span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 抢到了车位"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置随机停车时间</span></span><br><span class="line">                <span class="comment">//                    Thread.sleep((long) (Math.random() * 1000));</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" &gt;&gt;&gt;离开了车位"</span>);</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 释放</span></span><br><span class="line">                semaphore.release();</span><br><span class="line">            }</span><br><span class="line">        }, String.valueOf(i)).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757af84297ee.webp" alt="image-20241210110332953"></p>
<h2 id="9、ReentrantReadWriteLock读写锁"><a href="#9、ReentrantReadWriteLock读写锁" class="headerlink" title="9、ReentrantReadWriteLock读写锁"></a>9、ReentrantReadWriteLock读写锁</h2><h3 id="9-1、乐观锁和悲观锁"><a href="#9-1、乐观锁和悲观锁" class="headerlink" title="9.1、乐观锁和悲观锁"></a>9.1、乐观锁和悲观锁</h3><p>在并发编程中，<strong>乐观锁（Optimistic Locking）</strong> 和 <strong>悲观锁（Pessimistic Locking）</strong> 是两种常见的并发控制策略，用于解决多个线程对共享资源的访问冲突问题。它们的区别主要在于对资源竞争的态度和处理方式。</p>
<h4 id="9-1-1、悲观锁（Pessimistic-Locking）"><a href="#9-1-1、悲观锁（Pessimistic-Locking）" class="headerlink" title="9.1.1、悲观锁（Pessimistic Locking）"></a>9.1.1、悲观锁（Pessimistic Locking）</h4><p> <strong>基本概念</strong></p>
<p>悲观锁是一种“悲观”的并发控制策略，假设在任何时候都可能发生资源竞争，因此在访问共享资源时，会立即加锁以防止其他线程访问。</p>
<p><strong>工作原理</strong></p>
<ul>
<li><strong>加锁</strong>：在访问共享资源之前，先获取锁。</li>
<li><strong>独占访问</strong>：在持有锁的期间，其他线程无法访问该资源。</li>
<li><strong>解锁</strong>：操作完成后，释放锁，允许其他线程获取锁。</li>
</ul>
<p> <strong>实现方式</strong></p>
<p>悲观锁通常通过以下方式实现：</p>
<ul>
<li><strong>数据库锁</strong>：如行锁、表锁。</li>
<li><strong>Java 锁</strong>：如 <code>synchronized</code> 关键字、<code>ReentrantLock</code>。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>安全性高</strong>：能够有效避免资源竞争问题，保证数据一致性。</li>
<li><strong>简单易用</strong>：实现简单，适合对资源竞争频繁的场景。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>性能开销</strong>：频繁加锁和解锁会导致性能下降。</li>
<li><strong>并发性低</strong>：独占访问会降低系统的并发性能。</li>
</ul>
<p> <strong>适用场景</strong></p>
<ul>
<li><strong>写操作频繁</strong>：当写操作较多时，悲观锁可以有效避免数据冲突。</li>
<li><strong>资源竞争激烈</strong>：当多个线程频繁竞争同一资源时。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757b03a780cb.webp" alt="image-20241210110635201"></p>
<h4 id="9-1-2、乐观锁（Optimistic-Locking）"><a href="#9-1-2、乐观锁（Optimistic-Locking）" class="headerlink" title="9.1.2、乐观锁（Optimistic Locking）"></a>9.1.2、乐观锁（Optimistic Locking）</h4><p> <strong>基本概念</strong></p>
<p>乐观锁是一种“乐观”的并发控制策略，假设在大多数情况下不会发生资源竞争，因此在访问共享资源时不会立即加锁，而是在提交操作时检查是否有冲突。</p>
<p><strong>工作原理</strong></p>
<ul>
<li><strong>无锁访问</strong>：在访问共享资源时，不加锁，允许多个线程同时访问。</li>
<li><strong>冲突检测</strong>：在提交操作时，检查资源是否被其他线程修改。</li>
<li><strong>重试机制</strong>：如果检测到冲突，则回滚操作并重试。</li>
</ul>
<p><strong>实现方式</strong></p>
<p>乐观锁通常通过以下方式实现：</p>
<ul>
<li><strong>版本号机制</strong>：在数据中添加一个版本号字段，每次更新时检查版本号是否一致。</li>
<li><strong>CAS（Compare-And-Swap）</strong>：通过硬件级别的原子操作实现无锁更新。</li>
</ul>
<p> <strong>优点</strong></p>
<ul>
<li><strong>性能高</strong>：在资源竞争不激烈的情况下，性能优于悲观锁。</li>
<li><strong>并发性好</strong>：允许多个线程同时访问资源，提高了并发性能。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>复杂性高</strong>：需要实现冲突检测和重试机制，实现较为复杂。</li>
<li><strong>适用性有限</strong>：适用于读多写少的场景，写操作频繁时性能可能下降。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>读操作频繁</strong>：当读操作远远多于写操作时，乐观锁可以显著提高性能。</li>
<li><strong>资源竞争不激烈</strong>：当多个线程对同一资源的竞争较少时。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757b0613c82c.webp" alt="image-20241210110713930"></p>
<h4 id="9-1-3、乐观锁与悲观锁的对比"><a href="#9-1-3、乐观锁与悲观锁的对比" class="headerlink" title="9.1.3、乐观锁与悲观锁的对比"></a>9.1.3、乐观锁与悲观锁的对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">悲观锁（Pessimistic Locking）</th>
<th align="left">乐观锁（Optimistic Locking）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>资源访问</strong></td>
<td align="left">访问前加锁，独占访问</td>
<td align="left">访问时不加锁，允许多线程同时访问</td>
</tr>
<tr>
<td align="left"><strong>冲突处理</strong></td>
<td align="left">通过加锁避免冲突</td>
<td align="left">通过冲突检测和重试机制处理冲突</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">写操作频繁时性能较好</td>
<td align="left">读操作频繁时性能较好</td>
</tr>
<tr>
<td align="left"><strong>实现复杂性</strong></td>
<td align="left">实现简单，适合资源竞争频繁的场景</td>
<td align="left">实现复杂，适合资源竞争不激烈的场景</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">写操作频繁、资源竞争激烈的场景</td>
<td align="left">读操作频繁、资源竞争不激烈的场景</td>
</tr>
</tbody></table>
<h4 id="9-1-4、乐观锁的实现示例（版本号机制）"><a href="#9-1-4、乐观锁的实现示例（版本号机制）" class="headerlink" title="9.1.4、乐观锁的实现示例（版本号机制）"></a>9.1.4、乐观锁的实现示例（版本号机制）</h4><p>以下是一个使用版本号机制实现乐观锁的示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimisticLockExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OptimisticLockExample</span><span class="params">(<span class="type">int</span> data)</span> {</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.version = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(<span class="type">int</span> newData, <span class="type">int</span> expectedVersion)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.version == expectedVersion) {</span><br><span class="line">            <span class="comment">// 版本号匹配，更新数据</span></span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">            <span class="built_in">this</span>.version++; <span class="comment">// 更新版本号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 版本号不匹配，更新失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">OptimisticLockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockExample</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1尝试更新数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> example.updateData(<span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread 1 update success: "</span> + success);</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2尝试更新数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> example.updateData(<span class="number">300</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread 2 update success: "</span> + success);</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="9-1-5、悲观锁的实现示例（synchronized）"><a href="#9-1-5、悲观锁的实现示例（synchronized）" class="headerlink" title="9.1.5、悲观锁的实现示例（synchronized）"></a>9.1.5、悲观锁的实现示例（<code>synchronized</code>）</h4><p>以下是一个使用 <code>synchronized</code> 实现悲观锁的示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PessimisticLockExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PessimisticLockExample</span><span class="params">(<span class="type">int</span> data)</span> {</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(<span class="type">int</span> newData)</span> {</span><br><span class="line">        <span class="comment">// 加锁，独占访问</span></span><br><span class="line">        <span class="built_in">this</span>.data = newData;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">readData</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 加锁，独占访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">PessimisticLockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PessimisticLockExample</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1更新数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            example.updateData(<span class="number">200</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread 1 updated data to: "</span> + example.readData());</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2读取数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Thread 2 read data: "</span> + example.readData());</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="9-1-6、总结"><a href="#9-1-6、总结" class="headerlink" title="9.1.6、总结"></a>9.1.6、总结</h4><ul>
<li><strong>悲观锁</strong>：假设资源竞争频繁，通过加锁避免冲突，适合写操作频繁的场景。</li>
<li><strong>乐观锁</strong>：假设资源竞争不频繁，通过冲突检测处理冲突，适合读操作频繁的场景。</li>
</ul>
<p>在实际应用中，选择乐观锁还是悲观锁需要根据具体的业务场景和资源竞争情况来决定。如果写操作较多，悲观锁是更好的选择；如果读操作较多，乐观锁可以显著提高性能。</p>
<h3 id="9-2、表锁和行锁"><a href="#9-2、表锁和行锁" class="headerlink" title="9.2、表锁和行锁"></a>9.2、表锁和行锁</h3><p>在数据库管理系统（DBMS）中，<strong>表锁（Table Lock）</strong> 和 <strong>行锁（Row Lock）</strong> 是两种常见的锁机制，用于控制并发事务对数据库表和行的访问。它们的主要目的是确保数据的一致性和完整性，同时避免并发操作导致的冲突问题。</p>
<h4 id="9-2-1、表锁（Table-Lock）"><a href="#9-2-1、表锁（Table-Lock）" class="headerlink" title="9.2.1、表锁（Table Lock）"></a>9.2.1、表锁（Table Lock）</h4><p> <strong>基本概念</strong></p>
<p>表锁是对整个数据库表加锁的机制。当一个事务对某个表加锁时，其他事务无法对该表进行某些操作，直到锁被释放。</p>
<p><strong>工作原理</strong></p>
<ul>
<li><strong>加锁</strong>：事务在操作表之前，先对整个表加锁。</li>
<li><strong>独占访问</strong>：在锁被持有的期间，其他事务无法对该表进行某些操作（如写操作）。</li>
<li><strong>解锁</strong>：事务操作完成后，释放锁，允许其他事务访问。</li>
</ul>
<p><strong>表锁的类型</strong></p>
<p>表锁可以分为以下两种类型：</p>
<ol>
<li><strong>共享锁（Shared Lock，S锁）</strong>：<ul>
<li>允许多个事务同时持有共享锁，用于读操作。</li>
<li>持有共享锁的事务可以读取表，但不能修改表。</li>
</ul>
</li>
<li><strong>排他锁（Exclusive Lock，X锁）</strong>：<ul>
<li>只允许一个事务持有排他锁，用于写操作。</li>
<li>持有排他锁的事务可以读取和修改表，其他事务无法获取任何类型的锁。</li>
</ul>
</li>
</ol>
<p> <strong>优点</strong></p>
<ul>
<li><strong>简单易用</strong>：实现简单，适合对整个表的操作。</li>
<li><strong>安全性高</strong>：能够有效避免表级别的冲突。</li>
</ul>
<p> <strong>缺点</strong></p>
<ul>
<li><strong>并发性低</strong>：锁的粒度较大，可能导致其他事务长时间等待。</li>
<li><strong>性能开销</strong>：频繁加锁和解锁会导致性能下降。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>全表操作</strong>：如批量插入、删除或更新整个表。</li>
<li><strong>资源竞争激烈</strong>：当多个事务频繁竞争整个表时。</li>
</ul>
<h4 id="9-2-2、行锁（Row-Lock）"><a href="#9-2-2、行锁（Row-Lock）" class="headerlink" title="9.2.2、行锁（Row Lock）"></a>9.2.2、行锁（Row Lock）</h4><p><strong>基本概念</strong></p>
<p>行锁是对数据库表中的某一行或多行加锁的机制。当一个事务对某一行加锁时，其他事务无法对该行进行某些操作，直到锁被释放。</p>
<p><strong>工作原理</strong></p>
<ul>
<li><strong>加锁</strong>：事务在操作某一行之前，先对该行加锁。</li>
<li><strong>独占访问</strong>：在锁被持有的期间，其他事务无法对该行进行某些操作（如写操作）。</li>
<li><strong>解锁</strong>：事务操作完成后，释放锁，允许其他事务访问。</li>
</ul>
<p><strong>行锁的类型</strong></p>
<p>行锁的类型与表锁类似，分为以下两种：</p>
<ol>
<li><strong>共享锁（Shared Lock，S锁）</strong>：<ul>
<li>允许多个事务同时持有共享锁，用于读操作。</li>
<li>持有共享锁的事务可以读取行，但不能修改行。</li>
</ul>
</li>
<li><strong>排他锁（Exclusive Lock，X锁）</strong>：<ul>
<li>只允许一个事务持有排他锁，用于写操作。</li>
<li>持有排他锁的事务可以读取和修改行，其他事务无法获取任何类型的锁。</li>
</ul>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li><strong>并发性高</strong>：锁的粒度较小，允许多个事务同时操作不同的行。</li>
<li><strong>性能较好</strong>：在大多数情况下，行锁的性能优于表锁。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>复杂性高</strong>：实现和管理行锁比表锁更复杂。</li>
<li><strong>死锁风险</strong>：由于锁的粒度较小，可能导致死锁问题。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>单行操作</strong>：如更新、删除或查询单行数据。</li>
<li><strong>资源竞争不激烈</strong>：当多个事务对不同行的竞争较少时。</li>
</ul>
<h4 id="9-2-3、-表锁与行锁的对比"><a href="#9-2-3、-表锁与行锁的对比" class="headerlink" title="9.2.3、 表锁与行锁的对比"></a>9.2.3、 <strong>表锁与行锁的对比</strong></h4><table>
<thead>
<tr>
<th>特性</th>
<th>表锁（Table Lock）</th>
<th>行锁（Row Lock）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>锁的粒度</strong></td>
<td>锁的粒度较大，对整个表加锁</td>
<td>锁的粒度较小，对单行或多行加锁</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>并发性较低，可能导致其他事务长时间等待</td>
<td>并发性较高，允许多个事务同时操作不同行</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>性能较低，频繁加锁和解锁会导致性能下降</td>
<td>性能较高，锁的粒度较小，性能较好</td>
</tr>
<tr>
<td><strong>复杂性</strong></td>
<td>实现简单，管理较容易</td>
<td>实现复杂，管理较困难，可能引发死锁</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>全表操作、资源竞争激烈的场景</td>
<td>单行操作、资源竞争不激烈的场景</td>
</tr>
</tbody></table>
<hr>
<h4 id="9-2-4、-表锁与行锁的使用示例"><a href="#9-2-4、-表锁与行锁的使用示例" class="headerlink" title="9.2.4、 表锁与行锁的使用示例"></a>9.2.4、 <strong>表锁与行锁的使用示例</strong></h4><p><strong>表锁示例</strong></p>
<p>在 MySQL 中，可以通过 <code>LOCK TABLES</code> 语句显式地对表加锁：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对表加共享锁</span></span><br><span class="line">LOCK TABLES my_table READ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对表加排他锁</span></span><br><span class="line">LOCK TABLES my_table WRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>行锁示例</strong></p>
<p>在 MySQL 中，行锁通常由事务自动管理。例如，在 InnoDB 存储引擎中，行锁会在事务执行时自动加锁：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对某一行加排他锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> my_table <span class="keyword">SET</span> column1 <span class="operator">=</span> <span class="string">'new_value'</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，释放锁</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="9-2-5、-表锁与行锁的实际应用"><a href="#9-2-5、-表锁与行锁的实际应用" class="headerlink" title="9.2.5、 表锁与行锁的实际应用"></a>9.2.5、 <strong>表锁与行锁的实际应用</strong></h4><p><strong>表锁的应用</strong></p>
<ul>
<li><strong>批量操作</strong>：如批量插入、删除或更新整个表。</li>
<li><strong>数据备份</strong>：在备份数据时，对表加锁以确保数据一致性。</li>
</ul>
<p><strong>行锁的应用</strong></p>
<ul>
<li><strong>事务隔离</strong>：在事务中对单行数据进行更新或删除操作。</li>
<li><strong>并发控制</strong>：在多用户并发访问数据库时，确保单行数据的一致性。</li>
</ul>
<h4 id="9-2-6、-总结"><a href="#9-2-6、-总结" class="headerlink" title="9.2.6、 总结"></a>9.2.6、 <strong>总结</strong></h4><ul>
<li><strong>表锁</strong>：锁的粒度较大，适合全表操作和资源竞争激烈的场景，但并发性较低。</li>
<li><strong>行锁</strong>：锁的粒度较小，适合单行操作和资源竞争不激烈的场景，并发性较高。</li>
</ul>
<p>在实际应用中，选择表锁还是行锁需要根据具体的业务场景和资源竞争情况来决定。如果需要对整个表进行操作，表锁是更好的选择；如果需要对单行数据进行操作，行锁可以显著提高并发性能。</p>
<h3 id="9-3、读写锁"><a href="#9-3、读写锁" class="headerlink" title="9.3、读写锁"></a>9.3、读写锁</h3><p>在并发编程中，<strong>读锁（Read Lock）</strong> 和 <strong>写锁（Write Lock）</strong> 是用于控制对共享资源的访问的机制。它们通常用于实现 <strong>读写锁（Read-Write Lock）</strong>，这是一种特殊的锁机制，允许多个线程同时读取共享资源，但在写操作时需要独占访问。</p>
<h4 id="9-3-1、读写锁的基本概念"><a href="#9-3-1、读写锁的基本概念" class="headerlink" title="9.3.1、读写锁的基本概念"></a>9.3.1、读写锁的基本概念</h4><p>读写锁是一种分离锁（Split Lock），它将锁的粒度分为两种：</p>
<ul>
<li><strong>读锁（Read Lock）</strong>：允许多个线程同时持有读锁（又称为共享锁），只要没有线程持有写锁。</li>
<li><strong>写锁（Write Lock）</strong>：只允许一个线程持有写锁（又称为排他锁），且在持有写锁时，其他线程无法持有读锁或写锁。</li>
</ul>
<p>读写锁的核心思想是：</p>
<ul>
<li><strong>读操作</strong>：通常是安全的，允许多个线程并发读取共享资源。</li>
<li><strong>写操作</strong>：通常是独占的，需要保证写操作的线程安全。</li>
</ul>
<h4 id="9-3-2、读写锁的优点"><a href="#9-3-2、读写锁的优点" class="headerlink" title="9.3.2、读写锁的优点"></a>9.3.2、读写锁的优点</h4><ol>
<li><strong>提高并发性</strong>：允许多个线程同时读取共享资源，从而提高并发性能。</li>
<li><strong>降低锁竞争</strong>：读操作之间不需要互斥，减少了锁的竞争。</li>
<li><strong>灵活性</strong>：适用于读多写少的场景，能够更好地平衡性能和线程安全。</li>
</ol>
<h4 id="9-3-3、读写锁的实现"><a href="#9-3-3、读写锁的实现" class="headerlink" title="9.3.3、读写锁的实现"></a>9.3.3、读写锁的实现</h4><p>在 Java 中，读写锁的实现主要依赖于 <code>java.util.concurrent.locks.ReentrantReadWriteLock</code> 类。它提供了读锁和写锁的实现。</p>
<p><code>ReentrantReadWriteLock</code> 类**</p>
<p><code>ReentrantReadWriteLock</code> 是 Java 提供的读写锁实现类，它实现了 <code>ReadWriteLock</code> 接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> {</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;  <span class="comment">// 获取读锁</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>; <span class="comment">// 获取写锁</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>读锁（Read Lock）</strong></p>
<ul>
<li><strong>允许多个线程同时持有</strong>：只要没有线程持有写锁。</li>
<li><strong>获取读锁</strong>：调用 <code>readLock().lock()</code>。</li>
<li><strong>释放读锁</strong>：调用 <code>readLock().unlock()</code>。</li>
</ul>
<p><strong>写锁（Write Lock）</strong></p>
<ul>
<li><strong>只允许一个线程持有</strong>：在持有写锁时，其他线程无法持有读锁或写锁。</li>
<li><strong>获取写锁</strong>：调用 <code>writeLock().lock()</code>。</li>
<li><strong>释放写锁</strong>：调用 <code>writeLock().unlock()</code>。</li>
</ul>
<h4 id="9-3-4、读写锁的使用示例"><a href="#9-3-4、读写锁的使用示例" class="headerlink" title="9.3.4、读写锁的使用示例"></a>9.3.4、读写锁的使用示例</h4><p>以下是一个使用 <code>ReentrantReadWriteLock</code> 的示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sharedData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readData</span><span class="params">()</span> {</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is reading: "</span> + sharedData);</span><br><span class="line">            <span class="keyword">return</span> sharedData;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(<span class="type">int</span> newValue)</span> {</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is writing: "</span> + newValue);</span><br><span class="line">            sharedData = newValue;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReadWriteLockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadWriteLockExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个读线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">                example.readData();</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个写线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            example.writeData(<span class="number">100</span>);</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>课程案例:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> {</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在写入："</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 写入完成："</span> + key);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> {</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在读取&gt;&gt;："</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 读取完成&gt;&gt;："</span> + result);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">                myCache.put(Thread.currentThread().getName(), Thread.currentThread().getName());</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">                myCache.get(Thread.currentThread().getName());</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="9-3-5、读写锁的规则"><a href="#9-3-5、读写锁的规则" class="headerlink" title="9.3.5、读写锁的规则"></a>9.3.5、读写锁的规则</h4><ol>
<li><strong>读锁规则</strong>：<ul>
<li>允许多个线程同时持有读锁。</li>
<li>如果一个线程持有写锁，其他线程无法获取读锁。</li>
</ul>
</li>
<li><strong>写锁规则</strong>：<ul>
<li>只允许一个线程持有写锁。</li>
<li>如果一个线程持有写锁，其他线程无法获取读锁或写锁。</li>
</ul>
</li>
<li><strong>读写互斥</strong>：<ul>
<li>读锁和写锁是互斥的，即持有读锁的线程无法获取写锁，反之亦然。</li>
</ul>
</li>
</ol>
<h4 id="9-3-6、读写锁的适用场景"><a href="#9-3-6、读写锁的适用场景" class="headerlink" title="9.3.6、读写锁的适用场景"></a>9.3.6、读写锁的适用场景</h4><p>读写锁适用于以下场景：</p>
<ol>
<li><strong>读多写少</strong>：当读操作远远多于写操作时，读写锁可以显著提高并发性能。</li>
<li><strong>共享资源访问</strong>：需要对共享资源进行并发读写操作的场景。</li>
<li><strong>缓存系统</strong>：缓存系统通常需要频繁读取数据，但写操作较少。</li>
</ol>
<h4 id="9-3-7、读写锁的缺点"><a href="#9-3-7、读写锁的缺点" class="headerlink" title="9.3.7、读写锁的缺点"></a>9.3.7、读写锁的缺点</h4><ol>
<li><strong>复杂性</strong>：相比于普通锁（如 <code>ReentrantLock</code>），读写锁的实现和使用更复杂。</li>
<li><strong>饥饿问题</strong>：在某些情况下，写锁可能会因为频繁的读操作而长时间无法获取锁，导致写线程饥饿。</li>
<li><strong>性能开销</strong>：读写锁的实现比普通锁更复杂，可能会带来一定的性能开销。</li>
</ol>
<h4 id="9-3-8、读写锁与其他锁的对比"><a href="#9-3-8、读写锁与其他锁的对比" class="headerlink" title="9.3.8、读写锁与其他锁的对比"></a>9.3.8、读写锁与其他锁的对比</h4><table>
<thead>
<tr>
<th>特性</th>
<th>读写锁（Read-Write Lock）</th>
<th>普通锁（ReentrantLock）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>并发性</strong></td>
<td>允许多个线程同时读取共享资源</td>
<td>只允许一个线程持有锁</td>
</tr>
<tr>
<td><strong>互斥性</strong></td>
<td>读锁之间不互斥，读写锁之间互斥</td>
<td>所有操作都需要互斥</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>读多写少的场景</td>
<td>读写操作均衡的场景</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>在读多写少时性能更好</td>
<td>在读写操作均衡时性能更好</td>
</tr>
</tbody></table>
<h4 id="9-3-9、读写锁降级"><a href="#9-3-9、读写锁降级" class="headerlink" title="9.3.9、读写锁降级"></a>9.3.9、读写锁降级</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757df06f194e.webp" alt="15-读写锁降级"></p>
<p><strong>读写锁的降级（Read-Write Lock Downgrade）</strong> 是指在持有写锁的情况下，将写锁降级为读锁的过程。这种操作通常用于并发编程中，以提高系统的并发性能和灵活性。</p>
<p><strong>读写锁降级的概念</strong></p>
<p>在某些场景下，一个线程可能需要先对共享资源进行写操作，然后继续对该资源进行读操作。为了避免在写操作完成后，其他线程无法获取读锁，可以通过降级操作将写锁转换为读锁。</p>
<ul>
<li><strong>降级过程</strong>：<ol>
<li>线程先获取写锁。</li>
<li>完成写操作后，释放写锁。</li>
<li>立即获取读锁。</li>
<li>继续进行读操作。</li>
</ol>
</li>
</ul>
<p><strong>读写锁降级的优点</strong></p>
<ol>
<li><strong>提高并发性</strong>：降级操作允许其他线程在写操作完成后立即获取读锁，从而提高系统的并发性能。</li>
<li><strong>灵活性</strong>：降级操作提供了更灵活的锁管理方式，适用于需要在写操作后继续读取资源的场景。</li>
<li><strong>避免饥饿</strong>：降级操作可以避免写锁长时间占用资源，导致其他线程无法获取读锁或写锁。</li>
</ol>
<p> <strong>读写锁降级的实现</strong></p>
<p>在 Java 中，读写锁的降级可以通过 <code>ReentrantReadWriteLock</code> 实现。以下是降级的基本步骤：</p>
<ol>
<li><strong>获取写锁</strong>：调用 <code>writeLock().lock()</code>。</li>
<li><strong>执行写操作</strong>：对共享资源进行写操作。</li>
<li><strong>释放写锁</strong>：调用 <code>writeLock().unlock()</code>。</li>
<li><strong>获取读锁</strong>：调用 <code>readLock().lock()</code>。</li>
<li><strong>执行读操作</strong>：对共享资源进行读操作。</li>
<li><strong>释放读锁</strong>：调用 <code>readLock().unlock()</code>。</li>
</ol>
<p><strong>读写锁降级的示例</strong></p>
<p>以下是一个使用 <code>ReentrantReadWriteLock</code> 实现读写锁降级的示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDowngradeExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sharedData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downgradeLock</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 执行写操作</span></span><br><span class="line">            sharedData = <span class="number">100</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is writing: "</span> + sharedData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 降级为读锁</span></span><br><span class="line">            rwLock.readLock().lock();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 释放写锁</span></span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 执行读操作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is reading: "</span> + sharedData);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 释放读锁</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReadWriteLockDowngradeExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadWriteLockDowngradeExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程执行降级操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            example.downgradeLock();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>读写锁降级的适用场景</strong></p>
<ol>
<li><strong>写操作后需要读操作</strong>：当一个线程在完成写操作后，需要继续读取资源时。</li>
<li><strong>提高并发性</strong>：在写操作完成后，允许其他线程获取读锁，从而提高系统的并发性能。</li>
<li><strong>避免锁竞争</strong>：通过降级操作，减少写锁的持有时间，避免其他线程长时间等待。</li>
</ol>
<p><strong>读写锁降级的注意事项</strong></p>
<ol>
<li><strong>顺序问题</strong>：必须先释放写锁，再获取读锁，否则会导致死锁。</li>
<li><strong>线程安全</strong>：降级操作必须在同一个线程中完成，否则可能导致并发问题。</li>
<li><strong>性能开销</strong>：频繁的锁降级操作可能会带来一定的性能开销，需要根据具体场景权衡。</li>
</ol>
<p>读写锁降级是一种在持有写锁的情况下，将写锁降级为读锁的操作。它能够提高系统的并发性能，避免锁竞争，适用于写操作后需要继续读取资源的场景。在实现降级操作时，需要注意顺序问题和线程安全，确保操作的正确性。  </p>
<h4 id="3-9-10、读写锁演变"><a href="#3-9-10、读写锁演变" class="headerlink" title="3.9.10、读写锁演变"></a>3.9.10、读写锁演变</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757df5ea60e9.webp" alt="14-读写锁演变"></p>
<h2 id="10、阻塞队列（BlockingQueue）"><a href="#10、阻塞队列（BlockingQueue）" class="headerlink" title="10、阻塞队列（BlockingQueue）"></a>10、阻塞队列（BlockingQueue）</h2><blockquote>
<p>为什么需要BlockingQueue?</p>
<p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。</p>
<p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
</blockquote>
<h3 id="10-1、BlockingQueue简介"><a href="#10-1、BlockingQueue简介" class="headerlink" title="10.1、BlockingQueue简介"></a>10.1、BlockingQueue简介</h3><p><strong>阻塞队列（Blocking Queue）</strong> 是 Java 并发编程中的一个重要工具，位于 <code>java.util.concurrent</code> 包中。它是一种特殊的队列，支持在队列为空时阻塞消费者线程，或在队列满时阻塞生产者线程。阻塞队列常用于生产者-消费者模型中，能够有效解决线程间的协作问题。</p>
<p>阻塞队列是一种线程安全的队列，它提供了以下核心功能：</p>
<ol>
<li><strong>阻塞操作</strong>：<ul>
<li><strong>队列为空时</strong>：消费者线程尝试从队列中获取元素时会被阻塞，直到队列中有可用元素。</li>
<li><strong>队列满时</strong>：生产者线程尝试向队列中添加元素时会被阻塞，直到队列中有可用空间。</li>
</ul>
</li>
<li><strong>线程安全</strong>：阻塞队列是线程安全的，多个线程可以并发地进行操作。</li>
<li><strong>边界性</strong>：阻塞队列可以是有界的（固定容量）或无界的（容量无限）</li>
</ol>
<p>阻塞队列，顾名思义，首先它是一个队列，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757e06b24483.webp" alt="image-20241210143211999"></p>
<ul>
<li><strong>当队列是空的，从队列中获取元素的操作将会被阻塞，直到其他线程往空的队列插入新的元素</strong></li>
<li><strong>当队列是满的，从队列中添加元素的操作将会被阻塞，直到其他线程从队列中移除一个或多<br>个元素或者完全清空，使队列变得空闲</strong></li>
</ul>
<p>常用的队列主要有以下两种</p>
<ul>
<li>先进先出(First In First Out，FIFO):先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。</li>
<li>后进先出(Last In First OUt, LIFO)：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件（栈）</li>
</ul>
<p> <strong>阻塞队列的优点</strong></p>
<ol>
<li><strong>线程安全</strong>：阻塞队列是线程安全的，无需手动加锁。</li>
<li><strong>简化并发编程</strong>：提供了阻塞和超时机制，简化了生产者-消费者模型的实现。</li>
<li><strong>高效协作</strong>：能够有效解决生产者和消费者之间的协作问题。</li>
<li><strong>灵活性</strong>：提供了多种实现类，适用于不同的场景。</li>
</ol>
<p> <strong>阻塞队列的缺点</strong></p>
<ol>
<li><strong>性能开销</strong>：阻塞队列的实现通常基于锁机制，可能会带来一定的性能开销。</li>
<li><strong>死锁风险</strong>：在复杂的并发场景中，可能会出现死锁问题。</li>
<li><strong>适用性有限</strong>：阻塞队列适用于生产者-消费者模型，但在其他场景中可能不够灵活。</li>
</ol>
<p><strong>阻塞队列的适用场景</strong></p>
<ol>
<li><strong>生产者-消费者模型</strong>：阻塞队列是实现生产者-消费者模型的理想工具。</li>
<li><strong>任务调度</strong>：在任务调度系统中，阻塞队列可以用于存储待执行的任务。</li>
<li><strong>缓存系统</strong>：在缓存系统中，阻塞队列可以用于存储缓存数据。</li>
<li><strong>消息队列</strong>：在消息队列系统中，阻塞队列可以用于存储消息。</li>
</ol>
<p><strong>阻塞队列与其他队列的对比</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">阻塞队列（Blocking Queue）</th>
<th align="left">普通队列（Queue）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>阻塞机制</strong></td>
<td align="left">支持阻塞和超时机制</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">生产者-消费者模型、任务调度等</td>
<td align="left">单线程场景</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">在多线程场景下性能较好</td>
<td align="left">在单线程场景下性能较好</td>
</tr>
</tbody></table>
<h3 id="10-2、阻塞队列的使用示例"><a href="#10-2、阻塞队列的使用示例" class="headerlink" title="10.2、阻塞队列的使用示例"></a>10.2、<strong>阻塞队列的使用示例</strong></h3><p>以下是一个使用 <code>ArrayBlockingQueue</code> 的简单示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建一个容量为 3 的阻塞队列</span></span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                queue.put(<span class="string">"Task 1"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Produced: Task 1"</span>);</span><br><span class="line">                queue.put(<span class="string">"Task 2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Produced: Task 2"</span>);</span><br><span class="line">                queue.put(<span class="string">"Task 3"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Produced: Task 3"</span>);</span><br><span class="line">                queue.put(<span class="string">"Task 4"</span>); <span class="comment">// 队列已满，阻塞</span></span><br><span class="line">                System.out.println(<span class="string">"Produced: Task 4"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟消费延迟</span></span><br><span class="line">                System.out.println(<span class="string">"Consumed: "</span> + queue.take());</span><br><span class="line">                System.out.println(<span class="string">"Consumed: "</span> + queue.take());</span><br><span class="line">                System.out.println(<span class="string">"Consumed: "</span> + queue.take());</span><br><span class="line">                System.out.println(<span class="string">"Consumed: "</span> + queue.take()); <span class="comment">// 队列为空，阻塞</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-3、BlockingQueue核心方法"><a href="#10-3、BlockingQueue核心方法" class="headerlink" title="10.3、BlockingQueue核心方法"></a>10.3、BlockingQueue核心方法</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757eac2a6eac.webp" alt="image-20241210151618241"></p>
<p><code>BlockingQueue</code> 是阻塞队列的核心接口，定义了阻塞队列的基本操作。它的主要方法包括：</p>
<ul>
<li><strong>插入元素</strong>：<ul>
<li><code>boolean add(E e)</code>：插入元素，如果队列已满则抛出异常。</li>
<li><code>boolean offer(E e)</code>：插入元素，如果队列已满则返回 <code>false</code>。</li>
<li><code>void put(E e) throws InterruptedException</code>：插入元素，如果队列已满则阻塞。</li>
<li><code>boolean offer(E e, long timeout, TimeUnit unit)</code>：插入元素，如果队列已满则等待指定时间。</li>
</ul>
</li>
<li><strong>移除元素</strong>：<ul>
<li><code>E remove()</code>：移除元素，如果队列为空则抛出异常。</li>
<li><code>E poll()</code>：移除元素，如果队列为空则返回 <code>null</code>。</li>
<li><code>E take() throws InterruptedException</code>：移除元素，如果队列为空则阻塞。</li>
<li><code>E poll(long timeout, TimeUnit unit)</code>：移除元素，如果队列为空则等待指定时间。</li>
</ul>
</li>
<li><strong>检查元素</strong>：<ul>
<li><code>E element()</code>：返回队列头部元素，如果队列为空则抛出异常。</li>
<li><code>E peek()</code>：返回队列头部元素，如果队列为空则返回 <code>null</code>。</li>
</ul>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一组</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.add("a"));</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.add("b"));</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.add("c"));</span></span><br><span class="line">    <span class="comment">////        System.out.println(queue.element());</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">////        System.out.println(queue.add("d")); // 超出容量，抛出异常 IllegalStateException</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.remove());</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.remove());</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.remove());</span></span><br><span class="line">    <span class="comment">////        System.out.println(queue.remove()); // 队列为空时，抛出异常 NoSuchElementException</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二组</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.offer("a"));</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.offer("b"));</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.offer("c"));</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.offer("d")); // 超出容量，返回 false</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.poll());</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.poll());</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.poll());</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.poll()); // 队列为空时，返回 null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三组</span></span><br><span class="line">    <span class="comment">//        queue.put("a");</span></span><br><span class="line">    <span class="comment">//        queue.put("b");</span></span><br><span class="line">    <span class="comment">//        queue.put("c");</span></span><br><span class="line">    <span class="comment">////        queue.put("d"); // 超出容量，阻塞</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.take());</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.take());</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.take());</span></span><br><span class="line">    <span class="comment">//        System.out.println(queue.take()); // 队列为空时，阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四组</span></span><br><span class="line">    System.out.println(queue.offer(<span class="string">"a"</span>));</span><br><span class="line">    System.out.println(queue.offer(<span class="string">"b"</span>));</span><br><span class="line">    System.out.println(queue.offer(<span class="string">"c"</span>));</span><br><span class="line">    <span class="comment">//        System.out.println(queue.offer("d",3L, TimeUnit.SECONDS)); // 超出容量，阻塞, 超时返回 false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll(<span class="number">3L</span>, TimeUnit.SECONDS)); <span class="comment">// 队列为空时，阻塞, 超时返回 null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-4、常见的BlockingQueue"><a href="#10-4、常见的BlockingQueue" class="headerlink" title="10.4、常见的BlockingQueue"></a>10.4、常见的BlockingQueue</h3><blockquote>
<p><strong>ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</strong></p>
</blockquote>
<h4 id="10-4-1、ArrayBlockingQueue（常用）"><a href="#10-4-1、ArrayBlockingQueue（常用）" class="headerlink" title="10.4.1、ArrayBlockingQueue（常用）"></a>10.4.1、ArrayBlockingQueue（常用）</h4><p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的<br>头部和尾部在数组中的位置。</p>
<p>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还<br>可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>基于数组的有界阻塞队列，容量固定。</strong></li>
<li><strong>支持公平性策略（FIFO）。</strong></li>
</ul>
<p><strong>一句话总结：由数组结构组成的有界阻塞队列。</strong></p>
<h4 id="10-4-2、LinkedBlockingQueue（常用）"><a href="#10-4-2、LinkedBlockingQueue（常用）" class="headerlink" title="10.4.2、LinkedBlockingQueue（常用）"></a>10.4.2、LinkedBlockingQueue（常用）</h4><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时(LinkedBlockingQueue可以通过构造函数指定该值)，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>基于链表的无界或固定容量的阻塞队列。</strong></li>
<li><strong>默认是无界的，但可以指定容量。</strong></li>
</ul>
<p><strong>一句话总结：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE)阻塞队列。</strong></p>
<h4 id="10-4-3、PriorityBlockingQueue"><a href="#10-4-3、PriorityBlockingQueue" class="headerlink" title="10.4.3、PriorityBlockingQueue"></a>10.4.3、PriorityBlockingQueue</h4><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定)，但需要注意的是PriorityBlockingQueue<strong>并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。</strong></p>
<p>因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度</strong>，否则时间一长，会最终耗尽所有的可用堆内存空间。</p>
<p>在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p>
<p><strong>特点:</strong></p>
<ul>
<li><strong>基于优先级的无界阻塞队列。</strong></li>
<li><strong>元素按照优先级排序。</strong></li>
</ul>
<p><strong>一句话总结：支持优先级排序的无界阻塞队列。</strong></p>
<h4 id="10-4-4、DelayQueue"><a href="#10-4-4、DelayQueue" class="headerlink" title="10.4.4、DelayQueue"></a>10.4.4、DelayQueue</h4><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>延迟队列，元素必须实现 <code>Delayed</code> 接口。</strong></li>
<li><strong>元素只有在延迟到期后才能被消费。</strong></li>
</ul>
<p><strong>一句话总结：使用优先级队列实现的延迟无界阻塞队列。</strong></p>
<h4 id="10-4-5、SynchronousQueue"><a href="#10-4-5、SynchronousQueue" class="headerlink" title="10.4.5、SynchronousQueue"></a>10.4.5、SynchronousQueue</h4><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p>
<p>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。</p>
<p>公平模式和非公平模式的区别：</p>
<ul>
<li>公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</li>
<li>非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>同步队列，容量为 0。</strong></li>
<li><strong>生产者和消费者必须配对出现。</strong></li>
</ul>
<p><strong>一句话总结：不存储元素的阻塞队列，也即单个元素的队列。</strong></p>
<h4 id="10-4-6、LinkedTransferQueue"><a href="#10-4-6、LinkedTransferQueue" class="headerlink" title="10.4.6、LinkedTransferQueue"></a>10.4.6、LinkedTransferQueue</h4><p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>
<p>LinkedTransferQueue采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为null)入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时<br>发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</p>
<p><strong>一句话总结：由链表组成的无界阻塞队列。</strong></p>
<h4 id="10-4-7、LinkedBlockingDeque"><a href="#10-4-7、LinkedBlockingDeque" class="headerlink" title="10.4.7、LinkedBlockingDeque"></a>10.4.7、LinkedBlockingDeque</h4><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。</p>
<p>对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况</p>
<ul>
<li>插入元素时：如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再讲该元素插入，该操作可以通过设置超时参数，超时后返回false表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出InterruptedException异常。</li>
<li>读取元素时：如果当前队列为空会阻塞直到队列不为空然后返回元素，同样可以通过设置超时参数\</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>基于链表的双端阻塞队列。</strong></li>
<li><strong>支持从两端插入和移除元素。</strong></li>
</ul>
<p><strong>一句话总结：由链表组成的双向阻塞队列</strong></p>
<h2 id="11、线程池（ThreadPool"><a href="#11、线程池（ThreadPool" class="headerlink" title="11、线程池（ThreadPool)"></a>11、线程池（ThreadPool)</h2><p><strong>线程池（Thread Pool）</strong> 是 Java 并发编程中的一个重要概念，位于 <code>java.util.concurrent</code> 包中。线程池通过预先创建一组线程并复用它们，避免了频繁创建和销毁线程的开销，从而提高了系统的性能和资源利用率。线程池广泛应用于服务器端编程、任务调度、并发处理等场景。</p>
<h3 id="11-1、-线程池的基本概念"><a href="#11-1、-线程池的基本概念" class="headerlink" title="11.1、 线程池的基本概念"></a>11.1、 <strong>线程池的基本概念</strong></h3><h4 id="11-1-1、-为什么要使用线程池？"><a href="#11-1-1、-为什么要使用线程池？" class="headerlink" title="11.1.1、 为什么要使用线程池？"></a>11.1.1、 <strong>为什么要使用线程池？</strong></h4><ul>
<li><strong>性能优化</strong>：创建和销毁线程是昂贵的操作，线程池通过复用线程减少了这些开销。</li>
<li><strong>资源管理</strong>：线程池可以限制线程的数量，避免系统资源被耗尽。</li>
<li><strong>任务调度</strong>：线程池可以管理和调度任务，确保任务的执行顺序和优先级。</li>
</ul>
<h4 id="11-1-2、-线程池的核心组件"><a href="#11-1-2、-线程池的核心组件" class="headerlink" title="11.1.2、 线程池的核心组件"></a>11.1.2、 <strong>线程池的核心组件</strong></h4><ol>
<li><strong>线程池管理器</strong>：负责创建和管理线程池。</li>
<li><strong>工作线程</strong>：线程池中的线程，负责执行任务。</li>
<li><strong>任务队列</strong>：用于存储待执行的任务。</li>
<li><strong>拒绝策略</strong>：当任务队列满且线程池无法处理更多任务时，拒绝策略决定如何处理新任务。</li>
</ol>
<h4 id="11-1-3、线程池的优缺点及使用场景"><a href="#11-1-3、线程池的优缺点及使用场景" class="headerlink" title="11.1.3、线程池的优缺点及使用场景"></a>11.1.3、<strong>线程池的优缺点及使用场景</strong></h4><p><strong>优点：</strong></p>
<ol>
<li><strong>性能优化</strong>：通过复用线程减少了创建和销毁线程的开销。</li>
<li><strong>资源管理</strong>：限制线程数量，避免系统资源被耗尽。</li>
<li><strong>任务调度</strong>：管理和调度任务，确保任务的执行顺序和优先级。</li>
<li><strong>灵活性</strong>：提供了多种参数和策略，适用于不同的场景。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>复杂性</strong>：线程池的配置和使用需要一定的经验，配置不当可能导致性能问题。</li>
<li><strong>死锁风险</strong>：在复杂的并发场景中，可能会出现死锁问题。</li>
<li><strong>适用性有限</strong>：线程池适用于任务执行时间较短的场景，对于长时间运行的任务可能不够灵活。</li>
</ol>
<p><strong>适用场景：</strong></p>
<ol>
<li><strong>服务器端编程</strong>：如 Web 服务器、数据库连接池等。</li>
<li><strong>任务调度</strong>：如定时任务、批处理任务等。</li>
<li><strong>并发处理</strong>：如多线程下载、并行计算等。</li>
<li><strong>异步编程</strong>：如异步任务处理、事件驱动编程等。</li>
</ol>
<h3 id="11-2、-线程池的接口和实现类"><a href="#11-2、-线程池的接口和实现类" class="headerlink" title="11.2、 线程池的接口和实现类"></a>11.2、 <strong>线程池的接口和实现类</strong></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757f7182e738.webp" alt="image-20241210160856756"></p>
<h4 id="11-2-1、-Executor-接口"><a href="#11-2-1、-Executor-接口" class="headerlink" title="11.2.1、 Executor 接口"></a>11.2.1、 <code>Executor</code> 接口</h4><p><code>Executor</code> 是线程池的核心接口，定义了任务提交的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="11-2-2、-ExecutorService-接口"><a href="#11-2-2、-ExecutorService-接口" class="headerlink" title="11.2.2、 ExecutorService 接口"></a>11.2.2、 <code>ExecutorService</code> 接口</h4><p><code>ExecutorService</code> 是 <code>Executor</code> 的扩展接口，提供了更丰富的功能，如任务提交、任务取消、线程池关闭等：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> {</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="11-2-3、-常见的实现类"><a href="#11-2-3、-常见的实现类" class="headerlink" title="11.2.3、 常见的实现类"></a>11.2.3、 <strong>常见的实现类</strong></h4><p>Java 提供了多种线程池的实现类，适用于不同的场景：</p>
<ol>
<li><code>ThreadPoolExecutor</code>：<ul>
<li>最常用的线程池实现类。</li>
<li>支持自定义线程池的参数，如核心线程数、最大线程数、任务队列、拒绝策略等。</li>
</ul>
</li>
<li><code>ScheduledThreadPoolExecutor</code>：<ul>
<li>支持定时和周期性任务的线程池。</li>
</ul>
</li>
<li><code>Executors</code> 工厂类**：<ul>
<li>提供了创建常见线程池的便捷方法，如：<ul>
<li><code>newFixedThreadPool(int nThreads)</code>：创建固定大小的线程池。</li>
<li><code>newCachedThreadPool()</code>：创建可缓存的线程池。</li>
<li><code>newSingleThreadExecutor()</code>：创建单线程的线程池。</li>
<li><code>newScheduledThreadPool(int corePoolSize)</code>：创建支持定时任务的线程池。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="11-3、线程池的工作原理"><a href="#11-3、线程池的工作原理" class="headerlink" title="11.3、线程池的工作原理"></a>11.3、<strong>线程池的工作原理</strong></h3><h4 id="11-3-1、线程池的生命周期"><a href="#11-3-1、线程池的生命周期" class="headerlink" title="11.3.1、线程池的生命周期"></a>11.3.1、<strong>线程池的生命周期</strong></h4><p>线程池的生命周期包括以下几个阶段：</p>
<ol>
<li><strong>创建</strong>：初始化线程池，创建核心线程。</li>
<li><strong>运行</strong>：线程池接收任务并分配给工作线程执行。</li>
<li><strong>关闭</strong>：调用 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法关闭线程池。</li>
<li><strong>终止</strong>：所有任务执行完毕，线程池中的线程被销毁。</li>
</ol>
<h4 id="11-3-2、任务的执行流程"><a href="#11-3-2、任务的执行流程" class="headerlink" title="11.3.2、任务的执行流程"></a>11.3.2、<strong>任务的执行流程</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757fee0d078b.webp" alt="img"></p>
<ol>
<li><strong>提交任务</strong>：通过 <code>execute()</code> 或 <code>submit()</code> 方法提交任务。</li>
<li><strong>任务分配</strong>：<ul>
<li>如果线程池中的线程数小于核心线程数，创建新线程执行任务。</li>
<li>如果线程池中的线程数已达到核心线程数，将任务放入任务队列。</li>
<li>如果任务队列已满且线程数小于最大线程数，创建新线程执行任务。</li>
<li>如果任务队列已满且线程数已达到最大线程数，执行拒绝策略。</li>
</ul>
</li>
<li><strong>任务执行</strong>：工作线程从任务队列中获取任务并执行。</li>
<li><strong>任务完成</strong>：任务执行完毕后，线程返回线程池等待下一个任务。</li>
</ol>
<h3 id="11-4、线程池的参数及自定义线程池"><a href="#11-4、线程池的参数及自定义线程池" class="headerlink" title="11.4、线程池的参数及自定义线程池"></a>11.4、<strong>线程池的参数及自定义线程池</strong></h3><h4 id="11-4-1、线程池的参数"><a href="#11-4-1、线程池的参数" class="headerlink" title="11.4.1、线程池的参数"></a>11.4.1、线程池的参数</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> {</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ThreadPoolExecutor</code> 提供了多个参数，用于自定义线程池的行为：</p>
<ol>
<li><code>corePoolSize</code>：核心线程数，线程池中始终保持的线程数。</li>
<li><code>maximumPoolSize</code>：最大线程数，线程池中允许的最大线程数。</li>
<li><code>keepAliveTime</code>：非核心线程的空闲时间，超过该时间后，非核心线程会被销毁。</li>
<li><code>unit</code>：<code>keepAliveTime</code> 的时间单位。</li>
<li><code>workQueue</code>：任务队列，用于存储待执行的任务。</li>
<li><code>threadFactory</code>：线程工厂，用于创建新线程。</li>
<li><code>rejectedExecutionHandler</code>：拒绝策略，用于处理无法执行的任务。</li>
</ol>
<h4 id="11-4-2、自定义线程池"><a href="#11-4-2、自定义线程池" class="headerlink" title="11.4.2、自定义线程池"></a>11.4.2、自定义线程池</h4><p>阿里巴巴开发手册要求不允许使用Executors创建线程，而是通过ThreadPoolExecutor创建自定义线程池</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/6757ff5f88b21.webp" alt="image-20241210164416488"></p>
<p>下面是一个简单的自定义线程池示例:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) {</span><br><span class="line">                threadPool.execute(() -&gt; {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 办理业务"</span>);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="11-5、线程池的拒绝策略"><a href="#11-5、线程池的拒绝策略" class="headerlink" title="11.5、线程池的拒绝策略"></a>11.5、<strong>线程池的拒绝策略</strong></h3><p>当任务队列满且线程池无法处理更多任务时，拒绝策略决定如何处理新任务。常见的拒绝策略包括：</p>
<ol>
<li><code>AbortPolicy</code>：默认策略，直接抛出 <code>RejectedExecutionException</code> 异常。</li>
<li><code>CallerRunsPolicy</code>：由提交任务的线程执行任务。</li>
<li><code>DiscardPolicy</code>：直接丢弃任务，不抛出异常。</li>
<li><code>DiscardOldestPolicy</code>：丢弃任务队列中最旧的任务，然后尝试重新提交新任务。</li>
</ol>
<h3 id="11-6、线程池的使用示例"><a href="#11-6、线程池的使用示例" class="headerlink" title="11.6、线程池的使用示例"></a>11.6、<strong>线程池的使用示例</strong></h3><p>以下是一个使用 <code>ThreadPoolExecutor</code> 创建自定义线程池的示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建自定义线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">4</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">10</span>, <span class="comment">// 非核心线程的空闲时间</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// 任务队列</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">            executor.execute(() -&gt; {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is executing task."</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>课程案例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="comment">// 第一种: 一池N线程</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种：一池一线程</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种: 一池可扩容线程</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) {</span><br><span class="line">            threadPool3.execute(() -&gt; {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 办理业务"</span>);</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool3.shutdown();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="12、分支合并框架（Fork-Join）"><a href="#12、分支合并框架（Fork-Join）" class="headerlink" title="12、分支合并框架（Fork/Join）"></a>12、分支合并框架（Fork/Join）</h2><h3 id="12-1、Fork-Join框架简介"><a href="#12-1、Fork-Join框架简介" class="headerlink" title="12.1、Fork/Join框架简介"></a>12.1、Fork/Join框架简介</h3><p><strong>Fork/Join 框架</strong> 是 Java 7 引入的一个并发编程框架，位于 <code>java.util.concurrent</code> 包中。它基于 <strong>分治算法（Divide and Conquer）</strong>，将一个大任务拆分为多个小任务，并行执行这些小任务，最后将结果合并。Fork/Join 框架特别适合处理递归和并行计算问题，如归并排序、快速排序、并行数组处理等。</p>
<h4 id="12-1-1、-分治算法"><a href="#12-1-1、-分治算法" class="headerlink" title="12.1.1、 分治算法"></a>12.1.1、 <strong>分治算法</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/10/675805672c39f.webp" alt="image-20241210171000245"></p>
<p>分治算法的核心思想是将一个大问题分解为多个小问题，分别解决这些小问题，然后将结果合并。Fork/Join 框架通过以下步骤实现分治算法：</p>
<ol>
<li><strong>Fork（拆分）</strong>：将大任务拆分为多个小任务。</li>
<li><strong>Join（合并）</strong>：等待所有小任务完成，并将结果合并。</li>
</ol>
<h4 id="12-1-2、工作窃取算法（Work-Stealing）"><a href="#12-1-2、工作窃取算法（Work-Stealing）" class="headerlink" title="12.1.2、工作窃取算法（Work-Stealing）"></a>12.1.2、<strong>工作窃取算法（Work-Stealing）</strong></h4><p>Fork/Join 框架使用 <strong>工作窃取算法</strong> 来提高任务的执行效率：</p>
<ul>
<li>每个线程维护一个双端队列（Deque），用于存储任务。</li>
<li>当一个线程的任务队列为空时，它会从其他线程的任务队列末尾“窃取”任务。</li>
<li>这种机制减少了线程的空闲时间，提高了资源利用率。</li>
</ul>
<h4 id="12-1-3、Fork-Join-框架的优缺点及适用场景"><a href="#12-1-3、Fork-Join-框架的优缺点及适用场景" class="headerlink" title="12.1.3、Fork/Join 框架的优缺点及适用场景"></a>12.1.3、Fork/Join 框架的优缺点及适用场景</h4><p><strong>优点：</strong></p>
<ol>
<li><strong>高效并行</strong>：基于分治算法和工作窃取算法，能够高效地并行处理任务。</li>
<li><strong>简化并发编程</strong>：提供了丰富的 API，简化了并发任务的编写和组合。</li>
<li><strong>资源管理</strong>：通过线程池管理线程，避免了频繁创建和销毁线程的开销。</li>
<li><strong>适用性广</strong>：适用于递归和并行计算问题，如排序、搜索、矩阵运算等。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>复杂性</strong>：API 较为丰富，初学者可能需要一定时间熟悉。</li>
<li><strong>性能开销</strong>：相比于简单的线程池，Fork/Join 框架的实现较为复杂，可能会带来一定的性能开销。</li>
<li><strong>适用性有限</strong>：适用于递归和并行计算问题，但在简单的场景中可能显得过于复杂。</li>
</ol>
<p><strong>适用场景：</strong></p>
<ol>
<li><strong>递归问题</strong>：如归并排序、快速排序、树的遍历等。</li>
<li><strong>并行计算</strong>：如矩阵运算、图像处理、数据分析等。</li>
<li><strong>大规模数据处理</strong>：如大数据集的排序、搜索、聚合等。</li>
<li><strong>任务拆分</strong>：如任务调度、批处理任务等。</li>
</ol>
<h3 id="12-2、Fork-Join-框架的核心组件"><a href="#12-2、Fork-Join-框架的核心组件" class="headerlink" title="12.2、Fork/Join 框架的核心组件"></a>12.2、<strong>Fork/Join 框架的核心组件</strong></h3><h4 id="12-2-1、ForkJoinPool"><a href="#12-2-1、ForkJoinPool" class="headerlink" title="12.2.1、ForkJoinPool"></a>12.2.1、<code>ForkJoinPool</code></h4><p><code>ForkJoinPool</code> 是 Fork/Join 框架的核心类，它是一个特殊的线程池，专门用于执行 <code>ForkJoinTask</code>。</p>
<ul>
<li><p>创建 <code>ForkJoinPool</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>提交任务</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.submit(task);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="12-2-2、ForkJoinTask"><a href="#12-2-2、ForkJoinTask" class="headerlink" title="12.2.2、ForkJoinTask"></a>12.2.2、<code>ForkJoinTask</code></h4><p><code>ForkJoinTask</code> 是 Fork/Join 框架的任务抽象类，表示一个可以被拆分和执行的任务。它有两个主要的子类：</p>
<ol>
<li><code>RecursiveAction</code>：<ul>
<li>表示没有返回值的任务。</li>
<li>适用于不需要返回结果的场景，如文件处理、数据清洗等。</li>
</ul>
</li>
<li><code>RecursiveTask</code>：<ul>
<li>表示有返回值的任务。</li>
<li>适用于需要返回结果的场景，如并行计算、排序等。</li>
</ul>
</li>
</ol>
<h3 id="12-3、Fork-Join-框架的工作原理"><a href="#12-3、Fork-Join-框架的工作原理" class="headerlink" title="12.3、Fork/Join 框架的工作原理"></a>12.3、<strong>Fork/Join 框架的工作原理</strong></h3><h4 id="12-3-1、任务拆分"><a href="#12-3-1、任务拆分" class="headerlink" title="12.3.1、任务拆分"></a>12.3.1、<strong>任务拆分</strong></h4><ul>
<li>任务通过 <code>fork()</code> 方法拆分为多个子任务。</li>
<li>子任务会被放入当前线程的任务队列中，或者被其他线程窃取。</li>
</ul>
<h4 id="12-3-2、任务执行"><a href="#12-3-2、任务执行" class="headerlink" title="12.3.2、任务执行"></a>12.3.2、<strong>任务执行</strong></h4><ul>
<li>每个线程从自己的任务队列中获取任务并执行。</li>
<li>如果任务队列为空，线程会从其他线程的任务队列末尾窃取任务。</li>
</ul>
<h4 id="12-3-3、任务合并"><a href="#12-3-3、任务合并" class="headerlink" title="12.3.3、任务合并"></a>12.3.3、<strong>任务合并</strong></h4><ul>
<li>任务通过 <code>join()</code> 方法等待子任务完成，并将结果合并。</li>
<li>最终结果会被返回给调用者。</li>
</ul>
<h3 id="12-4、Fork-Join-框架的使用示例"><a href="#12-4、Fork-Join-框架的使用示例" class="headerlink" title="12.4、Fork/Join 框架的使用示例"></a>12.4、<strong>Fork/Join 框架的使用示例</strong></h3><h4 id="12-4-1、课程案例"><a href="#12-4-1、课程案例" class="headerlink" title="12.4.1、课程案例"></a>12.4.1、课程案例</h4><p>要求：计算 1+2+3+4+…+100，计算时两个相邻的数值不能超过10</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="comment">// 拆分差值不能超过10</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin; <span class="comment">// 拆分的开始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end; <span class="comment">// 拆分的结束值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result; <span class="comment">// 结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分和合并</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 两个数值相加是否大于10</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin &lt;= VALUE) {</span><br><span class="line">            <span class="comment">//相加操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= end; i++) {</span><br><span class="line">                result += i;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {<span class="comment">// 进一步拆分</span></span><br><span class="line">            <span class="comment">// 获取中间值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 拆分左边</span></span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin, middle);</span><br><span class="line">            <span class="comment">// 拆分右边</span></span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 合并</span></span><br><span class="line">            t1.fork();</span><br><span class="line">            t2.fork();</span><br><span class="line">            <span class="comment">// 合并结果</span></span><br><span class="line">            result = t1.join() + t2.join();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 创建分支合并池对象</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = pool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最终合并后的结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinTask.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭分支合并池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="12-4-2、计算数组元素的和"><a href="#12-4-2、计算数组元素的和" class="headerlink" title="12.4.2、计算数组元素的和"></a>12.4.2、<strong>计算数组元素的和</strong></h4><p>以下是一个使用 Fork/Join 框架计算数组元素和的示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建 ForkJoinPool</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组</span></span><br><span class="line">        <span class="type">int</span>[] array = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建任务</span></span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务并获取结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        System.out.println(<span class="string">"Sum of array elements: "</span> + result);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 RecursiveTask</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 任务拆分的阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SumTask</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如果任务足够小，直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) {</span><br><span class="line">                sum += array[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 拆分任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, start, mid);</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, mid, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并结果</span></span><br><span class="line">            <span class="keyword">return</span> leftTask.join() + rightTask.join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="12-4-3、归并排序"><a href="#12-4-3、归并排序" class="headerlink" title="12.4.3、归并排序"></a>12.4.3、<strong>归并排序</strong></h4><p>以下是一个使用 Fork/Join 框架实现归并排序的示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建 ForkJoinPool</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组</span></span><br><span class="line">        <span class="type">int</span>[] array = {<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建任务</span></span><br><span class="line">        <span class="type">MergeSortTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MergeSortTask</span>(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        pool.invoke(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出排序结果</span></span><br><span class="line">        System.out.println(<span class="string">"Sorted array: "</span> + Arrays.toString(array));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 RecursiveAction</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergeSortTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 任务拆分的阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MergeSortTask</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如果任务足够小，直接排序</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) {</span><br><span class="line">            Arrays.sort(array, start, end + <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 拆分任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">MergeSortTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MergeSortTask</span>(array, start, mid);</span><br><span class="line">            <span class="type">MergeSortTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MergeSortTask</span>(array, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待子任务完成</span></span><br><span class="line">            leftTask.join();</span><br><span class="line">            rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并结果</span></span><br><span class="line">            merge(array, start, mid, end);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) {</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[j]) {</span><br><span class="line">                temp[k++] = array[i++];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) {</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= end) {</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, array, start, temp.length);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="13、异步回调（CompletableFuture）"><a href="#13、异步回调（CompletableFuture）" class="headerlink" title="13、异步回调（CompletableFuture）"></a>13、异步回调（CompletableFuture）</h2><p><code>CompletableFuture</code> 是 Java 8 引入的一个强大的异步编程工具，位于 <code>java.util.concurrent</code> 包中。它是 <code>Future</code> 接口的实现类，提供了更丰富的功能，支持链式调用、组合任务、异常处理等，能够更方便地处理异步任务。</p>
<h3 id="13-1、-CompletableFuture-的基本概念"><a href="#13-1、-CompletableFuture-的基本概念" class="headerlink" title="13.1、 CompletableFuture 的基本概念"></a>13.1、 <code>CompletableFuture</code> 的基本概念</h3><h4 id="13-1-1、什么是-CompletableFuture？"><a href="#13-1-1、什么是-CompletableFuture？" class="headerlink" title="13.1.1、什么是 CompletableFuture？"></a>13.1.1、<strong>什么是 <code>CompletableFuture</code>？</strong></h4><ul>
<li><code>CompletableFuture</code> 是一个可完成的 <code>Future</code>，它不仅表示一个异步计算的结果，还允许你显式地完成它（通过设置结果或异常）。</li>
<li>它支持链式调用，可以将多个异步任务串联起来，形成一个任务链。</li>
<li>它提供了丰富的 API，用于处理任务的完成、组合、转换和异常处理。</li>
</ul>
<h4 id="13-1-2、CompletableFuture-的优缺点及适用场景"><a href="#13-1-2、CompletableFuture-的优缺点及适用场景" class="headerlink" title="13.1.2、CompletableFuture 的优缺点及适用场景"></a>13.1.2、<code>CompletableFuture</code> 的优缺点及适用场景</h4><p><strong>优点：</strong></p>
<ol>
<li><strong>简化异步编程</strong>：提供了丰富的 API，简化了异步任务的编写和组合。</li>
<li><strong>非阻塞操作</strong>：支持非阻塞的链式调用，避免了传统 <code>Future</code> 的阻塞问题。</li>
<li><strong>任务组合</strong>：支持任务之间的组合和依赖关系，能够更灵活地处理复杂的异步任务。</li>
<li><strong>异常处理</strong>：提供了专门的 API 处理异常，简化了异常处理的逻辑。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>复杂性</strong>：API 较为丰富，初学者可能需要一定时间熟悉。</li>
<li><strong>性能开销</strong>：相比于简单的线程池，<code>CompletableFuture</code> 的实现较为复杂，可能会带来一定的性能开销。</li>
<li><strong>适用性有限</strong>：适用于复杂的异步任务处理，但在简单的场景中可能显得过于复杂。</li>
</ol>
<p><strong>适用场景：</strong></p>
<ol>
<li><strong>异步任务处理</strong>：如网络请求、数据库查询等。</li>
<li><strong>任务组合</strong>：如多个异步任务的依赖关系处理。</li>
<li><strong>事件驱动编程</strong>：如响应式编程、事件处理等。</li>
<li><strong>并发处理</strong>：如并行计算、批处理任务等。</li>
</ol>
<h4 id="13-1-3、与传统-Future-的区别"><a href="#13-1-3、与传统-Future-的区别" class="headerlink" title="13.1.3、与传统 Future 的区别"></a>13.1.3、<strong>与传统 <code>Future</code> 的区别</strong></h4><table>
<thead>
<tr>
<th>特性</th>
<th><code>Future</code></th>
<th><code>CompletableFuture</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>异步任务</strong></td>
<td>只能通过 <code>get()</code> 获取结果，阻塞线程</td>
<td>支持非阻塞的链式调用和组合任务</td>
</tr>
<tr>
<td><strong>任务完成</strong></td>
<td>无法手动完成任务</td>
<td>可以手动完成任务（设置结果或异常）</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>不支持直接处理异常</td>
<td>提供专门的 API 处理异常</td>
</tr>
<tr>
<td><strong>任务组合</strong></td>
<td>不支持任务之间的组合</td>
<td>支持任务的组合和依赖关系</td>
</tr>
</tbody></table>
<h3 id="13-2、CompletableFuture-的核心功能"><a href="#13-2、CompletableFuture-的核心功能" class="headerlink" title="13.2、CompletableFuture 的核心功能"></a>13.2、<code>CompletableFuture</code> 的核心功能</h3><h4 id="13-2-1、创建-CompletableFuture"><a href="#13-2-1、创建-CompletableFuture" class="headerlink" title="13.2.1、创建 CompletableFuture"></a>13.2.1、创建 <code>CompletableFuture</code></h4><ul>
<li><p><strong>空任务</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"Task is running..."</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>带返回值的任务</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Result of the task"</span>;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="13-2-2、完成任务"><a href="#13-2-2、完成任务" class="headerlink" title="13.2.2、完成任务"></a>13.2.2、<strong>完成任务</strong></h4><ul>
<li><strong>手动完成任务</strong>：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">future.complete(<span class="string">"Result"</span>); <span class="comment">// 手动设置结果</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>手动抛出异常</strong>：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">future.completeExceptionally(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"Task failed"</span>));</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="13-2-3、获取结果"><a href="#13-2-3、获取结果" class="headerlink" title="13.2.3、获取结果"></a>13.2.3、<strong>获取结果</strong></h4><ul>
<li><p><strong>阻塞获取结果</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>非阻塞获取结果</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.getNow(<span class="string">"Default value"</span>); <span class="comment">// 如果未完成，返回默认值</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="13-2-4、链式调用"><a href="#13-2-4、链式调用" class="headerlink" title="13.2.4、链式调用"></a>13.2.4、<strong>链式调用</strong></h4><ul>
<li><p><strong>转换结果</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>)</span><br><span class="line">    .thenApply(result -&gt; result + <span class="string">" World"</span>);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>消费结果</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">future.thenAccept(result -&gt; System.out.println(result));</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>执行后续任务</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">future.thenRun(() -&gt; System.out.println(<span class="string">"Task completed"</span>));</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="13-2-5、任务组合"><a href="#13-2-5、任务组合" class="headerlink" title="13.2.5、任务组合"></a>13.2.5、<strong>任务组合</strong></h4><ul>
<li><strong>顺序组合</strong>：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"World"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; combined = future1.thenCombine(future2, (r1, r2) -&gt; r1 + <span class="string">" "</span> + r2);</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>并行组合</strong>：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"World"</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(future1, future2);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="13-2-6、异常处理"><a href="#13-2-6、异常处理" class="headerlink" title="13.2.6、异常处理"></a>13.2.6、<strong>异常处理</strong></h4><ul>
<li><strong>捕获异常</strong>：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">future.exceptionally(ex -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"Exception occurred: "</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Default value"</span>;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>处理异常和结果</strong>：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">future.handle((result, ex) -&gt; {</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"Exception occurred: "</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Default value"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="13-3、-CompletableFuture-的使用示例"><a href="#13-3、-CompletableFuture-的使用示例" class="headerlink" title="13.3、 CompletableFuture 的使用示例"></a>13.3、 <code>CompletableFuture</code> 的使用示例</h3><h4 id="13-3-1、课程案例"><a href="#13-3-1、课程案例" class="headerlink" title="13.3.1、课程案例"></a>13.3.1、课程案例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line">    <span class="comment">// 异步调用，无返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">        <span class="comment">// 执行异步任务</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" runAsync"</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    future.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调用，有返回值</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">        <span class="comment">// 执行异步任务</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" supplyAsync"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    future2.whenComplete((t, u) -&gt; {</span><br><span class="line">        <span class="comment">// 处理异步任务的结果</span></span><br><span class="line">        System.out.println(<span class="string">"异步任务结果："</span> + t);</span><br><span class="line">        System.out.println(<span class="string">"异常信息："</span> + u);</span><br><span class="line">    }).exceptionally((e) -&gt; {</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        System.out.println(<span class="string">"异步任务异常："</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="13-3-2、简单异步任务"><a href="#13-3-2、简单异步任务" class="headerlink" title="13.3.2、简单异步任务"></a>13.3.2、<strong>简单异步任务</strong></h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建一个异步任务</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Result of the task"</span>;</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        future.thenAccept(result -&gt; System.out.println(<span class="string">"Result: "</span> + result));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止主线程退出</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="13-3-3、任务组合"><a href="#13-3-3、任务组合" class="headerlink" title="13.3.3、任务组合"></a>13.3.3、<strong>任务组合</strong></h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureCombineExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建两个异步任务</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"World"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组合任务</span></span><br><span class="line">        CompletableFuture&lt;String&gt; combined = future1.thenCombine(future2, (r1, r2) -&gt; r1 + <span class="string">" "</span> + r2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        combined.thenAccept(result -&gt; System.out.println(<span class="string">"Combined result: "</span> + result));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止主线程退出</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</div></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">時光</div><div class="post-copyright__author_desc">心寄朗朗乾坤，胸怀真修之道。</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.shiguang666.eu.org/2024/12/09/f69225d19caa/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.shiguang666.eu.org/2024/12/09/f69225d19caa/')">【尚硅谷】JUC基础篇(2021版)</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.shiguang666.eu.org/2024/12/09/f69225d19caa/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=【尚硅谷】JUC基础篇(2021版)&amp;url=https://blog.shiguang666.eu.org/2024/12/09/f69225d19caa/&amp;pic=https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.shiguang666.eu.org" target="_blank">時光</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JAVA/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JAVA<span class="tagsPageCount">13</span></a><a class="post-meta__box__tags" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>尚硅谷<span class="tagsPageCount">42</span></a><a class="post-meta__box__tags" href="/tags/JUC/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JUC<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img.shiguangdev.cn/i/2024/12/13/675c5996649aa.webp" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/05/93840bcedc2c/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【尚硅谷】SpringCloud-微服务架构编码Base工程模块构建</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/09/68b16c939c95/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756ee980378a.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【智能协同云图库】2-项目初始化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/09/16/a32606420cb2/" title="【尚硅谷】JAVA基础-API"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-16</div><div class="title">【尚硅谷】JAVA基础-API</div></div></a></div><div><a href="/2024/09/17/56a6db38519d/" title="【尚硅谷】JAVA基础-IO流"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-17</div><div class="title">【尚硅谷】JAVA基础-IO流</div></div></a></div><div><a href="/2024/09/17/ef5bcf52c331/" title="【尚硅谷】JAVA基础-JDK新特性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-17</div><div class="title">【尚硅谷】JAVA基础-JDK新特性</div></div></a></div><div><a href="/2024/09/16/fadbedc8dc87/" title="【尚硅谷】JAVA基础-异常&amp;Object"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-16</div><div class="title">【尚硅谷】JAVA基础-异常&amp;Object</div></div></a></div><div><a href="/2024/09/16/277ab91cb5a0/" title="【尚硅谷】JAVA基础-多线程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-16</div><div class="title">【尚硅谷】JAVA基础-多线程</div></div></a></div><div><a href="/2024/09/17/0e6002b1fa7f/" title="【尚硅谷】JAVA基础-网络编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-17</div><div class="title">【尚硅谷】JAVA基础-网络编程</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display: none">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://emotion.acs.pw/emotion/Heo/送福.png" alt="status"></div></div><div class="author-info__description">代码成就万事基积沙镇海,<br>梦想永在凌云意意气风发。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">時光</h1><div class="author-info__desc">心寄朗朗乾坤，胸怀真修之道。</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/shiguang-coding" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content"><span>🌟欢迎光临時光的博客园子🌟</span><br> <span><a href="https://blog.shiguang666.eu.org"><b>blog.shiguang666.eu.org</b></a></span><br> <span><a target="_blank" rel="noopener" href="https://blog.shiguangdev.cn"><b>blog.shiguangdev.cn</b></a></span><br> <span><a target="_blank" rel="noopener" href="https://blog.shiguang88.icu"><b>blog.shiguang88.icu</b></a></span><br> <span>🤔 如有问题欢迎评论区交流！</span><br> <span>📧 如需联系我：<a href="mailto:an_shiguang@163.com"><b>发送邮件🚀</b></a></span> <div id="welcome-info"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E5%BF%85%E5%A4%87%E6%8A%80%E6%9C%AF%E4%B9%8BJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">大厂必备技术之JUC并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJUC"><span class="toc-number">1.1.</span> <span class="toc-text">1、什么是JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81JUC%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1、JUC简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2、进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3、线程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.3.1、线程状态枚举类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2%E3%80%81wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.3.2、wait和sleep的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4、并发与并行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1%E3%80%81%E4%B8%B2%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.4.1、串行模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2%E3%80%81%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">1.4.2、并行模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3%E3%80%81%E5%B9%B6%E5%8F%91"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">1.4.3、并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4%E3%80%81%E5%B0%8F%E7%BB%93%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">1.4.4、小结（重点）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E3%80%81%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5、管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E3%80%81%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6、用户线程和守护线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">2、Lock接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81Synchronized"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1、Synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 Synchronized关键字回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2%E3%80%81%E4%BD%BF%E7%94%A8synchronized%E5%AE%9E%E7%8E%B0%E5%94%AE%E7%A5%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2、使用synchronized实现售票案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFLock"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2、什么是Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81ReentrantLock"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3、ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1%E3%80%81ReentrantLock%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1、ReentrantLock介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2%E3%80%81%E5%94%AE%E7%A5%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2、售票案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81ReadWriteLock"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4、ReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1%E3%80%81ReadWriteLock%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1、ReadWriteLock介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2%E3%80%81%E5%94%AE%E7%A5%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2、售票案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E3%80%81-%E5%B0%8F%E7%BB%93%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5、 小结（重点）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.</span> <span class="toc-text">3、线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1、线程间通信案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2、虚假唤醒问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81ReentrantLock%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3、ReentrantLock实现线程间通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%AE%9A%E5%88%B6%E5%8C%96%E9%80%9A%E4%BF%A1"><span class="toc-number">1.4.</span> <span class="toc-text">4、线程间定制化通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1、案例分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2、案例实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.5.</span> <span class="toc-text">5、集合的线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81ArrayList%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E6%BC%94%E7%A4%BA"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1、ArrayList集合线程不安全演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Vector"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">5.1.1、解决方案-Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Collections"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">5.1.2、解决方案-Collections</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-CopyOnWriteArrayList"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">5.1.3、解决方案-CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81HashSet%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E6%BC%94%E7%A4%BA"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2、HashSet集合线程不安全演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-CopyOnWriteArraySet"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1、解决方案-CopyOnWriteArraySet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81HashMap%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E6%BC%94%E7%A4%BA"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3、HashMap集合线程不安全演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Collections"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1、解决方案-Collections</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-ConcurrentHashMap"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2、解决方案-ConcurrentHashMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">6、多线程锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E9%94%81%E7%9A%848%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1、锁的8种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2、公平锁和非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%88Fair-Lock%EF%BC%89"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">6.2.1、公平锁（Fair Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%88Non-fair-Lock%EF%BC%89"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">6.2.2、非公平锁（Non-fair Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">6.2.3、总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Reentrant-Lock%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3、可重入锁（Reentrant Lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1%E3%80%81synchronized%E5%8F%AF%E9%87%8D%E7%94%A8%E9%94%81%EF%BC%88%E9%9A%90%E5%BC%8F%EF%BC%89"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">6.3.1、synchronized可重用锁（隐式）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2%E3%80%81Lock%E5%8F%AF%E9%87%8D%E7%94%A8%E9%94%81%EF%BC%88%E6%98%BE%E7%A4%BA%EF%BC%89"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">6.3.2、Lock可重用锁（显示）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E3%80%81%E6%AD%BB%E9%94%81%EF%BC%88Deadlock%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4、死锁（Deadlock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">6.4.1、死锁的示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">6.4.2、如何避免死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3%E3%80%81%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">6.4.3、如何检测死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.</span> <span class="toc-text">7、Callable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1、测试案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81Callable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9%E5%A6%82%E4%B8%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2、Callable接口的特点如下（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E3%80%81Callable-%E4%B8%8E-Runnable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3、Callable 与 Runnable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E3%80%81FutureTask%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4、FutureTask介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81JUC%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-number">1.8.</span> <span class="toc-text">8、JUC强大的辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81%E5%87%8F%E5%B0%91%E6%8A%80%E6%9C%AFCountDownLatch"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1、减少技术CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1%E3%80%81%E9%94%81%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">8.1.1、锁门案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E3%80%81%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8FCyclicBarrier"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2、循环栅栏CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1%E3%80%81%E5%8F%AC%E5%94%A4%E7%A5%9E%E9%BE%99%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">8.2.1、召唤神龙案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E3%80%81%E4%BF%A1%E5%8F%B7%E7%81%AFSemaphore"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3、信号灯Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1%E3%80%81%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">8.3.1、案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81ReentrantReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.9.</span> <span class="toc-text">9、ReentrantReadWriteLock读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1、乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88Pessimistic-Locking%EF%BC%89"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">9.1.1、悲观锁（Pessimistic Locking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88Optimistic-Locking%EF%BC%89"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">9.1.2、乐观锁（Optimistic Locking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">9.1.3、乐观锁与悲观锁的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B%EF%BC%88%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">9.1.4、乐观锁的实现示例（版本号机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-5%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B%EF%BC%88synchronized%EF%BC%89"><span class="toc-number">1.9.1.5.</span> <span class="toc-text">9.1.5、悲观锁的实现示例（synchronized）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-6%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.1.6.</span> <span class="toc-text">9.1.6、总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E3%80%81%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2、表锁和行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1%E3%80%81%E8%A1%A8%E9%94%81%EF%BC%88Table-Lock%EF%BC%89"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">9.2.1、表锁（Table Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2%E3%80%81%E8%A1%8C%E9%94%81%EF%BC%88Row-Lock%EF%BC%89"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">9.2.2、行锁（Row Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3%E3%80%81-%E8%A1%A8%E9%94%81%E4%B8%8E%E8%A1%8C%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">9.2.3、 表锁与行锁的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-4%E3%80%81-%E8%A1%A8%E9%94%81%E4%B8%8E%E8%A1%8C%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">9.2.4、 表锁与行锁的使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-5%E3%80%81-%E8%A1%A8%E9%94%81%E4%B8%8E%E8%A1%8C%E9%94%81%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.9.2.5.</span> <span class="toc-text">9.2.5、 表锁与行锁的实际应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-6%E3%80%81-%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.2.6.</span> <span class="toc-text">9.2.6、 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3、读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">9.3.1、读写锁的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">9.3.2、读写锁的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-3%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">9.3.3、读写锁的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.9.3.4.</span> <span class="toc-text">9.3.4、读写锁的使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-5%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.9.3.5.</span> <span class="toc-text">9.3.5、读写锁的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-6%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.9.3.6.</span> <span class="toc-text">9.3.6、读写锁的适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-7%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.9.3.7.</span> <span class="toc-text">9.3.7、读写锁的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-8%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E4%B8%8E%E5%85%B6%E4%BB%96%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.9.3.8.</span> <span class="toc-text">9.3.8、读写锁与其他锁的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-9%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-number">1.9.3.9.</span> <span class="toc-text">9.3.9、读写锁降级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-10%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E6%BC%94%E5%8F%98"><span class="toc-number">1.9.3.10.</span> <span class="toc-text">3.9.10、读写锁演变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88BlockingQueue%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">10、阻塞队列（BlockingQueue）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81BlockingQueue%E7%AE%80%E4%BB%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1、BlockingQueue简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2、阻塞队列的使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E3%80%81BlockingQueue%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.3.</span> <span class="toc-text">10.3、BlockingQueue核心方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84BlockingQueue"><span class="toc-number">1.10.4.</span> <span class="toc-text">10.4、常见的BlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1%E3%80%81ArrayBlockingQueue%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">10.4.1、ArrayBlockingQueue（常用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2%E3%80%81LinkedBlockingQueue%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">10.4.2、LinkedBlockingQueue（常用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-3%E3%80%81PriorityBlockingQueue"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">10.4.3、PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-4%E3%80%81DelayQueue"><span class="toc-number">1.10.4.4.</span> <span class="toc-text">10.4.4、DelayQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-5%E3%80%81SynchronousQueue"><span class="toc-number">1.10.4.5.</span> <span class="toc-text">10.4.5、SynchronousQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-6%E3%80%81LinkedTransferQueue"><span class="toc-number">1.10.4.6.</span> <span class="toc-text">10.4.6、LinkedTransferQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-7%E3%80%81LinkedBlockingDeque"><span class="toc-number">1.10.4.7.</span> <span class="toc-text">10.4.7、LinkedBlockingDeque</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88ThreadPool"><span class="toc-number">1.11.</span> <span class="toc-text">11、线程池（ThreadPool)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%E3%80%81-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.11.1.</span> <span class="toc-text">11.1、 线程池的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">11.1.1、 为什么要使用线程池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2%E3%80%81-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">11.1.2、 线程池的核心组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-3%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">11.1.3、线程池的优缺点及使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2%E3%80%81-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.11.2.</span> <span class="toc-text">11.2、 线程池的接口和实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1%E3%80%81-Executor-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">11.2.1、 Executor 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-2%E3%80%81-ExecutorService-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">11.2.2、 ExecutorService 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-3%E3%80%81-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">11.2.3、 常见的实现类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.11.3.</span> <span class="toc-text">11.3、线程池的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">11.3.1、线程池的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">11.3.2、任务的执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.11.4.</span> <span class="toc-text">11.4、线程池的参数及自定义线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">11.4.1、线程池的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">11.4.2、自定义线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">1.11.5.</span> <span class="toc-text">11.5、线程池的拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.11.6.</span> <span class="toc-text">11.6、线程池的使用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E6%A1%86%E6%9E%B6%EF%BC%88Fork-Join%EF%BC%89"><span class="toc-number">1.12.</span> <span class="toc-text">12、分支合并框架（Fork/Join）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%E3%80%81Fork-Join%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">1.12.1.</span> <span class="toc-text">12.1、Fork/Join框架简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-1%E3%80%81-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">12.1.1、 分治算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-2%E3%80%81%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95%EF%BC%88Work-Stealing%EF%BC%89"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">12.1.2、工作窃取算法（Work-Stealing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-3%E3%80%81Fork-Join-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">12.1.3、Fork/Join 框架的优缺点及适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2%E3%80%81Fork-Join-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.12.2.</span> <span class="toc-text">12.2、Fork/Join 框架的核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-1%E3%80%81ForkJoinPool"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">12.2.1、ForkJoinPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-2%E3%80%81ForkJoinTask"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">12.2.2、ForkJoinTask</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3%E3%80%81Fork-Join-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.12.3.</span> <span class="toc-text">12.3、Fork/Join 框架的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1%E3%80%81%E4%BB%BB%E5%8A%A1%E6%8B%86%E5%88%86"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">12.3.1、任务拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2%E3%80%81%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">12.3.2、任务执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-3%E3%80%81%E4%BB%BB%E5%8A%A1%E5%90%88%E5%B9%B6"><span class="toc-number">1.12.3.3.</span> <span class="toc-text">12.3.3、任务合并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4%E3%80%81Fork-Join-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.12.4.</span> <span class="toc-text">12.4、Fork/Join 框架的使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1%E3%80%81%E8%AF%BE%E7%A8%8B%E6%A1%88%E4%BE%8B"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">12.4.1、课程案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-2%E3%80%81%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C"><span class="toc-number">1.12.4.2.</span> <span class="toc-text">12.4.2、计算数组元素的和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-3%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.12.4.3.</span> <span class="toc-text">12.4.3、归并排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%EF%BC%88CompletableFuture%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">13、异步回调（CompletableFuture）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1%E3%80%81-CompletableFuture-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.13.1.</span> <span class="toc-text">13.1、 CompletableFuture 的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-CompletableFuture%EF%BC%9F"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">13.1.1、什么是 CompletableFuture？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2%E3%80%81CompletableFuture-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">13.1.2、CompletableFuture 的优缺点及适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-3%E3%80%81%E4%B8%8E%E4%BC%A0%E7%BB%9F-Future-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.1.3.</span> <span class="toc-text">13.1.3、与传统 Future 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2%E3%80%81CompletableFuture-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">1.13.2.</span> <span class="toc-text">13.2、CompletableFuture 的核心功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1%E3%80%81%E5%88%9B%E5%BB%BA-CompletableFuture"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">13.2.1、创建 CompletableFuture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2%E3%80%81%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">13.2.2、完成任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-3%E3%80%81%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C"><span class="toc-number">1.13.2.3.</span> <span class="toc-text">13.2.3、获取结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-4%E3%80%81%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">1.13.2.4.</span> <span class="toc-text">13.2.4、链式调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-5%E3%80%81%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88"><span class="toc-number">1.13.2.5.</span> <span class="toc-text">13.2.5、任务组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-6%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.13.2.6.</span> <span class="toc-text">13.2.6、异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3%E3%80%81-CompletableFuture-%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.13.3.</span> <span class="toc-text">13.3、 CompletableFuture 的使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-1%E3%80%81%E8%AF%BE%E7%A8%8B%E6%A1%88%E4%BE%8B"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">13.3.1、课程案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-2%E3%80%81%E7%AE%80%E5%8D%95%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.13.3.2.</span> <span class="toc-text">13.3.2、简单异步任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-3%E3%80%81%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88"><span class="toc-number">1.13.3.3.</span> <span class="toc-text">13.3.3、任务组合</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/13/2ec3ab3954b3/" title="通过SSH密钥连接Linux"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/13/675c5996649aa.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="通过SSH密钥连接Linux"></a><div class="content"><a class="title" href="/2024/12/13/2ec3ab3954b3/" title="通过SSH密钥连接Linux">通过SSH密钥连接Linux</a><time datetime="2024-12-13T15:37:00.000Z" title="发表于 2024-12-13 23:37:00">2024-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/13/0616411766f4/" title="【Hexo】一键部署至远程服务器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/13/675c59eff34f4.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Hexo】一键部署至远程服务器"></a><div class="content"><a class="title" href="/2024/12/13/0616411766f4/" title="【Hexo】一键部署至远程服务器">【Hexo】一键部署至远程服务器</a><time datetime="2024-12-13T13:35:49.000Z" title="发表于 2024-12-13 21:35:49">2024-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/12/60bae9f9d9cc/" title="【尚硅谷】JVM-类的加载篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【尚硅谷】JVM-类的加载篇"></a><div class="content"><a class="title" href="/2024/12/12/60bae9f9d9cc/" title="【尚硅谷】JVM-类的加载篇">【尚硅谷】JVM-类的加载篇</a><time datetime="2024-12-12T04:02:59.000Z" title="发表于 2024-12-12 12:02:59">2024-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/11/0a6035f3745c/" title="【尚硅谷】JVM-字节码篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【尚硅谷】JVM-字节码篇"></a><div class="content"><a class="title" href="/2024/12/11/0a6035f3745c/" title="【尚硅谷】JVM-字节码篇">【尚硅谷】JVM-字节码篇</a><time datetime="2024-12-11T00:33:29.000Z" title="发表于 2024-12-11 08:33:29">2024-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/09/68b16c939c95/" title="【智能协同云图库】2-项目初始化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/09/6756ee980378a.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【智能协同云图库】2-项目初始化"></a><div class="content"><a class="title" href="/2024/12/09/68b16c939c95/" title="【智能协同云图库】2-项目初始化">【智能协同云图库】2-项目初始化</a><time datetime="2024-12-09T14:12:44.000Z" title="发表于 2024-12-09 22:12:44">2024-12-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/shiguang-coding" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" href="mailto:an_shiguang@163.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" size="50px"><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html">开往</a><a class="footer-item" title="异次元之旅" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on">异次元之旅</a><a class="footer-item" title="列表导航" target="_blank" rel="noopener" href="https://zhblogs.ohyee.cc/">列表导航</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a></div></div><div class="footer-group"><div class="footer-title">文章</div><div class="footer-links"><a class="footer-item" title="归档" href="/archives/">归档</a><a class="footer-item" title="分类" href="/categories/">分类</a><a class="footer-item" title="标签" href="/tags/">标签</a><a class="footer-item" title="RSS" href="/tom.xml">RSS</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="留言板" href="/comment/">留言板</a><a class="footer-item" title="关于我" href="/about/">关于我</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"></a><a class="github-badge" target="_blank" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=blog.shiguangdev.cn" style="margin-inline:5px" data-title="萌ICP备20246006号" title="萌ICP备20246006号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/%E8%90%8Cicp%E5%A4%87-20246006%E5%8F%B7-FF1485" alt="萌ICP备20246006号"></a><a class="github-badge" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">©2023 - 2024 By <a class="footer-bar-link" href="/" title="時光" target="_blank">時光</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = []
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://img.shiguangdev.cn/" title="图床">图床</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="豫ICP备2024070732号">豫ICP备2024070732号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">254</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">191</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">16</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.shiguang666.eu.org" title="時光主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光主页"><span class="back-menu-item-text">時光主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://nav.shiguang666.eu.org" title="時光导航站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光导航站"><span class="back-menu-item-text">時光导航站</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://game.shiguang666.eu.org" title="怀旧游戏机"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="怀旧游戏机"><span class="back-menu-item-text">怀旧游戏机</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://games.shiguang666.eu.org" title="在线小游戏"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="在线小游戏"><span class="back-menu-item-text">在线小游戏</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">后台管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://img.shiguangdev.cn/" title="時光图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/favicon.ico" alt="時光图床"><span class="back-menu-item-text">時光图床</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.shiguang666.eu.org/" title="Hexo管理面板"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://qexo.shiguang666.eu.org/favicon.ico" alt="Hexo管理面板"><span class="back-menu-item-text">Hexo管理面板</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随机</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/news/"><i class="fa fa-calendar faa-tada"></i><span> 早报亭</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=10051718332&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/xjj/"><i class="fa fa-rocket faa-tada"></i><span> 养生堂</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/flink/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comment/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>9</sup></a><a href="/tags/Alist/" style="font-size: 0.88rem;">Alist<sup>3</sup></a><a href="/tags/CentOs/" style="font-size: 0.88rem;">CentOs<sup>1</sup></a><a href="/tags/ChatGPT/" style="font-size: 0.88rem;">ChatGPT<sup>13</sup></a><a href="/tags/ChatGPt/" style="font-size: 0.88rem;">ChatGPt<sup>1</sup></a><a href="/tags/Chrome/" style="font-size: 0.88rem;">Chrome<sup>1</sup></a><a href="/tags/CloudFlare/" style="font-size: 0.88rem;">CloudFlare<sup>3</sup></a><a href="/tags/DNS/" style="font-size: 0.88rem;">DNS<sup>1</sup></a><a href="/tags/Ecology/" style="font-size: 0.88rem;">Ecology<sup>1</sup></a><a href="/tags/GPT-4o/" style="font-size: 0.88rem;">GPT-4o<sup>2</sup></a><a href="/tags/Gemini/" style="font-size: 0.88rem;">Gemini<sup>2</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>8</sup></a><a href="/tags/GitHub/" style="font-size: 0.88rem;">GitHub<sup>6</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>24</sup></a><a href="/tags/IDEA/" style="font-size: 0.88rem;">IDEA<sup>3</sup></a><a href="/tags/KeyBoardTestUtility/" style="font-size: 0.88rem;">KeyBoardTestUtility<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>4</sup></a><a href="/tags/Lombok/" style="font-size: 0.88rem;">Lombok<sup>1</sup></a><a href="/tags/Markdown/" style="font-size: 0.88rem;">Markdown<sup>2</sup></a><a href="/tags/MindManager/" style="font-size: 0.88rem;">MindManager<sup>1</sup></a><a href="/tags/Mysql/" style="font-size: 0.88rem;">Mysql<sup>2</sup></a><a href="/tags/Navicat/" style="font-size: 0.88rem;">Navicat<sup>1</sup></a><a href="/tags/Perplexity-AI/" style="font-size: 0.88rem;">Perplexity AI<sup>1</sup></a><a href="/tags/PicGo/" style="font-size: 0.88rem;">PicGo<sup>1</sup></a><a href="/tags/QQ/" style="font-size: 0.88rem;">QQ<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem;">SQL<sup>12</sup></a><a href="/tags/SSL/" style="font-size: 0.88rem;">SSL<sup>3</sup></a><a href="/tags/Sqlserver/" style="font-size: 0.88rem;">Sqlserver<sup>1</sup></a><a href="/tags/Typora/" style="font-size: 0.88rem;">Typora<sup>5</sup></a><a href="/tags/drawio/" style="font-size: 0.88rem;">drawio<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%90%A7%E5%B7%A5%E5%85%B7%E7%AE%B1/" style="font-size: 0.88rem;">图吧工具箱<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">图床<sup>7</sup></a><a href="/tags/%E5%BC%80%E6%BA%90%E5%88%86%E4%BA%AB/" style="font-size: 0.88rem;">开源分享<sup>6</sup></a><a href="/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/" style="font-size: 0.88rem;">搜索引擎<sup>2</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/" style="font-size: 0.88rem;">数据恢复<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">模板<sup>4</sup></a><a href="/tags/%E8%B8%A9%E5%9D%91/" style="font-size: 0.88rem;">踩坑<sup>6</sup></a><a href="/tags/%E9%B1%BC%E7%9A%AE/" style="font-size: 0.88rem;">鱼皮<sup>10</sup></a></div></div><hr></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="10051718332" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/my/m/music/playlist?id=10051718332&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async="" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("05/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 時光 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async="" src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.shiguangdev.eu.org',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.shiguangdev.eu.org',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async="" src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.shiguangdev.eu.org',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async="" data-pjax="" src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/custom/footer-animal.js" defer=""></script><script src="/api/card-welcome.js"></script><script id="click-heart" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><!-- hexo injector body_end start -->
  <script data-pjax="" src="/js/hexo_githubcalendar.js"></script>
  <script data-pjax="">
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://githubcalendarapi.shiguang666.eu.org/api?user=shiguang-coding";
            var git_color =['#ebedf0', '#a2f7af', '#6ce480', '#54ad63', '#469252', '#31753c', '#1f5f2a', '#13531f', '#084111', '#032b09', '#000000'];
            var git_user ="shiguang-coding";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar");
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end -->
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = '75439fb77e5551eacf54f0df75565616dcf2ad';
        let tianliGPT_postSelector = '#article-container';
        let tianliGPT_Title = '文章摘要';
        let tianliGPT_postURL = '/^https?://[^/]+/[0-9]{4}/[0-9]{2}/[0-9]{2}/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '1000';
        let tianliGPT_typingAnimate = true;
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: true,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "PostChat",
          userDesc: "如果你对网站的内容有任何疑问，可以来问我哦～",
          addButton: true,
          beginningText: "这篇文章介绍了"
        };
    </script>
    <script data-postchat_key="75439fb77e5551eacf54f0df75565616dcf2ad" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>
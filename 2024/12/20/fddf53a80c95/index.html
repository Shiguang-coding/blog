<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>【尚硅谷】JVM-运行时内存篇 | 時光</title><meta name="keywords" content="Java,尚硅谷,JVM"><meta name="author" content="時光"><meta name="copyright" content="時光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="【尚硅谷】JVM-运行时内存篇"><meta name="application-name" content="【尚硅谷】JVM-运行时内存篇"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="【尚硅谷】JVM-运行时内存篇"><meta property="og:url" content="https://blog.shiguang666.eu.org/2024/12/20/fddf53a80c95/index.html"><meta property="og:site_name" content="時光"><meta property="og:description" content="官方资料：      引用站外地址                                                        尚硅谷JVM精讲与GC调优教程（宋红康主讲，含jvm面试真题）             在线视频"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg"><meta property="article:author" content="時光"><meta property="article:tag" content="博客,時光,時光的博客,時光博客园子,实用博客,开源,共享"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg"><meta name="description" content="官方资料：      引用站外地址                                                        尚硅谷JVM精讲与GC调优教程（宋红康主讲，含jvm面试真题）             在线视频"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.shiguang666.eu.org/2024/12/20/fddf53a80c95/"><link rel="preconnect" href="//cdn.cbd.int"><meta name="google-site-verification" content="xxx"><meta name="baidu-site-verification" content="code-xxx"><meta name="msvalidate.01" content="xxx"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与各类博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.shiguangdev.eu.org',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://fcircle.shiguangdev.cn/"},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🌟 技术分享领航人","📚 终身学习倡导者","💡 创新思维启发源","📈 成长路径引路人","🚀 科技趋势探索者","🤖️ AI技术探索先锋","🌈 技术创新推动手","💬 社区互动活跃家","🛠️ 代码经验传授师","📢 知识传播倡导员"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":300,"languages":{"author":"作者: 時光","link":"链接: ","source":"来源: 時光","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '時光',
  title: '【尚硅谷】JVM-运行时内存篇',
  postAI: '',
  pageFillDescription: '1、说明, 2、程序计数器, 2.1、为什么需要它？, 2.2、案例, 2.3、基本特征, 2.4、两个问题, 2.4.1、PC寄存器存储字节码指令地址有什么用？, 2.4.2、PC寄存器为什么被设定为线程私有的？, 3、虚拟机栈, 3.1、概述, 3.1.1、如何理解栈管运行堆管存储？, 3.1.2、栈存在GC吗?, 3.1.3、可能抛出的异常？, 3.1.4、如何设置栈内存大小？, 3.2、栈的单位：栈帧（Stack Frame）, 3.2.1、方法和栈帧的关系？, 3.2.2、栈的FILO原理?, 3.3、栈桢内部结构, 3.3.1、局部变量表（local variables), 3.3.1.1、存在线程安全问题吗？, 3.3.1.2、关于Slot的理解, 3.3.1.3、Slot的重复利用举例？, 3.3.1.4、静态变量与局部变量的对比, 3.3.1.5、与GC Roots的关系, 3.3.2、操作数栈（Operand Stack）, 3.3.2.1、概念, 3.3.2.2、代码演示, 3.3.2.3、何为栈顶缓存技术？, 3.3.3、动态链接, 3.3.3.1、为什么需要常量池呢？, 3.3.3.2、方法的调用, 3.3.4、方法返回地址, 3.3.5、一些附加信息, 3.4、问题小结与拓展, 问题一：栈溢出的情况?, 问题二：调整栈大小就能保证不出现溢出吗?, 问题三：分配的栈内存越大越好吗?, 问题四：垃圾回收是否会涉及到虚拟机栈?, 问题五：方法中定义的局部变量是否线程安全?, 4、本地方法接口与本地方法栈, 4.1、什么是本地方法?, 4.2、为什么要使用Native Method？, 4.3、本地方法现状?, 4.4、本地方法栈, 5、堆, 5.1、核心概述, 5.1.1、对象都分配在堆上？, 5.2.2、所有的线程都共享堆？, 5.2、堆的内部结构, 5.3、如何设置堆内存大小？, 5.3.1、如何设置新生代与老年代比例？, 5.3.2、如何设置Eden、幸存者区比例？, 5.3.3、OOM举例, 5.3.4、参数设置小结, -Xms -Xmx, -Xmn, -XXNewRatio, -XXSurvivorRatio, -XXMaxTenuringThreshold, -XX+PrintGCDetails, -XXHandlePromotionFailure, -XX+PrintFlagsFinal, 5.4、对象分配金句, 5.4.1、过程剖析, 5.4.2、内存分配原则, 5.4.3、代码举例, 5.5、解释MinorGC、MajorGC、FullGC, 5.5.1、MinorGC触发机制, 5.5.2、MajorGC触发机制, 5.5.3、FullGC触发机制, 5.5.4、代码举例, 5.6、OOM如何解决, 5.7、堆空间分代思想, 5.5.5、快速分配策略：TLAB, 6、方法区, 6.1、栈、堆、方法区的关系, 6.2、方法区在哪里？, 6.3、方法区的理解, 6.4、HotSpot中方法区的演进, 6.5、方法区常用参数有哪些？, 6.6、方法区都存什么？, 6.6.1、类型信息, 6.6.2、域(Field)信息, 6.6.3、方法(Method)信息, 6.6.4、non-final的类变量, 6.6.5、运行时常量池, 6.6.5.1、关联：常量池, 6.6.5.2、为什么需要常量池？, 6.6.5.3、常量池都有什么？, 6.7、方法区使用举例, 6.8、永久代与元空间, 6.9、方法区是否存在GC？回收什么？, 6.10、内存结构小结, 7、直接内存, 7.1、概述, 7.2、非直接缓冲区vs直接缓冲区, 7.3、大小设置方式, 7.4、代码举例, 8、StringTable, 8.1、String的不可变性, 8.2、String的内存分配, 8.3、String的基本操作, 8.4、字符串拼接操作, 8.5、new String()问题, 8.6、intern()方法, 8.7、G1的String去重操作官方资料引用站外地址尚硅谷精讲与调优教程宋红康主讲含面试真题在线视频引用站外地址尚硅谷宋红康精讲与调优课程资料引用站外地址第篇运行时内存篇思维导图代码仓库引用站外地址引用站外地址说明面试题讲一下为什么要分为堆方法区等原理是什么智联的分区了解吗内存溢出发生在哪个位置亚信简述各个版本内存区域的变化猎聘的错误错误的错误蚂蚁金服不同的对于内存的划分方式和管理机制存在着部分差异结合虚拟机规范来探讨一下经典的内存布局面试题说一说的内存结构是什么样子的每个区域放什么各有什么特点快手搜狐内存模型有哪些龙湖地产的内存模型线程独有的放在哪里哪些是线程共享的哪些是线程独占的万达集团讲一下为什么要分为堆方法区等原理是什么小米搜狐讲讲运行时数据库区字节跳动的内存布局以及垃圾回收原理及过程讲一下京东你能画出内存结构图吗哪些内存结构与线程一一对应虚拟机定义了若干种程序运行期间会使用到的运行时数据区其中有一些会随着虚拟机启动而创建随着虚拟机退出而销毁另外一些则是与线程一一对应的这些与线程对应的数据区域会随着线程开始和结束而创建和销毁程序计数器面试题计数器如何记数京东物流为什么需要它为了保证程序在操作系统中理解为进程能够连续地执行下去必须具有某些手段来确定下一条指令的地址而程序计数器正是起到这种作用所以通常又称为指令计数器在程序开始执行前必须将它的起始地址即程序的一条指令所在的内存单元地址送入因此程序计数器的内容即是从内存提取的第一条指令的地址当执行指令时将自动修改的内容即每执行一条指令增加一个量这个量等于指令所含的字节数以便使其保持的总是将要执行的下一条指令的地址由于大多数指令都是按顺序来执行的所以修改的过程通常只是简单的对加当程序转移时转移指令执行的最终结果就是要改变的值此值就是转去的地址以此实现转移有些机器中也称为指令指针小结它是程序控制流的指示器分支循环跳转异常处理线程恢复等基础功能都需要依赖这个计数器来完成寄存器用来存储指向下一条指令的地址也是即将要执行的指令代码执行引擎的字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令为什么执行方法时是任何时间一个线程都只有一个方法在执行也就是所谓的当前方法程序计数器会存储当前线程正在执行的方法的指令地址本地方法是大多是通过语言实现并未编译成需要执行的字节码指令所以在计数器中当然是空案例对应的字节码字节码指令分析基本特征中的程序计数寄存器中的命名源于的寄存器寄存器存储指令相关的现场信息只有把数据装载到寄存器才能够运行这里并非是广义上所指的物理寄存器或许将其翻译为计数器或指令计数器会更加贴切也称为程序钩子并且也不容易引起一些不必要的误会中的寄存器是对物理寄存器的一种抽象模拟总结它是一块很小的内存空间几乎可以忽略不记也是运行速度最快的存储区域不会随着程序的运行需要更大的空间在规范中每个线程都有它自己的程序计数器是线程私有的生命周期与线程的生命周期保持一致它是唯一一个在虚拟机规范中没有规定任何情况的区域两个问题寄存器存储字节码指令地址有什么用因为需要不停的切换各个线程这时候切换回来以后就得知道接着从哪开始继续执行的字节码解释器就需要通过改变寄存器的值来明确下一条应该执行什么样的字节码指令寄存器为什么被设定为线程私有的我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法会不停地做任务切换这样必然导致经常中断或恢复如何保证分毫无差呢为了能够准确地记录各个线程正在执行的当前字节码指令地址最好的办法自然是为每一个线程都分配一个寄存器这样一来各个线程之间便可以进行独立计算从而不会出现相互干扰的情况虚拟机栈概述有不少开发人员一提到内存结构就会非常粗粒度地将中的内存区理解为仅有堆和栈虚拟机栈是什么虚拟机栈早期也叫栈每个线程在创建时都会创建一个虚拟机栈其内部保存一个个的栈帧对应着一次次的方法调用是线程私有的生命周期生命周期和线程一致特点栈是一种快速有效的分配存储方式访问速度仅次于程序计数器如何理解栈管运行堆管存储面试题堆和栈的区别谁的性能更高艾绒软件为什么要把堆和栈区分出来呢栈中不是也可以存储数据吗阿里解答思路角度一角度二栈堆执行效率角度三内存大小数据结构角度四栈管运行堆管存储作用主管程序的运行它保存方法的局部变量种基本数据类型对象的引用地址部分结果并参与方法的调用和返回局部变量成员变量或属性基本数据变量引用类型变量类数组接口即栈解决程序的运行问题即程序如何执行或者说如何处理数据堆解决的是数据存储的问题即数据怎么放放在哪儿栈存在吗不存在存在可能抛出的异常面试题什么情况下会发生栈内存溢出栈存在内存溢出吗京东解答思路局部数组过大当函数内部的数组过大时有可能导致堆栈溢出递归调用层次太多递归函数在运行时会执行压栈操作当压栈次数太多时也会导致堆栈溢出虚拟机规范允许栈的大小是动态的或者是固定不变的如果采用固定大小的虚拟机栈那每一个线程的虚拟机栈容量可以在线程创建的时候独立选定如果线程请求分配的栈容量超过虚拟机栈允许的最大容量虚拟机将会抛出一个异常如果虚拟机栈可以动态扩展并且在尝试扩展的时候无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈那虚拟机将会抛出个异常如何设置栈内存大小面试题中栈的大小通过什么参数来设置即一般默认为取决于操作系统栈的大小直接决定了函数调用的最大可达深度设置的栈空间值过大会导致系统可以用于创建线程的数量减少一般一个进程中通常有个线程默认值实践总结如何配置启动参数之前默认栈大小之后默认栈大小栈的单位栈帧面试题栈是如何运行的有哪些组成堆栈各放了什么东西新浪怎么理解栈堆堆中存什么栈中存什么阿里每个线程都有自己的栈栈中的数据都是以栈帧的格式存在方法和栈帧的关系在这个线程上正在执行的每个方法都各自对应一个栈帧栈帧是一个内存区块是一个数据集维系着方法执行过程中的各种数据信息在一条活动线程中一个时间点上只会有一个活动的栈帧即只有当前正在执行的方法的栈帧栈顶栈帧是有效的这个栈帧被称为当前栈帧与当前栈帧相对应的方法就是当前方法定义这个方法的类就是当前类如果在该方法中调用了其他方法对应的新的栈帧会被创建出来放在栈的顶端成为新的当前帧执行引擎运行的所有字节码指令只针对当前栈帧进行操作栈的原理直接对栈的操作只有两个每个方法执行伴随着进栈入栈压栈执行结束后的出栈工作遵循先进后出后进先出原则不同线程中所包含的栈帧是不允许存在相互引用的即不可能在一个栈帧之中引用另外一个线程的栈帧如果当前方法调用了其他方法方法返回之际当前栈帧会传回此方法的执行结果给前一个栈帧接着虚拟机会丢弃当前栈帧使得前一个栈帧重新成为当前栈帧方法有两种返回函数的方式一种是正常的函数返回使用指令另外一种是抛出异常不管使用哪种方式都会导致栈帧被弹出栈桢内部结构每个栈帧中存储着局部变量表操作数栈或表达式栈动态链接或指向运行时常量池的方法引用方法返回地址或方法正常退出或者异常退出的定义一些附加信息局部变量表局部变量表也被称之为局部变量数组或本地变量表定义为一个数字数组主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型种对象引用以及类型局部变量表所需的容量大小是在编译期确定下来的并保存在方法的属性的数据项中在方法运行期间是不会改变局部变量表的大小的方法嵌套调用的次数由栈的大小决定一般来说栈越大方法嵌套调用次数越多对一个函数而言它的参数和局部变量越多使得局部变量表膨胀它的栈帧就越大以满足方法调用所需传递的信息增大的需求进而函数调用就会占用更多的栈空间导致其嵌套调用次数就会减少局部变量表中的变量只在当前方法调用中有效在方法执行时虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程当方法调用结束后随着方法栈帧的销毁局部变量表也会随之销毁可以看到在文件的局部变量表中显示了每个局部变量的作用域范围所在槽位的索引列变量名列和数据类型表示型存在线程安全问题吗由于局部变量表是建立在线程的栈上是线程的私有数据因此不存在数据线程安全问题关于的理解参数值的存放总是在局部变量数组的为开始到数组长度的索引结束局部变量表最基本的存储单元是变量槽在局部变量表里位以内的类型只占用一个包括类型位的类型和占用两个在存储前被转换为也被转换为表示非表示和则占据两个会为局部变量表中的每一个都分配一个访问索引通过这个索引即可成功访问到局部变量表中指定的局部变量值当一个实例方法被调用的时候它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个上如果需要访问局部变量表中一个的局部变量值时只需要使用前一个索引即可比如访问或类型变量如果当前帧是由构造方法或者实例方法创建的那么该对象引用将会存放在为的处其余的参数按照参数表顺序继续排列的重复利用举例栈帧中的局部变量表中的槽位是可以重用的如果一个局部变量过了其作用域那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位从而达到节省资源的目的变量的位置复用了变量的局部变量表如下静态变量与局部变量的对比参数表分配完毕之后再根据方法体内定义的变量的顺序和作用域分配我们知道类变量表有两次初始化的机会第一次是在准备阶段执行系统初始化对类变量设置零值另一次则是在初始化阶段赋予程序员在代码中定义的初始值和类变量初始化不同的是局部变量表不存在系统初始化的过程这意味着一旦定义了局部变量则必须人为的初始化否则无法使用这样的代码是错误的没有赋值不能够使用与的关系局部变量表中的变量也是重要的垃圾回收根节点只要被局部变量表中直接或间接引用的对象都不会被回收操作数栈概念我们说虚拟机的解释引擎是基于栈的执行引擎其中的栈指的就是操作数栈每一个独立的栈帧中除了包含局部变量表以外还包含一个后进先出的操作数栈也可以称之为表达式栈操作数栈就是执行引擎的一个工作区当一个方法刚开始执行的时候一个新的栈帧也会随之被创建出来这个方法的操作数栈是空的每一个操作数栈都会拥有一个明确的栈深度用于存储数值其所需的最大深度在编译期就定义好了保存在方法的属性中为的值栈中的任何一个元素都可以是任意的数据类型的类型占用一个栈单位深度的类型占用两个栈单位深度操作数栈在方法执行过程中根据字节码指令并非采用访问索引的方式来进行数据访问的而是只能通过标准的入栈和出栈操作往栈中写入数据或提取数据来完成一次数据访问某些字节码指令将值压入操作数栈其余的字节码指令将操作数取出栈使用它们后再把结果压入栈比如执行复制交换求和等操作如果被调用的方法带有返回值的话其返回值将会被压入当前栈帧的操作数栈中并更新寄存器中下一条需要执行的字节码指令代码举例字节码指令信息操作数栈主要用于保存计算过程的中间结果同时作为计算过程中变量临时的存储空间操作数栈中元素的数据类型必须与字节码指令的序列严格匹配这由编译器在编译器期间进行验证同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证代码演示字节码分析何为栈顶缓存技术前面提过基于栈式架构的虚拟机所使用的零地址指令更加紧凑但完成一项操作的时候必然需要使用更多的入栈和出栈指令这同时也就意味着将需要更多的指令分派次数和内存读写次数由于操作数是存储在内存中的因此频繁地执行内存读写操作必然会影响执行速度为了解决这个问题的设计者们提出了栈顶缓存技术将栈顶元素全部缓存在物理的寄存器中以此降低对内存的读写次数提升执行引擎的执行效率动态链接动态链接或指向运行时常量池的方法引用每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接比如指令在源文件被编译到字节码文件中时所有的变量和方法引用都作为符号引用保存在文件的常量池里比如描述一个方法调用了另外的其他方法时就是通过常量池中指向方法的符号引用来表示的那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用举例为什么需要常量池呢常量池的作用就是为了提供一些符号和常量便于指令的识别方法的调用在中将符号引用转换为调用方法的直接引用与方法的绑定机制相关静态链接当一个字节码文件被装载进内部时如果被调用的目标方法在编译期可知且运行期保持不变时这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接动态链接如果被调用的方法在编译期无法被确定下来也就是说只能够在程序运行期将调用方法的符号引用转换为直接引用由于这种引用转换过程具备动态性因此也就被称之为动态链接对应的方法的绑定机制为早期绑定和晚期绑定绑定是一个字段方法或者类在符号引用被替换为直接引用的过程这仅仅发生一次早期绑定早期绑定就是指被调用的目标方法如果在编译期可知且运行期保持不变时即可将这个方法与所属的类型进行绑定这样一来由于明确了被调用的目标方法究竟是哪一个因此也就可以使用静态链接的方式将符号引用转换为直接引用晚期绑定如果被调用的方法在编译期无法被确定下来只能够在程序运行期根据实际的类型绑定相关的方法这种绑定方式也就被称之为晚期绑定虚方法与非虚方法随着高级语言的横空出世类似于一样的基于面向对象的编程语言如今越来越多尽管这类编程语言在语法风格上存在一定的差别但是它们彼此之间始终保持着一个共性那就是都支持封装继承和多态等面向对象特性既然这一类的编程语言具备多态特性那么自然也就具备早期绑定和晚期绑定两种绑定方式中任何一个普通的方法其实都具备虚函数的特征它们相当于语言中的虚函数中则需要使用关键字来显式定义如果在程序中不希望某个方法拥有虚函数的特征时则可以使用关键字来标记这个方法非虚方法如果方法在编译期就确定了具体的调用版本这个版本在运行时是不可变的这样的方法称为非虚方法静态方法私有方法方法实例构造器父类方法都是非虚方法其他方法称为虚方法子类对象的多态性的使用前提类的继承关系方法的重写在类加载的解析阶段就可以进行解析如下是非虚方法举例虚拟机中提供了以下几条方法调用指令普通调用指令调用静态方法解析阶段确定唯一方法版本调用方法私有及父类方法解析阶段确定唯一方法版本调用所有虚方法调用接口方法动态调用指令动态解析出需要调用的方法然后执行前四条指令固化在虚拟机内部方法的调用执行不可人为干预而指令则支持由用户确定方法版本其中指令和指令调用的方法称为非虚方法其余的修饰的除外称为虚方法关于指令字节码指令集一直比较稳定一直到中才增加了一个指令这是为了实现动态类型语言支持而做的一种改进但是在中并没有提供直接生成指令的方法需要借助这种底层字节码工具来产生指令直到的表达式的出现指令的生成在中才有了直接的生成方式中增加的动态语言类型支持的本质是对虚拟机规范的修改而不是对语言规则的修改这一块相对来讲比较复杂增加了虚拟机中的方法调用最直接的受益者就是运行在平台的动态语言的编译器动态类型语言和静态类型语言动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期满足前者就是静态类型语言反之是动态类型语言说的再直白一点就是静态类型语言是判断变量自身的类型信息动态类型语言是判断变量值的类型信息变量没有类型信息变量值才有类型信息这是动态语言的一个重要特征关于指令下午方法重写的本质介绍程序试图访问或修改一个属性或调用一个方法这个属性或方法你没有权限访问一般的这个会引起编译器异常这个错误如果发生在运行时就说明一个类发生了不兼容的改变找到操作数栈顶的第一个元素所执行的对象的实际类型记作如果在过程结束如果不通类型中找到与常量中的描述符合简单名称都相符的方法则进行访问权限校验如果通过则返回这个方法的直接引用查找过则返回异常否则按照继承关系从下往上依次对的各个父类进行第步的搜索和验证过程如果始终没有找到合适的方法则抛出异常虚方法表在面向对象的编程中会很频繁的使用到动态分派如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率因此为了提高性能采用在类的方法区建立一个虚方法表非虚方法不会出现在表中来实现使用索引表来代替查找每个类中都有一个虚方法表表中存放着各个方法的实际入口那么虚方法表什么时候被创建虚方法表会在类加载的链接阶段被创建并开始初始化类的变量初始值准备完成之后会把该类的方法表也初始化完毕举例举例虚方法表虚方法表虚方法表方法返回地址存放调用该方法的寄存器的值一个方法的结束有两种方式正常执行完成出现未处理的异常非正常退出无论通过哪种方式退出在方法退出后都返回到该方法被调用的位置方法正常退出时调用者的计数器的值作为返回地址即调用该方法的指令的下一条指令的地址而通过异常退出的返回地址是要通过异常表来确定栈帧中一般不会保存这部分信息当一个方法开始执行后只有两种方式可以退出这个方法执行引擎遇到任意一个方法返回的字节码指令会有返回值传递给上层的方法调用者简称正常完成出口一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定在字节码指令中返回指令包含当返回值是和类型时使用以及另外还有一个指令供声明为的方法实例初始化方法类和接口的初始化方法使用在方法执行的过程中遇到了异常并且这个异常没有在方法内进行处理也就是只要在本方法的异常表中没有搜索到匹配的异常处理器就会导致方法退出简称异常完成出口方法执行过程中抛出异常时的异常处理存储在一个异常处理表方便在发生异常的时候找到处理异常的代码本质上方法的退出就是当前栈帧出栈的过程此时需要恢复上层方法的局部变量表操作数栈将返回值压入调用者栈帧的操作数栈设置寄存器值等让调用者方法继续执行下去正常完成出口和异常完成出口的区别在于通过异常完成出口退出的不会给他的上层调用者产生任何的返回值一些附加信息栈帧中还允许携带与虚拟机实现相关的一些附加信息例如对程序调试提供支持的信息问题小结与拓展问题一栈溢出的情况栈溢出举个简单的例子在方法中调用方法就会不断压栈执行直到栈溢出栈的大小可以是固定大小的也可以是动态变化动态扩展的如果是固定的可以通过设置栈的大小如果是动态变化的当栈大小到达了整个内存空间不足了就是抛出异常问题二调整栈大小就能保证不出现溢出吗不能因为调整栈大小只会减少出现溢出的可能栈大小不是可以无限扩大的所以不能保证不出现溢出问题三分配的栈内存越大越好吗不是因为增加栈大小会造成每个线程的栈都变的很大使得一定的栈空间下能创建的线程数量会变小问题四垃圾回收是否会涉及到虚拟机栈不会垃圾回收只会涉及到方法区和堆中方法区和堆也会存在溢出的可能程序计数器只记录运行下一行的地址不存在溢出和垃圾回收虚拟机栈和本地方法栈都是只涉及压栈和出栈可能存在栈溢出不存在垃圾回收问题五方法中定义的局部变量是否线程安全具体问题具体分析见分析代码方法中定义的局部变量是否线程安全具体问题具体分析的声明方式是线程安全的因为线程私有在线程内创建的不会被其它线程调用线程不安全的操作过程是线程不安全的因为是外面传进来的有可能被多个线程调用的操作是线程不安全的因为返回了一个有可能被其他线程共享的操作是线程安全的因为返回了一个相当于了一个所以没有被其他线程共享的可能结论如果局部变量在内部产生并在内部消亡的那就是线程安全的本地方法接口与本地方法栈什么是本地方法简单地讲一个就是一个调用非代码的接口一个是这样一个方法该方法的实现由非语言实现比如这个特征并非所特有很多其它的编程语言都有这一机制比如在中你可以用告知编译器去调用一个的函数在定义一个时并不提供实现体有些像定义一个因为其实现体是由非语言在外面实现的本地接口的作用是融合不同的编程语言为所用它的初衷是融合程序举例举例举例类的内部标识符可以与所有其它的标识符连用但是除外为什么要使用使用起来非常方便然而有些层次的任务用实现起来不容易或者我们对程序的效率很在意时问题就来了与环境外交互有时应用需要与外面的环境交互这是本地方法存在的主要原因你可以想想需要与一些底层系统如操作系统或某些硬件交换信息时的情况本地方法正是这样一种交流机制它为我们提供了一个非常简洁的接口而且我们无需去了解应用之外的繁琐的细节与操作系统交互支持着语言本身和运行时库它是程序赖以生存的平台它由一个解释器解释字节码和一些连接到本地代码的库组成然而不管怎样它毕竟不是一个完整的系统它经常依赖于一些底层系统的支持这些底层系统常常是强大的操作系统通过使用本地方法我们得以用实现了的与底层系统的交互甚至的一些部分就是用写的还有如果我们要使用一些语言本身没有提供封装的操作系统的特性时我们也需要使用本地方法的解释器是用实现的这使得它能像一些普通的一样与外部交互大部分是用实现的它也通过一些本地方法与外界交互例如类的方法是用实现的但是它实现调用的是该类里的本地方法这个本地方法是用实现的并被植入内部在的平台上这个本地方法最终将调用这是一个本地方法的具体实现由直接提供更多的情况是本地方法由外部的动态链接库提供然后被调用本地方法现状目前该方法使用的越来越少了除非是与硬件有关的应用比如通过程序驱动打印机或者系统管理生产设备在企业级应用中已经比较少见因为现在的异构领域间的通信很发达比如可以使用通信也可以使用等等不多做介绍本地方法栈虚拟机栈用于管理方法的调用而本地方法栈用于管理本地方法的调用本地方法栈也是线程私有的允许被实现成固定或者是可动态扩展的内存大小在内存溢出方面是相同的如果线程请求分配的栈容量超过本地方法栈允许的最大容量虚拟机将会抛出一个异常如果本地方法栈可以动态扩展并且在尝试扩展的时候无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的本地方法栈那么虚拟机将会抛出一个异常本地方法是使用语言实现的它的具体做法是中登记方法在执行时加载本地方法库当某个线程调用一个本地方法时它就进入了一个全新的并且不再受虚拟机限制的世界它和虚拟机拥有同样的权限本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区它甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存并不是所有的都支持本地方法因为虚拟机规范并没有明确要求本地方法栈的使用语言具体实现方式数据结构等如果产品不打算支持方法也可以无需实现本地方法栈堆核心概述一个实例只存在一个堆内存堆也是内存管理的核心区域堆区在启动的时候即被创建其空间大小也就确定了是管理的最大一块内存空间堆内存的大小是可以调节的虚拟机规范规定堆可以处于物理上不连续的内存空间中但在逻辑上它应该被视为连续的堆是垃圾收集器执行垃圾回收的重点区域在方法结束后堆中的对象不会马上被移除仅仅在垃圾收集的时候才会被移除对象都分配在堆上虚拟机规范中对堆的描述是所有的对象实例以及数组都应当在运行时分配在堆上数组和对象可能永远不会存储在栈上因为栈帧中保存引用这个引用指向对象或者数组在堆中的位置说的是几乎所有的对象实例都在这里分配内存从实际使用角度看的举例所有的线程都共享堆所有的线程共享堆在这里还可以划分线程私有的缓冲区堆的内部结构面试题内存为什么要分成新生代老年代持久代新生代中为什么要分为和字节跳动堆里面的分区老年代各自的特点京东物流堆的结构为什么两个区蚂蚁金服的内存结构和比例京东现代垃圾收集器大部分都基于分代收集理论设计堆空间细分为及之前堆内存逻辑上分为三部分新生区养老区永久区新生区又被划分为区和区养老区永久区及之后堆内存逻辑上分为三部分新生区养老区元空间新生区又被划分为区和区养老区元空间约定新生区新生代年轻代养老区老年区老年代永久区永久代年轻代与老年代存储在中的对象可以被划分为两类一类是生命周期较短的瞬时对象这类对象的创建和消亡都非常迅速另外一类对象的生命周期却非常长在某些极端的情况下还能够与的生命周期保持一致堆区进一步细分的话可以划分为年轻代和老年代其中年轻代又可以划分为空间空间和空间有时也叫做区区几乎所有的对象都是在区被出来的绝大部分的对象的销毁都在新生代进行了公司的专门研究表明新生代中的对象都是朝生夕死的如何设置堆内存大小面试题堆大小通过什么参数设置阿里初始堆大小和最大堆大小一样问这样有什么好处亚信中最大堆大小有没有限制阿里堆区用于存储对象实例那么堆的大小在启动时就已经设定好了大家可以通过选项和来进行设置用于表示堆区的起始内存等价于则用于表示堆区的最大内存等价于一旦堆区中的内存大小超过所指定的最大内存时将会抛出异常通常会将和两个参数配置相同的值其目的是为了能够在垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小从而提高性能默认最大值计算方式如果物理内存少于那么最大值为物理内存的一半如果物理内存大于等于那么的最大值为物理内存的默认最小值计算方式最少不得少于如果物理内存大于等于那么默认值为物理内存的即最小堆内存在启动的时候就会被初始化关于堆空间的大小从官网取下来说明另对于位虚拟机如果物理内存等于那么堆内存可以达到对于位虚拟机如果物理内存为那么最多可以达到如何设置新生代与老年代比例下面这参数开发中一般不会调配置新生代与老年代在堆结构的占比默认表示新生代占老年代占新生代占整个堆的可以修改表示新生代占老年代占新生代占整个堆的可以使用选项设置新生代最大内存大小这个参数一般使用默认值就可以了如何设置幸存者区比例在中空间和另外两个空间缺省所占的比例是当然开发人员可以通过选项调整这个空间比例比如举例测试配置鼠标右键也可以通过进行设置选择当前正在运行的程序添加配置插件安装找到按照后重启即可运行程序监控内存状态可以看到区和的比例不是默认的而是可通过添加参数进行调整调整后如下报错如下参数设置小结面试题什么是空间分配担保策略堆空间大小的设置初始内存默认为物理内存的最大内存默认为物理内存的举例上午报错如下设置新生代的大小初始值及最大值通常默认即可配置新生代与老年代在堆结构的占比赋的值即为老年代的占比剩下的给新生代默认表示新生代占老年代占新生代占整个堆的表示新生代占老年代占新生代占整个堆的在中空间和另外两个空间缺省所占的比例是开发人员可以通过选项调整这个空间比例比如设置新生代垃圾的最大年龄超过此值仍未被回收的话则进入老年代默认值为表示年轻代对象不经过区直接进入老年代对于老年代比较多的应用可以提高效率如果将此值设置为一个较大值则年轻代对象会在区进行多次复制这样可以增加对象在年轻代的存活时间增加在年轻代即被回收的概率输出详细的处理日志显示如下在发生之前虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间如果大于则此次是安全的如果小于则虚拟机会查看设置值是否允许担保失败如果那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小如果大于则尝试进行一次但这次依然是有风险的如果小于或者则改为进行一次在之后参数不会再影响到虚拟机的空间分配担保策略观察中的源码变化虽然源码中还定义了参数但是在代码中已经不会再使用它之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行否则将进行查看所有的参数的最终值可能会存在修改不再是初始值具体查看某个参数的指令查看当前运行中的进程进程对象分配金句面试题什么时候对象会进入老年代渣打银行的伊甸园区区区的比例是否可调花旗银行中一次完整的流程是怎样的对象如何晋升到老年代字节跳动对象在堆内存创建的生命周期蚂蚁金服重点讲讲对象如何晋升到老年代几种主要的参数蚂蚁金服新生代和老年代的内存回收策略蚂蚁金服什么时候对象可以被收回蚂蚁金服为新对象分配内存是一件非常严谨和复杂的任务的设计者们不仅需要考虑内存如何分配在哪里分配等问题并且由于内存分配算法与内存回收算法密切相关所以还需要考虑执行完内存回收后是否会在内存空间中产生内存碎片金句针对幸存者区的总结复制之后有交换谁空谁是关于垃圾回收频繁在新生区收集很少在养老区收集几乎不在永久区元空间收集过程剖析的对象先放伊甸园区此区有大小限制当伊甸园的空间填满时程序又需要创建对象的垃圾回收器将对伊甸园区进行垃圾回收将伊甸园区中的不再被其他对象所引用的对象进行销毁再加载新的对象放到伊甸园区然后将伊甸园中的剩余对象移动到幸存者区如果再次触发垃圾回收此时上次幸存下来的放到幸存者区的如果没有回收就会放到幸存者区如果再次经历垃圾回收此时会重新放回幸存者区接着再去幸存者区啥时候能去养老区呢可以设置次数默认是次可以设置参数设置对象晋升老年代的年龄阈值在养老区相对悠闲当养老区内存不足时再次触发进行养老区的内存清理若养老区执行了之后发现依然无法进行对象的保存就会产生异常内存分配策略或对象提升规则如果对象在出生并经过第一次后仍然存活并且能被容纳的话将被移动到空间中并将对象年龄设为对象在区中每熬过一次年龄就增加岁当它的年龄增加到一定程度默认为岁其实每个每个都有所不同时就会被晋升到老年代中内存分配原则针对不同年龄段的对象分配原则如下所示优先分配到大对象直接分配到老年代尽量避免程序中出现过多的大对象长期存活的对象分配到老年代动态对象年龄判断如果区中相同年龄的所有对象大小的总和大于空间的一半年龄大于或等于该年龄的对象可以直接进入老年代无须等到中要求的年龄空间分配担保代码举例解释面试题与分别在什么时候发生腾讯老年代的垃圾回收机制什么时候触发自动触发的阈值是多少蚂蚁金服简述内存分配与回收策略以及和国美的一次完整的流程从到是怎样的蚂蚁金服在进行时并非每次都对上面三个内存新生代老年代方法区区域一起回收的大部分时候回收的都是指新生代针对的实现它里面的按照回收区域又分为两大种类型一种是部分收集一种是整堆收集部分收集不是完整收集整个堆的垃圾收集其中又分为新生代收集只是新生代的垃圾收集老年代收集只是老年代的垃圾收集目前只有会有单独收集老年代的行为注意很多时候会和混淆使用需要具体分辨是老年代回收还是整堆回收混合收集收集整个新生代以及部分老年代的垃圾收集目前只有会有这种行为整堆收集收集整个堆和方法区的垃圾收集触发机制年轻代触发机制当年轻代空间不足时就会触发这里的年轻代满指的是区满满不会引发每次会清理年轻代的内存因为对象大多都具备朝生夕灭的特性所以非常频繁一般回收速度也比较快这一定义既清晰又易于理解会引发暂停其它用户的线程等垃圾回收结束用户线程才恢复运行触发机制老年代触发机制指发生在老年代的对象从老年代消失时我们说或发生了出现了经常会伴随至少一次的但非绝对的在收集器的收集策略里就有直接进行的策略选择过程也就是在老年代空间不足时会先尝试触发如果之后空间还不足则触发的速度一般会比慢倍以上的时间更长是指在执行某些特定操作时暂停所有应用线程的现象期间应用程序的所有线程都会停止执行直到完成相关操作通常发生在垃圾回收过程中但也可能在其他情况下出现如果后内存还不足就报了触发机制触发机制触发执行的情况有如下五种调用时系统建议执行但是不必然执行老年代空间不足方法区空间不足通过后进入老年代的平均大小大于老年代的可用内存由区区向区复制时对象大小大于可用内存则把该对象转存到老年代且老年代的可用内存小于该对象大小说明是开发或调优中尽量要避免的这样暂时时间会短一些代码举例代码举例将参数调整的小一些这样问题会出现的比较早代码举例测试遍历次数为如何解决要解决异常或的异常一般的手段是首先通过内存映像分析工具如对出来的堆转储快照进行分析重点是确认内存中的对象是否是必要的也就是要先分清楚到底是出现了内存泄漏还是内存溢出如果是内存泄漏可进一步通过工具查看泄漏对象到的引用链于是就能找到泄漏对象是通过怎样的路径与相关联并导致垃圾收集器无法自动回收它们的掌握了泄漏对象的类型信息以及引用链的信息就可以比较准确地定位出泄漏代码的位置如果不存在内存泄漏换句话说就是内存中的对象确实都还必须存活着那就应当检查虚拟机的堆参数与与机器物理内存对比看是否还可以调大从代码上检查是否存在某些对象生命周期过长持有状态时间过长的情况尝试减少程序运行期的内存消耗堆空间分代思想为什么需要把堆分代不分代就不能正常工作了吗其实不分代完全可以分代的唯一理由就是优化性能如果没有分代那所有的对象都在一块就如同把一个学校的人都关在一个教室的时候要找到哪些对象没用这样就会对堆的所有区域进行扫描而很多对象都是朝生夕死的如果分代的话把新创建的对象放到某一地方当的时候先把这块存储朝生夕死对象的区域进行回收这样就会腾出很大的空间出来经研究不同对象的生命周期不同的对象是临时对象新生代有两块大小相同的又称为构成总为空老年代存放新生代中经历多次仍然存活的对象快速分配策略为什么有堆区是线程共享区域任何线程都可以访问到堆区中的共享数据由于对象实例的创建在中非常频繁因此在并发环境下从堆区中划分内存空间是线程不安全的为避免多个线程操作同一地址需要使用加锁等机制进而影响分配速度所以多线程同时分配内存时使用可以避免一系列的非线程安全问题同时还能够提升内存分配的吞吐量因此我们可以将这种内存分配方式称之为快速分配策略什么是从内存模型而不是垃圾收集的角度对区域继续进行划分为每个线程分配了一个私有缓存区域它包含在空间内据我所知所有衍生出来的都提供了的设计的再说明尽管不是所有的对象实例都能够在中成功分配内存但确实是将作为内存分配的首选在程序中开发人员可以通过选项设置是否开启空间默认情况下空间的内存非常小仅占有整个空间的当然我们可以通过选项设置空间所占用空间的百分比大小一旦对象在空间分配内存失败时就会尝试着通过使用加锁机制确保数据操作的原子性从而直接在空间中分配内存方法区栈堆方法区的关系方法区在哪里虚拟机规范中明确说明尽管所有的方法区在逻辑上是属于堆的一部分但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩但对于而言方法区还有一个别名叫做非堆目的就是要和堆分开所以方法区看作是一块独立于堆的内存空间方法区的理解从线程共享与否的角度来看方法区与堆一样是各个线程共享的内存区域方法区在启动的时候被创建并且它的实际的物理内存空间中和堆区一样都可以是不连续的方法区的大小跟堆空间一样可以选择固定大小或者可扩展方法区的大小决定了系统可以保存多少个类如果系统定义了太多的类导致方法区溢出虚拟机同样会抛出内存溢出错误或者加载大量的第三方的包部署的工程过多个大量动态的生成反射类关闭就会释放这个区域的内存中方法区的演进在及以前习惯上把方法区称为永久代开始使用元空间取代了永久代本质上方法区和永久代并不等价仅是对而言的虚拟机规范对如何实现方法区不做统一要求例如中不存在永久代的概念现在来看当年使用永久代不是好的导致程序更容易超过上限而到了终于完全废弃了永久代的概念改用与一样在本地内存中实现的元空间来代替元空间的本质和永久代类似都是对规范中方法区的实现不过元空间与永久代最大的区别在于元空间不在虚拟机设置的内存中而是使用本地内存永久代元空间二者并不只是名字变了内部结构也调整了根据虚拟机规范的规定如果方法区无法满足新的内存分配需求时将抛出异常方法区常用参数有哪些设置方法区内存的大小方法区的大小不必是固定的可以根据应用的需要动态调整及以前通过来设置永久代初始分配空间默认值是来设定永久代最大可分配空间位机器默认是位机器模式是当加载的类信息容量超过了这个值会报异常及以后元数据区大小可以使用参数和指定替代上述原有的两个参数默认值依赖于平台下是的值是即没有限制与永久代不同如果不指定大小默认情况下虚拟机会耗尽所有的可用系统内存如果元数据区发生溢出虚拟机一样会抛出异常设置初始的元空间大小对于一个位的服务器端来说其默认的值为这就是初始的高水位线一旦触及这个水位线将会被触发并卸载没用的类即这些类对应的类加载器不再存活然后这个高水位线将会重置新的高水位线的值取决于后释放了多少元空间如果释放的空间不足那么在不超过时适当提高该值如果释放空间过多则适当降低该值如果初始化的高水位线设置过低上述高水位线调整情况会发生很多次通过垃圾回收器的日志可以观察到多次调用为了避免频繁地建议将设置为一个相对较高的值在及以上版本中设定参数在启动时并不会报错但是会提示代码举例中中创建对象用于生成类的二进制字节码指明版本号类名包名父类接口返回类的加载对象方法区都存什么深入理解虚拟机书中对方法区存储内容描述如下它用于存储已被虚拟机加载的类型信息常量静态变量即时编译器编译后的代码缓存等类型信息对每个加载的类型类接口枚举注解必须在方法区中存储以下类型信息这个类型的完整有效名称全名包名类名这个类型直接父类的完整有效名对于或是都没有父类这个类型的修饰符的某个子集这个类型直接接口的一个有序列表域信息必须在方法区中保存类型的所有域的相关信息以及域的声明顺序域的相关信息包括域名称域类型域修饰符的某个子集方法信息必须保存所有方法的以下信息同域信息一样包括声明顺序方法名称方法的返回类型或方法参数的数量和类型按顺序方法的修饰符的一个子集方法的字节码操作数栈局部变量表及大小和方法除外异常表和方法除外每个异常处理的开始位置结束位置代码处理在程序计数器中的偏移地址被捕获的异常类的常量池索引代码举例一编译后如下代码举例二属性测试方法的内部结构方法的类变量静态变量和类关联在一起随着类的加载而加载它们成为类数据在逻辑上的一部分类变量被类的所有实例共享即使没有类实例时你也可以访问它补充说明全局常量被声明为的类变量的处理方法则不同每个全局常量在编译的时候就会被分配了运行时常量池运行时常量池是方法区的一部分常量池表是文件的一部分用于存放编译期生成的各种字面量与符号引用这部分内容将在类加载后存放到方法区的运行时常量池中运行时常量池在加载类和接口到虚拟机后就会创建对应的运行时常量池为每个已加载的类型类或接口都维护一个常量池池中的数据项像数组项一样是通过索引访问的运行时常量池中包含多种不同的常量包括编译期就已经明确的数值字面量也包括到运行期解析后才能够获得的方法或者字段引用此时不再是常量池中的符号地址了这里换为真实地址运行时常量池相对于文件常量池的另一重要特征是具备动态性运行时常量池类似于传统编程语言中的符号表但是它所包含的数据却比符号表要更加丰富一些当创建类或接口的运行时常量池时如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值则会抛异常关联常量池方法区内部包含了运行时常量池字节码文件内部包含了常量池要弄清楚方法区需要理解清楚因为加载类的信息都在方法区要弄清楚方法区的运行时常量池需要理解清楚中的常量池如下一个有效的字节码文件中除了包含类的版本信息字段方法以及接口等描述信息外还包含一项信息那就是常量池表包括各种字面量和对类型域和方法的符号引用小结常量池可以看做是一张表虚拟机指令根据这张常量表找到要执行的类名方法名参数类型字面量等类型为什么需要常量池一个源文件中的类接口编译后产生一个字节码文件而中的字节码需要数据支持通常这种数据会很大以至于不能直接存到字节码里换另一种方式可以存到常量池这个字节码包含了指向常量池的引用在动态链接的时候会用到运行时常量池之前有介绍比如如下的代码虽然只有字节但是里面却使用了及等结构这里代码量其实已经很小了如果代码多引用到的结构会更多这里就需要常量池了常量池都有什么几种在常量池内存储的数据类型包括数量值字符串值类引用字段引用方法引用例如下面这段代码其中代码将会被编译成如下字节码方法区使用举例永久代与元空间首先明确只有才有永久代等来说是不存在永久代的概念的原则上如何实现方法区属于虚拟机实现细节不受虚拟机规范管束并不要求统一中永久代的变化及之前有永久代有永久代但已经逐步去永久代字符串常量池静态变量移除保存在堆中及之后无永久代类型信息字段方法常量保存在本地内存的元空间但字符串常量池仍在堆方法区是否存在回收什么面试题的永久代中会发生垃圾回收么腾讯有些人认为方法区如虚拟机中的元空间或者永久代是没有垃圾收集行为的其实不然虚拟机规范对方法区的约束是非常宽松的提到过可以不要求虚拟机在方法区中实现垃圾收集事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在如时期的收集器就不支持类卸载一般来说这个区域的回收效果比较难令人满意尤其是类型的卸载条件相当苛刻但是这部分区域的回收有时又确实是必要的以前公司的列表中曾出现过的若干个严重的就是由于低版本的虚拟机对此区域未完全回收而导致内存泄漏方法区的垃圾收集主要回收两部分内容常量池中废弃的常量和不再使用的类型先来说说方法区内常量池之中主要存放的两大类常量字面量和符号引用字面量比较接近语言层次的常量概念如文本字符串被声明为的常量值等而符号引用则属于编译原理方面的概念包括下面三类常量类和接口的全限定名字段的名称和描述符方法的名称和描述符虚拟机对常量池的回收策略是很明确的只要常量池中的常量没有被任何地方引用就可以被回收回收废弃常量与回收堆中的对象非常类似判定一个常量是否废弃还是相对简单而要判定一个类型是否属于不再被使用的类的条件就比较苛刻了需要同时满足下面三个条件该类所有的实例都已经被回收也就是堆中不存在该类及其任何派生子类的实例加载该类的类加载器已经被回收这个条件除非是经过精心设计的可替换类加载器的场景如的重加载等否则通常是很难达成的该类对应的对象没有在任何地方被引用无法在任何地方通过反射访问该类的方法虚拟机被允许对满足上述三个条件的无用类进行回收这里说的仅仅是被允许而并不是和对象一样没有引用了就必然会回收关于是否要对类型进行回收虚拟机提供了参数进行控制还可以使用以及查看类加载和卸载信息在大量使用反射动态代理等字节码框架动态生成以及这类频繁自定义类加载器的场景中通常都需要虚拟机具备类型卸载的能力以保证不会对方法区造成过大的内存压力内存结构小结直接内存概述不是虚拟机运行时数据区的一部分也不是虚拟机规范中定义的内存区域直接内存是在堆外的直接向系统申请的内存区间来源于通过存在堆中的操作内存通常访问直接内存的速度会优于堆即读写性能高因此出于性能考虑读写频繁的场合可能会考虑使用直接内存的库允许程序使用直接内存用于数据缓冲区非直接缓冲区直接缓冲区读写文件需要与磁盘交互需要由用户态切换到内核态使用见上图这里需要两份内存存储重复数据效率低使用时如上图操作系统划出的直接缓存区可以被代码直接访问只有一份适合对大文件的读写操作大小设置方式也可能导致异常由于直接内存在堆外因此它的大小不会直接受限于指定的最大堆大小但是系统内存是有限的堆和直接内存的总和依然受限于操作系统能给出的最大内存缺点分配回收成本较高不受内存回收管理直接内存大小可以通过设置如果不指定默认与堆的最大值参数值一致简单理解代码举例如果不指定则默认与堆最大值指定一致上午面试题是放在哪里还放在哪里搜狐万达集团的不可变性通过字面量的方式区别于给一个字符串赋值此时的字符串值声明在字符串常量池中字符串常量池中是不会存储相同内容的字符串的字面量的定义方式比较和的地址值的内存分配整体来说及以前字符串常量池存放在永久代中的工程师对字符串池的逻辑做了很大的改变即将字符串常量池的位置调整到堆内中字符串常量仍然在堆为什么要调整举例具体细节数组链表的是一个固定大小的默认值大小长度是如果放进的非常多就会造成冲突严重从而导致链表会很长而链表长了后直接会造成的影响就是当调用时性能会大幅下降因为要一个一个找在中是固定的就是的长度所以如果常量池中的字符串过多就会导致效率下降很快在中的长度可以通过一个参数指定的基本操作常量优化机制编译的时候就已经是最终编译成再执行字符串拼接操作体会执行效率每次循环都会创建一个问题的实例化方式方式一通过字面量定义的方式方式二通过构造器的方式面试题方式创建对象在内存中创建了几个对象两个一个是堆空间中结构另一个是对应的常量池中的数据方法中的解释中的解释题目变形的去重操作问题底层是什么结构新的需求许多大规模的应用的瓶颈在于内存测试表明在这些类型的应用里面堆中存活的数据集合差不多是对象更进一步这里面差不多一半对象是重复的重复的意思是说为堆上存在重复的对象必然是一种内存的浪费这个项目将在垃圾收集器中实现自动持续对重复的对象进行去重这样就能避免浪费内存说明去重不需要对的类库和已经存在的代码做任何的改动',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-03 17:38:52',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script async="" defer="" src="https://umami.shiguangdev.cn/script.js" data-website-id="bc279f56-9a19-416a-a035-58c0abed887b"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="時光" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar.png"><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.shiguang666.eu.org" title="時光主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光主页"><span class="back-menu-item-text">時光主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://nav.shiguang666.eu.org" title="時光导航站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://nav.shiguang666.eu.org/images/logo-collapsed@2x.png" alt="時光导航站"><span class="back-menu-item-text">時光导航站</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://love.shiguang666.eu.org" title="表白生成器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://love.shiguang666.eu.org/favicon.ico" alt="表白生成器"><span class="back-menu-item-text">表白生成器</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://publish.shiguang666.eu.org/" title="時光站点发布页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/homepage.png" alt="時光站点发布页"><span class="back-menu-item-text">時光站点发布页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://release.shiguang666.eu.org/" title="地址发布页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/homepage.png" alt="地址发布页"><span class="back-menu-item-text">地址发布页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://qq.shiguang666.eu.org/" title="時光的QQ"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/qqavatar.jpg" alt="時光的QQ"><span class="back-menu-item-text">時光的QQ</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://game.shiguang666.eu.org" title="怀旧游戏机"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/chat.png" alt="怀旧游戏机"><span class="back-menu-item-text">怀旧游戏机</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://games.shiguang666.eu.org" title="H5小游戏合集"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://echeverra.cn/wp-content/uploads/2021/06/cropped-thmub-32x32.jpg" alt="H5小游戏合集"><span class="back-menu-item-text">H5小游戏合集</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">后台管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://umami.shiguangdev.cn/share/1CY8KW6pqM0UBUIL/blog.shiguangdev.cn" title="访客统计"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://umami.shiguangdev.cn/favicon.ico" alt="访客统计"><span class="back-menu-item-text">访客统计</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://img.shiguangdev.cn/" title="時光图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/favicon.ico" alt="時光图床"><span class="back-menu-item-text">時光图床</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.shiguang666.eu.org/" title="Qexo"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://unpkg.com/qexo-static@2.2.3/qexo/images/icon.png" alt="Qexo"><span class="back-menu-item-text">Qexo</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">時光</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="fa fa-line-chart faa-tada"></i><span> 统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随机</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/news/"><i class="fa fa-newspaper faa-tada"></i><span> 早报亭</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=10051718332&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/xjj/"><i class="fa fa-rocket faa-tada"></i><span> 养生堂</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comment/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechat.png"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.png"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">31</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">38</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">30</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java</span></a><a class="article-meta__tags" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>尚硅谷</span></a><a class="article-meta__tags" href="/tags/JVM/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JVM</span></a></span></div></div><h1 class="post-title" itemprop="name headline">【尚硅谷】JVM-运行时内存篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-12-20T03:27:30.000Z" title="发表于 2024-12-20 11:27:30">2024-12-20</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-01-03T09:38:52.144Z" title="更新于 2025-01-03 17:38:52">2025-01-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">21.5k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>73分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/12/20/fddf53a80c95/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope="" itemtype="https://blog.shiguang666.eu.org/2024/12/20/fddf53a80c95/"><header><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a><a href="/tags/Java/" tabindex="-1" itemprop="url">Java</a><a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" tabindex="-1" itemprop="url">尚硅谷</a><a href="/tags/JVM/" tabindex="-1" itemprop="url">JVM</a><h1 id="CrawlerTitle" itemprop="name headline">【尚硅谷】JVM-运行时内存篇</h1><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">時光</span><time itemprop="dateCreated datePublished" datetime="2024-12-20T03:27:30.000Z" title="发表于 2024-12-20 11:27:30">2024-12-20</time><time itemprop="dateCreated datePublished" datetime="2025-01-03T09:38:52.144Z" title="更新于 2025-01-03 17:38:52">2025-01-03</time></header><div id="postchat_postcontent"><p><strong>官方资料：</strong></p>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=18">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://www.bilibili.com/favicon.ico)">
          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">尚硅谷JVM精讲与GC调优教程（宋红康主讲，含jvm面试真题）</div>
            <div class="tag-link-sitename">在线视频</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://pan.baidu.com/s/1ITPpXOuTwfBW2e5dksgqNw?pwd=yyds">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://nd-static.bdstatic.com/m-static/v20-main/favicon-main.ico)">
          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">尚硅谷宋红康JVM精讲与GC调优</div>
            <div class="tag-link-sitename">课程资料</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://blog.shiguangdev.cn/html/atguigu/尚硅谷_JVM精讲与GC调优第4篇-对象内存布局.html">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://th.bing.com/th?id=ODLS.257b82c4-9cf6-4599-8c46-03342a2f9e88&amp;w=32&amp;h=32&amp;qlt=90&amp;pcl=fffffa&amp;o=6&amp;pid=1.2)">
          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">第3篇-运行时内存篇</div>
            <div class="tag-link-sitename">思维导图</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<p><strong>代码仓库：</strong></p>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://gitee.com/an_shiguang/learn-jvm">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://gitee.com/favicon.ico)">
          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Gitee</div>
            <div class="tag-link-sitename">@an_shiguang</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://github.com/Shiguang-coding/learn-jvm">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://github.com/favicon.ico)">
          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">GitHub</div>
            <div class="tag-link-sitename">@Shiguang-coding</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<h1 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h1><blockquote>
<p><strong>面试题：</strong></p>
<ul>
<li>讲一下为什么JVM要分为堆、方法区等？原理是什么？（UC、智联）</li>
<li>JVM的分区了解吗，内存溢出发生在哪个位置 （亚信、BOSS）</li>
<li>简述各个版本内存区域的变化？（猎聘）</li>
<li>OOM的错误，StackOverFlow错误，permgen space的错误  (蚂蚁金服)</li>
</ul>
</blockquote>
<p><strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异。</strong>结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764e6007e243.webp" alt="image-20241220113526580"></p>
<p><strong>面试题</strong>：</p>
<ul>
<li><p>说一说JVM的内存结构是什么样子的,每个区域放什么，各有什么特点？（快手、搜狐）</p>
</li>
<li><p>JVM内存模型有哪些？（龙湖地产）</p>
</li>
<li><p>JVM的内存模型，线程独有的放在哪里？哪些是线程共享的？哪些是线程独占的？（万达集团）</p>
</li>
<li><p>讲一下为什么JVM要分为堆、方法区等？原理是什么？（小米、搜狐）</p>
</li>
<li><p>讲讲JVM运行时数据库区  (字节跳动)</p>
</li>
<li><p>JVM的内存布局以及垃圾回收原理及过程讲一下 (京东)</p>
</li>
<li><p>你能画出HotSpotVM内存结构图吗？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764e73cd0519.webp" alt="image-20241220114043921"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764e75807524.webp" alt="image-20241220114111694"></p>
</li>
<li><p>哪些内存结构与线程一一对应？</p>
<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
</li>
</ul>
<h1 id="2、程序计数器"><a href="#2、程序计数器" class="headerlink" title="2、程序计数器"></a>2、程序计数器</h1><blockquote>
<p>面试题：JVM计数器如何记数（京东-物流）?</p>
</blockquote>
<h2 id="2-1、为什么需要它？"><a href="#2-1、为什么需要它？" class="headerlink" title="2.1、为什么需要它？"></a>2.1、为什么需要它？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764e80554347.webp" alt="image-20241220114405048"></p>
<ol>
<li>为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为<strong>指令计数器</strong>。</li>
<li>在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。</li>
<li>由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。 </li>
<li>当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为<strong>指令指针IP（Instruction Pointer）</strong>。</li>
</ol>
<p><strong>小结</strong>：</p>
<ul>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li><strong>PC寄存器用来存储指向下一条指令的地址，也是即将要执行的指令代码。执行引擎的字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</strong></li>
</ul>
<blockquote>
<p><strong>为什么执行native方法时，是undefined？</strong></p>
</blockquote>
<ul>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。</li>
<li><strong>native 本地方法是大多是通过C语言实现，并未编译成需要执行的字节码指令，所以在计数器中当然是空（undefined）。</strong></li>
</ul>
<h2 id="2-2、案例"><a href="#2-2、案例" class="headerlink" title="2.2、案例"></a>2.2、案例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 对应的字节码：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int <span class="built_in">test</span>();</span><br><span class="line">    descriptor: ()I</span><br><span class="line"> </span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"> </span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: iconst_1</span><br><span class="line">         3: istore_2</span><br><span class="line">         4: iload_1</span><br><span class="line">         5: iload_2</span><br><span class="line">         6: iadd</span><br><span class="line">         7: ireturn</span><br><span class="line"> </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">        line 8: 2</span><br><span class="line">        line 9: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"> </span><br><span class="line">            0       8     0  this   Lcom/alibaba/uc/TestClass;</span><br><span class="line">            2       6     1     x   I</span><br><span class="line">            4       4     2     y   I</span><br></pre></td></tr></tbody></table></figure>

<p>字节码指令分析：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764ea4cc2ac3.webp" alt="image-20241220115348317"></p>
<h2 id="2-3、基本特征"><a href="#2-3、基本特征" class="headerlink" title="2.3、基本特征"></a>2.3、基本特征</h2><p>JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。</p>
<p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切(也称为程序钩子) ，并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764eaeae0d35.webp" alt="image-20241220115626619"></p>
<p><strong>总结</strong>：</p>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。不会随着程序的运行需要更大的空间。</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li>
<li><strong>它是唯一一个在Java 虚拟机规范中没有规定任何OutOtMemoryError 情况的区域。</strong></li>
</ul>
<h2 id="2-4、两个问题"><a href="#2-4、两个问题" class="headerlink" title="2.4、两个问题"></a>2.4、两个问题</h2><h3 id="2-4-1、PC寄存器存储字节码指令地址有什么用？"><a href="#2-4-1、PC寄存器存储字节码指令地址有什么用？" class="headerlink" title="2.4.1、PC寄存器存储字节码指令地址有什么用？"></a>2.4.1、PC寄存器存储字节码指令地址有什么用？</h3><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。	</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764eb842c958.webp" alt="image-20241220115859871"></p>
<h3 id="2-4-2、PC寄存器为什么被设定为线程私有的？"><a href="#2-4-2、PC寄存器为什么被设定为线程私有的？" class="headerlink" title="2.4.2、PC寄存器为什么被设定为线程私有的？"></a>2.4.2、PC寄存器为什么被设定为线程私有的？</h3><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<h1 id="3、虚拟机栈"><a href="#3、虚拟机栈" class="headerlink" title="3、虚拟机栈"></a>3、虚拟机栈</h1><h2 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h2><p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆(heap)和Java栈(stack)？</p>
<p><strong>Java虚拟机栈是什么？</strong></p>
<ul>
<li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</li>
<li>是线程私有的</li>
</ul>
<p><strong>生命周期：</strong></p>
<p>生命周期和线程一致。</p>
<p><strong>特点：</strong></p>
<p>栈是一种快速有效的分配存储方式，<strong>访问速度仅次于程序计数器</strong>。</p>
<h3 id="3-1-1、如何理解栈管运行，堆管存储？"><a href="#3-1-1、如何理解栈管运行，堆管存储？" class="headerlink" title="3.1.1、如何理解栈管运行，堆管存储？"></a>3.1.1、如何理解栈管运行，堆管存储？</h3><blockquote>
<p>面试题：</p>
<ul>
<li>堆和栈的区别、谁的性能更高（艾绒软件）</li>
<li>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？  (阿里)</li>
</ul>
<p>解答思路：</p>
<ul>
<li>角度一：GC;OOM</li>
<li>角度二：栈、堆执行效率</li>
<li>角度三：内存大小；数据结构</li>
<li>角度四：栈管运行；堆管存储。</li>
</ul>
</blockquote>
<p><strong>作用</strong></p>
<p>主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果，并参与方法的调用和返回。</p>
<ul>
<li>局部变量 vs 成员变量(或属性)</li>
<li>基本数据变量  vs 引用类型变量（类、数组、接口）</li>
</ul>
<p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p>
<h3 id="3-1-2、栈存在GC吗"><a href="#3-1-2、栈存在GC吗" class="headerlink" title="3.1.2、栈存在GC吗?"></a>3.1.2、栈存在GC吗?</h3><p>不存在GC ; 存在OOM</p>
<h3 id="3-1-3、可能抛出的异常？"><a href="#3-1-3、可能抛出的异常？" class="headerlink" title="3.1.3、可能抛出的异常？"></a>3.1.3、可能抛出的异常？</h3><blockquote>
<p>面试题：</p>
<ul>
<li>什么情况下会发生栈内存溢出（360）</li>
<li>栈存在内存溢出吗 (京东)</li>
</ul>
<p>解答思路：</p>
<ul>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。</li>
<li>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li>
</ul>
</blockquote>
<p>Java 虚拟机规范允许<strong>Java栈的大小是动态的或者是固定不变的</strong>。</p>
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常。</li>
</ul>
<h3 id="3-1-4、如何设置栈内存大小？"><a href="#3-1-4、如何设置栈内存大小？" class="headerlink" title="3.1.4、如何设置栈内存大小？"></a>3.1.4、如何设置栈内存大小？</h3><blockquote>
<p>面试题：Java中，栈的大小通过什么参数来设置？</p>
</blockquote>
<p><strong>-Xss size (即：-XX:ThreadStackSize)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764f0099eeb8.webp" alt="image-20241220121814500"></p>
<ul>
<li>一般默认为512k-1024k，取决于操作系统。</li>
<li>栈的大小直接决定了函数调用的最大可达深度。</li>
<li>设置的栈空间值过大，会导致系统可以用于创建线程的数量减少。一般一个进程中通常有3000-5000个线程。</li>
</ul>
<p><strong>默认值</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37646636/article/details/120530053">[实践总结] idea如何配置JVM启动参数(IntelliJ IDEA 2021.2.2)</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764f03a7c881.webp" alt="image-20241220121849264"></p>
<ul>
<li>jdk5.0之前，默认栈大小：256k</li>
<li>jdk5.0之后，默认栈大小：1024k （linux\mac\windows)</li>
</ul>
<h2 id="3-2、栈的单位：栈帧（Stack-Frame）"><a href="#3-2、栈的单位：栈帧（Stack-Frame）" class="headerlink" title="3.2、栈的单位：栈帧（Stack Frame）"></a>3.2、栈的单位：栈帧（Stack Frame）</h2><blockquote>
<p>面试题：</p>
<ul>
<li><p>栈是如何运行的（OPPO）</p>
</li>
<li><p>VM有哪些组成，堆，栈各放了什么东西。（新浪）</p>
</li>
<li><p>怎么理解栈、堆？堆中存什么？栈中存什么？  (阿里)</p>
</li>
</ul>
</blockquote>
<p>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）</strong>的格式存在。</p>
<h3 id="3-2-1、方法和栈帧的关系？"><a href="#3-2-1、方法和栈帧的关系？" class="headerlink" title="3.2.1、方法和栈帧的关系？"></a>3.2.1、方法和栈帧的关系？</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764f11db0e11.webp" alt="image-20241220122252154"></p>
<ul>
<li><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p>
</li>
<li><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
</li>
</ul>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong>。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p><strong>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</strong></p>
<h3 id="3-2-2、栈的FILO原理"><a href="#3-2-2、栈的FILO原理" class="headerlink" title="3.2.2、栈的FILO原理?"></a>3.2.2、栈的FILO原理?</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764f20239649.webp" alt="image-20241220122640497"></p>
<p>JVM直接对Java栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着进栈(入栈、压栈)</li>
<li>执行结束后的出栈工作</li>
<li><strong>遵循“先进后出”/“后进先出”原则</strong></li>
</ul>
<p><strong>不同线程中所包含的栈帧是不允许存在相互引用</strong>的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></p>
<h2 id="3-3、栈桢内部结构"><a href="#3-3、栈桢内部结构" class="headerlink" title="3.3、栈桢内部结构"></a>3.3、栈桢内部结构</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764f3314a71c.webp" alt="image-20241220123143779"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764f355d7712.webp" alt="image-20241220123220942"></p>
<p>每个栈帧中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）（或表达式栈）</li>
<li>动态链接(Dynamic Linking) （或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<h3 id="3-3-1、局部变量表（local-variables"><a href="#3-3-1、局部变量表（local-variables" class="headerlink" title="3.3.1、局部变量表（local variables)"></a>3.3.1、局部变量表（local variables)</h3><ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型(8种)、对象引用（reference），以及returnAddress类型。</li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li><strong>方法嵌套调用的次数由栈的大小决定。</strong>一般来说，栈越大，<strong>方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效。</strong>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764f46f00e6e.webp" alt="image-20241220123701562"></p>
<p>可以看到，在Class文件的局部变量表中，显示了每个局部变量的作用域范围、所在槽位的索引(index列)、变量名(name列)和数据类型(J表示long型)。</p>
<h4 id="3-3-1-1、存在线程安全问题吗？"><a href="#3-3-1-1、存在线程安全问题吗？" class="headerlink" title="3.3.1.1、存在线程安全问题吗？"></a>3.3.1.1、存在线程安全问题吗？</h4><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，<strong>因此不存在数据线程安全问题</strong>。</p>
<h4 id="3-3-1-2、关于Slot的理解"><a href="#3-3-1-2、关于Slot的理解" class="headerlink" title="3.3.1.2、关于Slot的理解"></a>3.3.1.2、关于Slot的理解</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764f656e64e3.webp" alt="image-20241220124509356"></p>
<ul>
<li>参数值的存放总是在局部变量数组的index为0开始，到数组长度-1的索引结束。</li>
<li>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>。</li>
<li>在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double)占用两个slot。</strong><ul>
<li>byte 、short 、char 在存储前被转换为int，boolean 也被转换为int，0 表示false ，非0 表示true。</li>
<li>long 和double 则占据两个Slot。</li>
</ul>
</li>
<li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个Slot上</li>
<li><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>(比如：访问long或double类型变量）</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</li>
</ul>
<h4 id="3-3-1-3、Slot的重复利用举例？"><a href="#3-3-1-3、Slot的重复利用举例？" class="headerlink" title="3.3.1.3、Slot的重复利用举例？"></a>3.3.1.3、Slot的重复利用举例？</h4><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//变量c的位置:复用了变量b的slot</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>局部变量表如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/30/67724fdb099f5.webp" alt="image-20241230154633776"></p>
<h4 id="3-3-1-4、静态变量与局部变量的对比"><a href="#3-3-1-4、静态变量与局部变量的对比" class="headerlink" title="3.3.1.4、静态变量与局部变量的对比"></a>3.3.1.4、静态变量与局部变量的对比</h4><ul>
<li><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
</li>
<li><p>我们知道类变量表有两次初始化的机会，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对类变量设置零值，另一次则是在“<strong>初始化</strong>”阶段，赋予程序员在代码中定义的初始值。</p>
</li>
<li><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样的代码是错误的，没有赋值不能够使用。</p>
</li>
</ul>
<h4 id="3-3-1-5、与GC-Roots的关系"><a href="#3-3-1-5、与GC-Roots的关系" class="headerlink" title="3.3.1.5、与GC Roots的关系"></a>3.3.1.5、与GC Roots的关系</h4><p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764f8f325b89.webp" alt="image-20241220125617470"></p>
<h3 id="3-3-2、操作数栈（Operand-Stack）"><a href="#3-3-2、操作数栈（Operand-Stack）" class="headerlink" title="3.3.2、操作数栈（Operand Stack）"></a>3.3.2、操作数栈（Operand Stack）</h3><h4 id="3-3-2-1、概念"><a href="#3-3-2-1、概念" class="headerlink" title="3.3.2.1、概念"></a>3.3.2.1、概念</h4><ul>
<li>我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</li>
<li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称之为<strong>表达式栈（Expression Stack）</strong>。</li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong>。</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，<strong>其所需的最大深度在编译期就定义好了</strong>，保存在方法的Code属性中，为<strong>max_stack</strong>的值。</li>
<li>栈中的任何一个元素都可以是任意的Java数据类型。<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li><strong>操作数栈，在方法执行过程中，根据字节码指令，并非采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈（push）和出栈（pop）操作，往栈中写入数据或提取数据来完成一次数据访问。<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作</li>
</ul>
</li>
<li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</li>
</ul>
<p><strong>代码举例</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>字节码指令信息:</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void testAddOperation();</span><br><span class="line">     Code:</span><br><span class="line">     0: bipush        15</span><br><span class="line">     2: istore_1</span><br><span class="line">     3: bipush        8</span><br><span class="line">     5: istore_2</span><br><span class="line">     6: iload_1</span><br><span class="line">     7: iload_2</span><br><span class="line">     8: iadd</span><br><span class="line">     9: istore_3</span><br><span class="line">     10: <span class="built_in">return</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果</strong>，同时作为计算过程中变量临时的存储空间。</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li>
</ul>
<h4 id="3-3-2-2、代码演示"><a href="#3-3-2-2、代码演示" class="headerlink" title="3.3.2.2、代码演示"></a>3.3.2.2、代码演示</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 字节码分析：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764fbde19063.webp" alt="image-20241220130844582"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764fbfcd0249.webp" alt="image-20241220130915265"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764fc0d824a0.webp" alt="image-20241220130932890"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764fc27f1d08.webp" alt="image-20241220130958890"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764fc38a2e7e.webp" alt="image-20241220131016058"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764fc4aaf1ed.webp" alt="image-20241220131034107"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764fc5b144b5.webp" alt="image-20241220131050124"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764fc6ed0341.webp" alt="image-20241220131110164"></p>
<h4 id="3-3-2-3、何为栈顶缓存技术？"><a href="#3-3-2-3、何为栈顶缓存技术？" class="headerlink" title="3.3.2.3、何为栈顶缓存技术？"></a>3.3.2.3、何为栈顶缓存技术？</h4><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中</strong>，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<h3 id="3-3-3、动态链接"><a href="#3-3-3、动态链接" class="headerlink" title="3.3.3、动态链接"></a>3.3.3、动态链接</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/6764fd0d88e3b.webp" alt="image-20241220131348024"></p>
<p><strong>动态链接（或指向运行时常量池的方法引用）</strong>：</p>
<ul>
<li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接（Dynamic Linking）</strong>。比如：invokedynamic指令。</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，<strong>那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。</li>
</ul>
<p><strong>举例</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSum</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getSum();</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-3-1、为什么需要常量池呢？"><a href="#3-3-3-1、为什么需要常量池呢？" class="headerlink" title="3.3.3.1、为什么需要常量池呢？"></a>3.3.3.1、为什么需要常量池呢？</h4><p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p>
<h4 id="3-3-3-2、方法的调用"><a href="#3-3-3-2、方法的调用" class="headerlink" title="3.3.3.2、方法的调用"></a>3.3.3.2、方法的调用</h4><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p>
<ul>
<li><p><strong>静态链接</strong></p>
<p>当一个字节码文件被装载进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>
</li>
<li><p><strong>动态链接</strong><br>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p>
</li>
<li><p><strong>早期绑定</strong><br>早期绑定就是指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</li>
<li><p><strong>晚期绑定</strong></p>
<p>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
</li>
</ul>
<p><strong>虚方法与非虚方法</strong></p>
<p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<strong>这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式</strong>。</p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字<strong>final</strong>来标记这个方法。</p>
<p>非虚方法：</p>
<ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ul>
<p>子类对象的多态性的使用前提：① 类的继承关系 ② 方法的重写 </p>
<p>在类加载的解析阶段就可以进行解析，如下是非虚方法举例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> {</span><br><span class="line">        System.out.println(<span class="string">"father "</span> + str);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String str)</span> {</span><br><span class="line">        System.out.println(<span class="string">"father "</span> + str);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualMethodTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Son.print(<span class="string">"coder"</span>);</span><br><span class="line">        <span class="comment">//Father fa = new Father();</span></span><br><span class="line">        <span class="comment">//fa.show("atguigu.com");</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li><p>普通调用指令：<br>1. <strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong><br>2. <strong>invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</strong><br>3. invokevirtual：调用所有虚方法<br>4. invokeinterface：调用接口方法</p>
</li>
<li><p>动态调用指令：</p>
<ol start="5">
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ol>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</strong>。</p>
<p>关于invokedynamic指令:</p>
<ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是<strong>Java为了实现『动态类型语言』支持而做的一种改进</strong>。</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java<strong>中才有了直接的生成方式</strong>。</li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li>
</ul>
<p>动态类型语言和静态类型语言:</p>
<p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，<strong>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特征。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java: String info = “atguigu”; //info = atguigu;</span><br><span class="line">JS：var name = “shkstart”; var name = 10;</span><br><span class="line">Python: info = 130.5;</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于invokedynamic指令</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 12:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();</span><br><span class="line">        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        };</span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>方法重写的本质</strong></p>
<blockquote>
<p>IllegalAccessError介绍：<br>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
</blockquote>
<ul>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li>
<li>如果在过程结束；如果不通类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过，则返回 java.lang.IllegalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError异常。</li>
</ul>
<p><strong>虚方法表</strong></p>
<ul>
<li><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<strong>为了提高性能</strong>，JVM采用在类的方法区建立一个<strong>虚方法表（virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找</strong>。</p>
</li>
<li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
</li>
<li><p>那么虚方法表什么时候被创建？</p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
</li>
</ul>
<p><strong>举例1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/30/67725cfb30449.webp" alt="image-20241230164234976"></p>
<p><strong>举例2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/30/67725d08d6afe.webp" alt="image-20241230164248874"></p>
<p>Dog虚方法表:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/30/67725d10152be.webp" alt="image-20241230164256084"></p>
<p>CockerSpaniel虚方法表:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/30/67725d25d16b3.webp" alt="image-20241230164317805"></p>
<p>Cat虚方法表:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/30/67725d30a3bd1.webp" alt="image-20241230164328620"></p>
<h3 id="3-3-4、方法返回地址"><a href="#3-3-4、方法返回地址" class="headerlink" title="3.3.4、方法返回地址"></a>3.3.4、方法返回地址</h3><ul>
<li>存放调用该方法的pc寄存器的值。</li>
<li>一个方法的结束，有两种方式：<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<p>1、执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，<strong>简称正常完成出口</strong>；</p>
<ul>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li>
</ul>
<p>2、在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</p>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception table:</span><br><span class="line">from to   target  <span class="built_in">type</span></span><br><span class="line">4    16   19      any</span><br><span class="line">19   21   19      any</span><br></pre></td></tr></tbody></table></figure>

<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
<h3 id="3-3-5、一些附加信息"><a href="#3-3-5、一些附加信息" class="headerlink" title="3.3.5、一些附加信息"></a>3.3.5、一些附加信息</h3><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>
<h2 id="3-4、问题小结与拓展"><a href="#3-4、问题小结与拓展" class="headerlink" title="3.4、问题小结与拓展"></a>3.4、问题小结与拓展</h2><h3 id="问题一：栈溢出的情况"><a href="#问题一：栈溢出的情况" class="headerlink" title="问题一：栈溢出的情况?"></a>问题一：栈溢出的情况?</h3><p>栈溢出:StackOverflowError;<br>举个简单的例子:在main方法中调用main方法,就会不断压栈执行,直到栈溢出;<br>栈的大小可以是固定大小的,也可以是动态变化（动态扩展）的。<br>如果是固定的,可以通过-Xss设置栈的大小;<br>如果是动态变化的,当栈大小到达了整个内存空间不足了,就是抛出OutOfMemory异常(java.lang.OutOfMemoryError)</p>
<h3 id="问题二：调整栈大小-就能保证不出现溢出吗"><a href="#问题二：调整栈大小-就能保证不出现溢出吗" class="headerlink" title="问题二：调整栈大小,就能保证不出现溢出吗?"></a>问题二：调整栈大小,就能保证不出现溢出吗?</h3><p>不能。因为调整栈大小,只会减少出现溢出的可能,栈大小不是可以无限扩大的,所以不能保证不出现溢出</p>
<h3 id="问题三：分配的栈内存越大越好吗"><a href="#问题三：分配的栈内存越大越好吗" class="headerlink" title="问题三：分配的栈内存越大越好吗?"></a>问题三：分配的栈内存越大越好吗?</h3><p>不是,因为增加栈大小，会造成每个线程的栈都变的很大,使得一定的栈空间下,能创建的线程数量会变小</p>
<h3 id="问题四：垃圾回收是否会涉及到虚拟机栈"><a href="#问题四：垃圾回收是否会涉及到虚拟机栈" class="headerlink" title="问题四：垃圾回收是否会涉及到虚拟机栈?"></a>问题四：垃圾回收是否会涉及到虚拟机栈?</h3><p>不会;垃圾回收只会涉及到方法区和堆中,方法区和堆也会存在溢出的可能;<br>程序计数器,只记录运行下一行的地址,不存在溢出和垃圾回收;<br>虚拟机栈和本地方法栈,都是只涉及压栈和出栈,可能存在栈溢出,不存在垃圾回收。</p>
<h3 id="问题五：方法中定义的局部变量是否线程安全"><a href="#问题五：方法中定义的局部变量是否线程安全" class="headerlink" title="问题五：方法中定义的局部变量是否线程安全?"></a>问题五：方法中定义的局部变量是否线程安全?</h3><p>具体问题具体分析,见分析代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**方法中定义的局部变量是否线程安全?   具体问题具体分析</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 15:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariableThreadSafe</span> {</span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的,因为线程私有，在线程内创建的s1 ，不会被其它线程调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stringBuilder的操作过程：是线程不安全的，</span></span><br><span class="line">    <span class="comment">// 因为stringBuilder是外面传进来的，有可能被多个线程调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder stringBuilder)</span> {</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stringBuilder的操作：是线程不安全的；因为返回了一个stringBuilder，</span></span><br><span class="line">    <span class="comment">// stringBuilder有可能被其他线程共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stringBuilder的操作：是线程安全的；因为返回了一个stringBuilder.toString()相当于new了一个String，</span></span><br><span class="line">    <span class="comment">// 所以stringBuilder没有被其他线程共享的可能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 结论：如果局部变量在内部产生并在内部消亡的，那就是线程安全的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="4、本地方法接口与本地方法栈"><a href="#4、本地方法接口与本地方法栈" class="headerlink" title="4、本地方法接口与本地方法栈"></a>4、本地方法接口与本地方法栈</h1><h2 id="4-1、什么是本地方法"><a href="#4-1、什么是本地方法" class="headerlink" title="4.1、什么是本地方法?"></a>4.1、什么是本地方法?</h2><blockquote>
<p> “A native method is a Java method whose implementation is provided by non-java code.”</p>
</blockquote>
<p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接口</strong>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个C的函数。</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合 C/C++程序。</p>
<p><strong>举例1：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span>{</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">methodNative1</span><span class="params">( <span class="type">int</span> x )</span> ;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">methodNative2</span><span class="params">()</span> ;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">methodNative3</span><span class="params">( Object o )</span> ;</span><br><span class="line">      <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">methodNative4</span><span class="params">( <span class="type">int</span>[] ary )</span> <span class="keyword">throws</span> Exception ;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<p><strong>举例2：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.currentTimeMillis()</span><br></pre></td></tr></tbody></table></figure>

<p><strong>举例3：</strong></p>
<p>Thread类的start()内部。</p>
<p><strong>标识符native可以与所有其它的java标识符连用，但是abstract除外。</strong></p>
<h2 id="4-2、为什么要使用Native-Method？"><a href="#4-2、为什么要使用Native-Method？" class="headerlink" title="4.2、为什么要使用Native Method？"></a>4.2、为什么要使用Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<p><strong>与Java环境外交互</strong>：</p>
<p><strong>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。</strong>你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>
<p><strong>与操作系统交互</strong>：<br>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<p><strong>Sun’s Java</strong><br>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p>
<h2 id="4-3、本地方法现状"><a href="#4-3、本地方法现状" class="headerlink" title="4.3、本地方法现状?"></a>4.3、本地方法现状?</h2><p><strong>目前该方法使用的越来越少了，除非是与硬件有关的应用</strong>，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<h2 id="4-4、本地方法栈"><a href="#4-4、本地方法栈" class="headerlink" title="4.4、本地方法栈"></a>4.4、本地方法栈</h2><ul>
<li><p><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</strong></p>
</li>
<li><p>本地方法栈，也是线程私有的。</p>
</li>
<li><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 OutOfMemoryError 异常。</li>
</ul>
</li>
<li><p>本地方法是使用C语言实现的。</p>
</li>
<li><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/01/6774f72c8b3a7.webp" alt="image-20250101160501386"></p>
</li>
<li><p><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限</strong>。</p>
<ul>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
</li>
<li><p><strong>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等</strong>。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p>
</li>
</ul>
<h1 id="5、堆"><a href="#5、堆" class="headerlink" title="5、堆"></a>5、堆</h1><h2 id="5-1、核心概述"><a href="#5-1、核心概述" class="headerlink" title="5.1、核心概述"></a>5.1、核心概述</h2><ul>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li>
<li>Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</li>
<li>堆内存的大小是可以调节的。</li>
<li>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续</strong>的内存空间中，但在<strong>逻辑上</strong>它应该被视为<strong>连续的</strong>。</li>
<li>堆，是GC ( Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li>
</ul>
<h3 id="5-1-1、对象都分配在堆上？"><a href="#5-1-1、对象都分配在堆上？" class="headerlink" title="5.1.1、对象都分配在堆上？"></a>5.1.1、对象都分配在堆上？</h3><ul>
<li><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated ) 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
</li>
<li><p>说的是：“几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。</p>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHeap</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleHeap</span><span class="params">(<span class="type">int</span> id)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"My ID is "</span> + id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/01/6774f9fa3aaf1.webp" alt="image-20250101161700300"></p>
</li>
</ul>
<h3 id="5-2-2、所有的线程都共享堆？"><a href="#5-2-2、所有的线程都共享堆？" class="headerlink" title="5.2.2、所有的线程都共享堆？"></a>5.2.2、所有的线程都共享堆？</h3><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer, TLAB)。</p>
<h2 id="5-2、堆的内部结构"><a href="#5-2、堆的内部结构" class="headerlink" title="5.2、堆的内部结构"></a>5.2、堆的内部结构</h2><blockquote>
<p>面试题：<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor（字节跳动）<br>堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。（京东-物流）<br>堆的结构？为什么两个survivor区？  (蚂蚁金服)<br>JVM的内存结构，Eden和Survivor比例。  (京东)</p>
</blockquote>
<p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/01/6774faca99569.webp" alt="image-20250101162028794"></p>
<p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+<strong>永久区</strong></p>
<ul>
<li>Young Generation Space   新生区      Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space  养老区      Old/Tenure</li>
<li>Permanent Space          永久区      Perm</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/01/6774fb5b558c7.webp" alt="image-20250101162253450"></p>
<p>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+<strong>元空间</strong></p>
<ul>
<li>Young Generation Space    新生区      Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space   养老区      Old/Tenure</li>
<li>Meta Space                元空间      Meta</li>
</ul>
<p><strong>约定：</strong><br>新生区&lt;=&gt;新生代&lt;=&gt;年轻代  </p>
<p>养老区&lt;=&gt;老年区&lt;=&gt;老年代  </p>
<p>永久区&lt;=&gt;永久代</p>
<p><strong>年轻代与老年代：</strong></p>
<ul>
<li><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</li>
</ul>
</li>
<li><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）</p>
</li>
<li><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/01/6774fce441ab6.webp" alt="image-20250101162926420"></p>
</li>
<li><p><strong>几乎所有</strong>的Java对象都是在Eden区被new出来的。</p>
</li>
<li><p>绝大部分的Java对象的销毁都在新生代进行了。</p>
<ul>
<li>IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。</li>
</ul>
</li>
</ul>
<h2 id="5-3、如何设置堆内存大小？"><a href="#5-3、如何设置堆内存大小？" class="headerlink" title="5.3、如何设置堆内存大小？"></a>5.3、如何设置堆内存大小？</h2><blockquote>
<p>面试题</p>
<ul>
<li>堆大小通过什么参数设置？  (阿里)</li>
<li>初始堆大小和最大堆大小一样，问这样有什么好处？（亚信）</li>
<li>JVM中最大堆大小有没有限制？ (阿里)</li>
</ul>
</blockquote>
<ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。<ul>
<li>“-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize</li>
<li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
</ul>
</li>
<li>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError:heap异常。</li>
<li>通常会将 -Xms 和 -Xmx两个参数配置相同的值，其<strong>目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</li>
<li>heap默认最大值计算方式：如果物理内存少于192M,那么heap最大值为物理内存的一半。如果物理内存大于等于1G，<strong>那么heap的最大值为物理内存的1/4</strong>。</li>
<li>heap默认最小值计算方式：最少不得少于8M，如果物理内存大于等于1G，那么<strong>默认值为物理内存的1/64</strong>，即1024/64=16M。最小堆内存在jvm启动的时候就会被初始化。</li>
</ul>
<blockquote>
<p>关于堆空间的大小，从官网取下来说明：<br>On Oracle Solaris 7 and Oracle Solaris 8 SPARC platforms, the upper limit for this value is approximately 4,000 MB minus overhead amounts. On Oracle Solaris 2.6 and x86 platforms, the upper limit is approximately 2,000 MB minus overhead amounts. On Linux platforms, the upper limit is approximately 2,000 MB minus overhead amounts.</p>
</blockquote>
<p>另：对于32位虚拟机，如果物理内存等于4G，那么堆内存可以达到1G。对于64位虚拟机，如果物理内存为128G，那么heap最多可以达到32G。</p>
<h3 id="5-3-1、如何设置新生代与老年代比例？"><a href="#5-3-1、如何设置新生代与老年代比例？" class="headerlink" title="5.3.1、如何设置新生代与老年代比例？"></a>5.3.1、如何设置新生代与老年代比例？</h3><p>下面这参数开发中一般不会调：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/01/677500798f02b.webp" alt="image-20250101164443733"></p>
<ul>
<li><p>配置新生代与老年代在堆结构的占比。</p>
<ul>
<li><p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67765b49ce9de.webp" alt="image-20250102172424781"></p>
</li>
<li><p>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p>
</li>
</ul>
</li>
<li><p>可以使用选项”**-Xmn**”设置新生代最大内存大小</p>
<ul>
<li>这个参数一般使用默认值就可以了。</li>
</ul>
</li>
</ul>
<h3 id="5-3-2、如何设置Eden、幸存者区比例？"><a href="#5-3-2、如何设置Eden、幸存者区比例？" class="headerlink" title="5.3.2、如何设置Eden、幸存者区比例？"></a>5.3.2、如何设置Eden、幸存者区比例？</h3><ul>
<li><p>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1</p>
</li>
<li><p>当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67765d2f037ec.webp" alt="image-20250102173230838"></p>
</li>
</ul>
<h3 id="5-3-3、OOM举例"><a href="#5-3-3、OOM举例" class="headerlink" title="5.3.3、OOM举例"></a>5.3.3、OOM举例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试OOM</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  21:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Picture&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Picture</span><span class="params">(<span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="built_in">this</span>.pixels = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>IDEA配置：</strong></p>
<p>鼠标右键 -&gt; More Run/Debug -&gt; Modify Run Configuration…</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776626ea7450.webp" alt="image-20250102175454122"></p>
<p>也可以通过 Run -&gt; Edit Configurations… 进行设置，选择当前正在运行的JAVA程序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677665c0eda0d.webp" alt="image-20250102180904780"></p>
<p>添加VM配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677664597bfc6.webp" alt="image-20250102180305221"></p>
<p><strong>VisualVM插件安装:</strong></p>
<p>Tools -&gt; Plugins</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776632652cac.webp" alt="image-20250102175758203"></p>
<p>Available Plugine 找到 Visual Gc -&gt; Install，按照后重启即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677662e61b9e7.webp" alt="image-20250102175653939"></p>
<p>运行JAVA程序，监控内存状态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677664be09fe9.webp" alt="image-20250102180445715"></p>
<p>可以看到，Eden区和Survivor的比例不是默认的8：1：1，而是6：1：1，可通过添加<code>-XX:SurvivorRatio=8</code>参数进行调整。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776671cbf59c.webp" alt="image-20250102181451493"></p>
<p>调整后如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776673569865.webp" alt="image-20250102181517222"></p>
<p>报错如下：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/01/677501f943c81.webp" alt="image-20250101165107420"></p>
<h3 id="5-3-4、参数设置小结"><a href="#5-3-4、参数设置小结" class="headerlink" title="5.3.4、参数设置小结"></a>5.3.4、参数设置小结</h3><blockquote>
<p>面试题：什么是空间分配担保策略？</p>
</blockquote>
<h4 id="Xms-Xmx"><a href="#Xms-Xmx" class="headerlink" title="-Xms -Xmx"></a><strong>-Xms -Xmx</strong></h4><p>堆空间大小的设置：<br>-Xms:初始内存 （默认为物理内存的1/64）；<br>-Xmx:最大内存（默认为物理内存的1/4）；</p>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms10m -Xmx10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 上午 10:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"atguigu"</span>;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line"></span><br><span class="line">                str +=  UUID.randomUUID().toString();</span><br><span class="line">                list.add(str);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>报错如下：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/01/677502a53b04f.webp" alt="image-20250101165359148"></p>
<h4 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h4><p>设置新生代的大小。(初始值及最大值)<br>通常默认即可。</p>
<h4 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h4><p>配置新生代与老年代在堆结构的占比。赋的值即为老年代的占比，剩下的1给新生代<br>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3<br>-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p>
<h4 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h4><ul>
<li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8：1</li>
<li>开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8</li>
</ul>
<h4 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h4><ul>
<li>设置新生代垃圾的最大年龄。超过此值，仍未被回收的话，则进入老年代。</li>
<li>默认值为15</li>
<li>-XX:MaxTenuringThreshold=0：表示年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。</li>
<li>如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率。</li>
</ul>
<h4 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h4><p>输出详细的GC处理日志</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/01/677503f704a43.webp" alt="image-20250101165937204"></p>
<p>显示如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9728K, used 2497K [0x00000000fd580000, 0x00000000fe000000, 0x0000000100000000)</span><br><span class="line">  eden space 8704K, 28% used [0x00000000fd580000,0x00000000fd7f06e8,0x00000000fde00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000000fdf00000,0x00000000fdf00000,0x00000000fe000000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fde00000,0x00000000fde00000,0x00000000fdf00000)</span><br><span class="line"> ParOldGen       total 22016K, used 0K [0x00000000f8000000, 0x00000000f9580000, 0x00000000fd580000)</span><br><span class="line">  object space 22016K, 0% used [0x00000000f8000000,0x00000000f8000000,0x00000000f9580000)</span><br><span class="line"> Metaspace       used 3511K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 388K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></tbody></table></figure>

<h4 id="XX-HandlePromotionFailure"><a href="#XX-HandlePromotionFailure" class="headerlink" title="-XX:HandlePromotionFailure"></a>-XX:HandlePromotionFailure</h4><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。</li>
<li>如果HandlePromotionFailure =true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</li>
</ul>
<p>在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>
<h4 id="XX-PrintFlagsFinal"><a href="#XX-PrintFlagsFinal" class="headerlink" title="-XX:+PrintFlagsFinal"></a>-XX:+PrintFlagsFinal</h4><p>查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>
<p>具体查看某个参数的指令： jps：查看当前运行中的进程<br>                      jinfo -flag SurvivorRatio 进程id</p>
<h2 id="5-4、对象分配金句"><a href="#5-4、对象分配金句" class="headerlink" title="5.4、对象分配金句"></a>5.4、对象分配金句</h2><blockquote>
<p>面试题：</p>
<ul>
<li>什么时候对象会进入老年代？（渣打银行）</li>
<li>JVM的伊甸园区，from区，to区的比例是否可调？（花旗银行）</li>
<li>JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代（字节跳动）</li>
<li>对象在堆内存创建的生命周期  (蚂蚁金服)</li>
<li>重点讲讲对象如何晋升到老年代，几种主要的JVM参数  (蚂蚁金服)</li>
<li>新生代和老年代的内存回收策略 (蚂蚁金服)</li>
<li>什么时候对象可以被收回？ (蚂蚁金服)</li>
</ul>
</blockquote>
<p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p><strong>金句：</strong></p>
<ul>
<li><font color="red">针对幸存者s0,s1区的总结：复制之后有交换，谁空谁是to.</font></li>
<li><font color="red">关于垃圾回收：</font><ul>
<li><font color="red">频繁在新生区收集</font></li>
<li><font color="red">很少在养老区收集</font></li>
<li><font color="red">几乎不在永久区/元空间收集</font></li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6775f58b3c760.webp" alt="image-20250102101019119"></p>
<h3 id="5-4-1、过程剖析"><a href="#5-4-1、过程剖析" class="headerlink" title="5.4.1、过程剖析"></a>5.4.1、过程剖析</h3><ol>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/YGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是15次。<ul>
<li><strong>可以设置参数：-XX:MaxTenuringThreshold=&lt;N&gt; 设置对象晋升老年代的年龄阈值。</strong></li>
</ul>
</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</li>
<li>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常<ul>
<li><strong>java.lang.OutOfMemoryError: Java heap space</strong></li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6775f7ec4541c.webp" alt="image-20250102102028099"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6775f80e86ae9.webp" alt="image-20250102102102590"></p>
<p><strong>内存分配策略（或对象提升(promotion)规则):</strong></p>
<p>如果对象在Eden 出生并经过第一次MinorGC 后仍然存活，并且能被Survivor 容纳的话，将被移动到Survivor 空间中，并将对象年龄设为1 。对象在Survivor 区中每熬过一次MinorGC ， 年龄就增加1岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p>
<h3 id="5-4-2、内存分配原则"><a href="#5-4-2、内存分配原则" class="headerlink" title="5.4.2、内存分配原则"></a>5.4.2、内存分配原则</h3><p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代 <ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保<ul>
<li>-XX:HandlePromotionFailure</li>
</ul>
</li>
</ul>
<h3 id="5-4-3、代码举例"><a href="#5-4-3、代码举例" class="headerlink" title="5.4.3、代码举例"></a>5.4.3、代码举例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m -XX:SurvivorRatio=8 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021  17:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapInstanceTest</span> {</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HeapInstanceTest&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HeapInstanceTest</span>());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-5、解释MinorGC、MajorGC、FullGC"><a href="#5-5、解释MinorGC、MajorGC、FullGC" class="headerlink" title="5.5、解释MinorGC、MajorGC、FullGC"></a>5.5、解释MinorGC、MajorGC、FullGC</h2><blockquote>
<p>面试题：</p>
<ul>
<li>Minor GC 与 Full GC 分别在什么时候发生？（腾讯）</li>
<li>老年代的垃圾回收机制什么时候触发，自动触发的阈值是多少（蚂蚁金服）</li>
<li>简述 Java 内存分配与回收策略以及 Minor GC 和Major GC（国美）</li>
<li>JVM的一次完整的GC流程（从ygc到fgc)是怎样的(蚂蚁金服)</li>
</ul>
</blockquote>
<p>JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代；方法区)区域一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：</p>
<ul>
<li>一种是部分收集（Partial GC）</li>
<li>一种是整堆收集（Full GC）</li>
<li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（Minor GC / Young GC）：只是新生代（Eden\S0,S1）的垃圾收集</li>
<li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为。</li>
<li><strong>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></li>
</ul>
</li>
<li>混合收集（Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（Full GC)：收集整个java堆和方法区的垃圾收集。</li>
</ul>
<h3 id="5-5-1、MinorGC触发机制"><a href="#5-5-1、MinorGC触发机制" class="headerlink" title="5.5.1、MinorGC触发机制"></a>5.5.1、MinorGC触发机制</h3><p><strong>年轻代GC(Minor GC)触发机制</strong>：</p>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC。这里的<strong>年轻代满指的是Eden区满</strong>，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)</li>
<li>因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6775fc41c615e.webp" alt="image-20250102103857747"></p>
<h3 id="5-5-2、MajorGC触发机制"><a href="#5-5-2、MajorGC触发机制" class="headerlink" title="5.5.2、MajorGC触发机制"></a>5.5.2、MajorGC触发机制</h3><p><strong>老年代GC（Major GC/Full GC）触发机制：</strong></p>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。<ul>
<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。</li>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC<br>Major GC的速度一般会比Minor GC慢10倍以上，STW（Stop-The-World）的时间更长,STW（Stop-The-World）是指 JVM 在执行某些特定操作时，暂停所有应用线程的现象。STW 期间，应用程序的所有线程都会停止执行，直到 JVM 完成相关操作。STW 通常发生在垃圾回收（GC）过程中，但也可能在其他情况下出现。</li>
</ul>
</li>
<li>如果Major GC 后，内存还不足，就报OOM了。</li>
</ul>
<h3 id="5-5-3、FullGC触发机制"><a href="#5-5-3、FullGC触发机制" class="headerlink" title="5.5.3、FullGC触发机制"></a>5.5.3、FullGC触发机制</h3><p><strong>Full GC触发机制：</strong></p>
<p>触发Full GC 执行的情况有如下五种：<br>（1）调用<code>System.gc()</code>时，系统建议执行Full GC，但是不必然执行<br>（2）老年代空间不足<br>（3）方法区空间不足<br>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br>（5）由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小<br><strong>说明：full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。</strong></p>
<h3 id="5-5-4、代码举例"><a href="#5-5-4、代码举例" class="headerlink" title="5.5.4、代码举例"></a>5.5.4、代码举例</h3><p><strong>代码举例1：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"www.atguigu.com"</span>;</span><br><span class="line">        <span class="comment">//将参数调整的小一些，这样问题会出现的比较早。</span></span><br><span class="line">        <span class="comment">// -Xms8m -Xmx8m -XX:+PrintGCDetails</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            str += str + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">88888888</span>) +</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">999999999</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码举例2:</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试MinorGC 、 MajorGC、FullGC</span></span><br><span class="line"><span class="comment"> * -Xms10m -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">"atguigu.com"</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"遍历次数为："</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-6、OOM如何解决"><a href="#5-6、OOM如何解决" class="headerlink" title="5.6、OOM如何解决"></a>5.6、OOM如何解决</h2><p>1、要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<p>2、如果是<strong>内存泄漏</strong>，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地<strong>定位出泄漏代码的位置</strong>。</p>
<p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查<strong>是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗</strong>。</p>
<h2 id="5-7、堆空间分代思想"><a href="#5-7、堆空间分代思想" class="headerlink" title="5.7、堆空间分代思想"></a>5.7、堆空间分代思想</h2><blockquote>
<p><strong>为什么需要把Java堆分代？不分代就不能正常工作了吗？</strong></p>
<p>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
</blockquote>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有Eden、两块大小相同的Survivor(又称为from/to，s0/s1)构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<p>JDK7:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6775ff1f8d9f4.webp" alt="image-20250102105111568"></p>
<p>JDK8：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6775ff2e402f0.webp" alt="image-20250102105126347"></p>
<h3 id="5-5-5、快速分配策略：TLAB"><a href="#5-5-5、快速分配策略：TLAB" class="headerlink" title="5.5.5、快速分配策略：TLAB"></a>5.5.5、快速分配策略：TLAB</h3><p><strong>为什么有TLAB（Thread Local Allocation Buffer）？</strong></p>
<ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<p>所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</p>
<p><strong>什么是TLAB？</strong></p>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM<strong>为每个线程分配了一个私有缓存区域</strong>，它包含在Eden空间内。</li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776006dac096.webp" alt="image-20250102105645684"></p>
<p><strong>TLAB的再说明：</strong></p>
<ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</li>
<li>在程序中，开发人员可以通过选项“**-XX:+/-UseTLAB**”设置是否开启TLAB空间。</li>
<li>默认情况下，TLAB空间的内存非常小，<strong>仅占有整个Eden空间的1%<strong>，当然我们可以通过选项“</strong>-XX:TLABWasteTargetPercent</strong>”设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677600ed5c4b0.webp" alt="image-20250102105853400"></p>
<h1 id="6、方法区"><a href="#6、方法区" class="headerlink" title="6、方法区"></a>6、方法区</h1><h2 id="6-1、栈、堆、方法区的关系"><a href="#6-1、栈、堆、方法区的关系" class="headerlink" title="6.1、栈、堆、方法区的关系"></a>6.1、栈、堆、方法区的关系</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677601c4a993c.webp" alt="image-20250102110228279"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677601eeeb722.webp" alt="image-20250102110310940"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67760201504d4.webp" alt="image-20250102110329334"></p>
<h2 id="6-2、方法区在哪里？"><a href="#6-2、方法区在哪里？" class="headerlink" title="6.2、方法区在哪里？"></a>6.2、方法区在哪里？</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776026151fcb.webp" alt="image-20250102110505390"></p>
<p>《Java虚拟机规范》中明确说明: “尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。” 但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。</p>
<p>所以，方法区看作是一块独立于Java 堆的内存空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67760267e2307.webp" alt="image-20250102110511976"></p>
<h2 id="6-3、方法区的理解"><a href="#6-3、方法区的理解" class="headerlink" title="6.3、方法区的理解"></a>6.3、方法区的理解</h2><p>从线程共享与否的角度来看</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677602e0f0bab.webp" alt="image-20250102110712895"></p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: <strong>PermGen space</strong> 或者 java.lang.OutOfMemoryError: <strong>Metaspace</strong><ul>
<li><strong>加载大量的第三方的jar包；Tomcat部署的工程过多（30-50个）；大量动态的生成反射类</strong></li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h2 id="6-4、HotSpot中方法区的演进"><a href="#6-4、HotSpot中方法区的演进" class="headerlink" title="6.4、HotSpot中方法区的演进"></a>6.4、HotSpot中方法区的演进</h2><ul>
<li><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677603a9c7dbb.webp" alt="image-20250102111033897"></p>
</li>
<li><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit/ IBM J9中不存在永久代的概念。</p>
<ul>
<li><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX:MaxPermSize上限）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677603f682ce5.webp" alt="image-20250102111150584"></p>
</li>
</ul>
</li>
<li><p>而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776042f50e8b.webp" alt="image-20250102111247379"></p>
</li>
<li><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</p>
</li>
<li><p>永久代、元空间二者并不只是名字变了，内部结构也调整了。</p>
</li>
<li><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</p>
</li>
</ul>
<h2 id="6-5、方法区常用参数有哪些？"><a href="#6-5、方法区常用参数有哪些？" class="headerlink" title="6.5、方法区常用参数有哪些？"></a>6.5、方法区常用参数有哪些？</h2><p><strong>设置方法区内存的大小</strong></p>
<ul>
<li><p>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。</p>
</li>
<li><p>jdk7及以前：</p>
<ul>
<li><p><strong>通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</strong></p>
</li>
<li><p><strong>-XX:MaxPermSize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</strong></p>
</li>
<li><p>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677604f66e79f.webp" alt="image-20250102111606554"></p>
</li>
</ul>
</li>
<li><p>jdk8及以后：</p>
<ul>
<li>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定,替代上述原有的两个参数。</li>
<li>默认值依赖于平台。<strong>windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize 的值是-1，即没有限制。</strong></li>
<li>与永久代不同，<strong>如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Metaspace</strong></li>
<li>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC ，建议将-XX:MetaspaceSize设置为一个相对较高的值。</li>
</ul>
</li>
</ul>
<p>在JDK8 及以上版本中，设定MaxPermSize 参数， JVM在启动时并不会报错，但是会提示：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot 64Bit Server VM warning:</span><br><span class="line">ignoring option MaxPermSize=2560m; support was removed <span class="keyword">in</span> 8.0 。</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677605921df88.webp" alt="image-20250102111842190"></p>
<p><strong>代码举例</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021  22:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，public,类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">"Class"</span> + i, <span class="literal">null</span>, <span class="string">"java/lang/Object"</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">"Class"</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//CLass对象</span></span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-6、方法区都存什么？"><a href="#6-6、方法区都存什么？" class="headerlink" title="6.6、方法区都存什么？"></a>6.6、方法区都存什么？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762aa1723f2.webp" alt="image-20250102135648722"></p>
<p>《深入理解Java 虚拟机》书中对方法区（Method Area）存储内容描述如下：<br>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762b085ed8c.webp" alt="image-20250102135832578"></p>
<h3 id="6-6-1、类型信息"><a href="#6-6-1、类型信息" class="headerlink" title="6.6.1、类型信息"></a>6.6.1、类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：<br>① 这个类型的完整有效名称（全名=包名.类名）<br>② 这个类型直接父类的完整有效名(对于interface或是java.lang.Object，都没有父类)<br>③ 这个类型的修饰符(public,abstract, final的某个子集)<br>④ 这个类型直接接口的一个有序列表 </p>
<h3 id="6-6-2、域-Field-信息"><a href="#6-6-2、域-Field-信息" class="headerlink" title="6.6.2、域(Field)信息"></a>6.6.2、域(Field)信息</h3><ul>
<li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li>
<li>域的相关信息包括： 域名称、域类型、域修饰符(public, private, protected, static, final, volatile, transient的某个子集)</li>
</ul>
<h3 id="6-6-3、方法-Method-信息"><a href="#6-6-3、方法-Method-信息" class="headerlink" title="6.6.3、方法(Method)信息"></a>6.6.3、方法(Method)信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序 ：</p>
<ul>
<li>方法名称 </li>
<li>方法的返回类型(或 void)</li>
<li>方法参数的数量和类型(按顺序)</li>
<li>方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)</li>
<li>方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<p><strong>代码举例一：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchOne</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        tryIt();</span><br><span class="line">    } <span class="keyword">catch</span> (MyExc e) {</span><br><span class="line">        handleExc(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译后，如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void catchOne();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokevirtual <span class="comment">#2                  // Method tryIt:()V</span></span><br><span class="line">         4: goto          13</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: aload_0</span><br><span class="line">         9: aload_1</span><br><span class="line">        10: invokevirtual <span class="comment">#4                  // Method handleExc:(Ljava/lang/Exception;)V</span></span><br><span class="line">        13: <span class="built_in">return</span></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception table:</span><br><span class="line">       from    to  target <span class="built_in">type</span></span><br><span class="line">           0     4     7   Class com/atguigu/java/MethodInnerTest<span class="variable">$MyExc</span></span><br></pre></td></tr></tbody></table></figure>

<p>代码举例二：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"测试方法的内部结构"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"count = "</span> + count);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> cal)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-6-4、non-final的类变量"><a href="#6-6-4、non-final的类变量" class="headerlink" title="6.6.4、non-final的类变量"></a>6.6.4、non-final的类变量</h3><ul>
<li>静态变量和类关联在一起，随着类的加载而加载,它们成为类数据在逻辑上的一部分。</li>
<li>类变量被类的所有实例共享，即使没有类实例时你也可以访问它。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>补充说明：全局常量：static final</strong></p>
<p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p>
<h3 id="6-6-5、运行时常量池"><a href="#6-6-5、运行时常量池" class="headerlink" title="6.6.5、运行时常量池"></a>6.6.5、运行时常量池</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762cca50d72.webp" alt="image-20250102140602347"></p>
<ul>
<li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
</li>
<li><p>常量池表（Constant Pool Table）是Class文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用</strong>，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</p>
</li>
<li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
</li>
<li><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过<strong>索引访问</strong>的。</p>
</li>
<li><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p>
<ul>
<li><p>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。</p>
<p>String.intern()</p>
</li>
</ul>
</li>
<li><p>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</p>
</li>
<li><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</p>
</li>
</ul>
<h4 id="6-6-5-1、关联：常量池"><a href="#6-6-5-1、关联：常量池" class="headerlink" title="6.6.5.1、关联：常量池"></a>6.6.5.1、关联：常量池</h4><ul>
<li>方法区，内部包含了运行时常量池。</li>
<li>字节码文件，内部包含了常量池。</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html%E3%80%82%E5%A6%82%E4%B8%8B%EF%BC%9A">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html。如下：</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762df6bcca9.webp" alt="image-20250102141102602"></p>
</blockquote>
<p> 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762e15042c6.webp" alt="image-20250102141133111"></p>
<p><strong>小结：</strong><br>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h4 id="6-6-5-2、为什么需要常量池？"><a href="#6-6-5-2、为什么需要常量池？" class="headerlink" title="6.6.5.2、为什么需要常量池？"></a>6.6.5.2、为什么需要常量池？</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。</p>
<p>比如：如下的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>虽然只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里代码量其实已经很小了。如果代码多，引用到的结构会更多！这里就需要常量池了！</p>
<h4 id="6-6-5-3、常量池都有什么？"><a href="#6-6-5-3、常量池都有什么？" class="headerlink" title="6.6.5.3、常量池都有什么？"></a>6.6.5.3、常量池都有什么？</h4><p>几种在常量池内存储的数据类型包括：</p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>例如下面这段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中代码：Object foo = new Object();将会被编译成如下字节码：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:      new <span class="comment">#2               // Class java/lang/Object</span></span><br><span class="line">1:      dup</span><br><span class="line">2:      invokespecial <span class="comment">#3    // Method java/ lang/Object “&lt;init&gt;”( ) V</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-7、方法区使用举例"><a href="#6-7、方法区使用举例" class="headerlink" title="6.7、方法区使用举例"></a>6.7、方法区使用举例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  14:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762f8006501.webp" alt="image-20250102141736020"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762f92ce16f.webp" alt="image-20250102141754873"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762fa28cf3e.webp" alt="image-20250102141810651"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762fb1ab08d.webp" alt="image-20250102141825794"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762fbfb2c06.webp" alt="image-20250102141839795"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762fcf9949e.webp" alt="image-20250102141855698"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762fdfdb5d6.webp" alt="image-20250102141911988"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762fec422c8.webp" alt="image-20250102141924364"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67762ffb7cd65.webp" alt="image-20250102141939564"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677630099b7cd.webp" alt="image-20250102141953700"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67763015f0a7d.webp" alt="image-20250102142006077"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677630213f807.webp" alt="image-20250102142017348"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776302dc4227.webp" alt="image-20250102142029852"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776303a623c6.webp" alt="image-20250102142042509"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67763049d0e92.webp" alt="image-20250102142057862"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67763057e094e.webp" alt="image-20250102142111991"></p>
<h2 id="6-8、永久代与元空间"><a href="#6-8、永久代与元空间" class="headerlink" title="6.8、永久代与元空间"></a>6.8、永久代与元空间</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p>
</blockquote>
<p>1、首先明确：只有HotSpot才有永久代。<br>BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677630b35ae33.webp" alt="image-20250102142243540"></p>
<p>2、HotSpot中永久代的变化<br><strong>jdk1.6及之前</strong>：有永久代(permanent generation)<br><strong>jdk1.7</strong>：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中<br><strong>jdk1.8及之后</strong>： 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池仍在堆</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677630e5bd897.webp" alt="image-20250102142333961"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677630ee04ac2.webp" alt="image-20250102142342224"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677630f595a39.webp" alt="image-20250102142349755"></p>
<h2 id="6-9、方法区是否存在GC？回收什么？"><a href="#6-9、方法区是否存在GC？回收什么？" class="headerlink" title="6.9、方法区是否存在GC？回收什么？"></a>6.9、方法区是否存在GC？回收什么？</h2><blockquote>
<p>面试题：JVM的永久代中会发生垃圾回收么?（腾讯）</p>
</blockquote>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。</p>
<p>一般来说<strong>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</strong>。但是这部分区域的回收<strong>有时又确实是必要的</strong>。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</strong></p>
<ul>
<li>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：<ul>
<li>1、类和接口的全限定名</li>
<li>2、字段的名称和描述符</li>
<li>3、方法的名称和描述符</li>
</ul>
</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</li>
<li>回收废弃常量与回收Java堆中的对象非常类似。</li>
<li>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： <ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 </li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 </li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
<li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及**-XX:+TraceClassLoading -XX:+TraceClassUnloading查看类加载和卸载信息**</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，<strong>通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</strong>。</li>
</ul>
<h2 id="6-10、内存结构小结"><a href="#6-10、内存结构小结" class="headerlink" title="6.10、内存结构小结"></a>6.10、内存结构小结</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677632af294b7.webp" alt="image-20250102143111176"></p>
<h1 id="7、直接内存"><a href="#7、直接内存" class="headerlink" title="7、直接内存"></a>7、直接内存</h1><h2 id="7-1、概述"><a href="#7-1、概述" class="headerlink" title="7.1、概述"></a>7.1、概述</h2><ul>
<li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li>
<li>直接内存是在Java堆外的、直接向系统申请的内存区间。</li>
<li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li>
<li>通常，访问直接内存的速度会优于Java堆。即读写性能高。<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>
<li><strong>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</strong></li>
</ul>
</li>
</ul>
<h2 id="7-2、非直接缓冲区vs直接缓冲区"><a href="#7-2、非直接缓冲区vs直接缓冲区" class="headerlink" title="7.2、非直接缓冲区vs直接缓冲区"></a>7.2、非直接缓冲区vs直接缓冲区</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677633a1b7838.webp" alt="image-20250102143513862"></p>
<p>读写文件，需要与磁盘交互，需要由用户态切换到内核态。<br>使用IO,见上图。这里需要两份内存存储重复数据，效率低。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677633cd36630.webp" alt="image-20250102143557283"></p>
<p>使用NIO时，如上图。操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。</p>
<h2 id="7-3、大小设置方式"><a href="#7-3、大小设置方式" class="headerlink" title="7.3、大小设置方式"></a>7.3、大小设置方式</h2><ul>
<li>也可能导致OutOfMemoryError异常</li>
<li>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li>
<li>缺点<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li>直接内存大小可以通过MaxDirectMemorySize设置</li>
<li>如果不指定，默认与堆的最大值-Xmx参数值一致</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776347a25d01.webp" alt="image-20250102143849817"></p>
<p>简单理解：<br><strong>java process memory = java heap + native memory</strong></p>
<h2 id="7-4、代码举例"><a href="#7-4、代码举例" class="headerlink" title="7.4、代码举例"></a>7.4、代码举例</h2><p>如果不指定MaxDirectMemorySize，则默认与java堆最大值（-Xmx指定）一致。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:MaxDirectMemorySize=10m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 上午 12:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemTest</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException {</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe)unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="8、StringTable"><a href="#8、StringTable" class="headerlink" title="8、StringTable"></a>8、StringTable</h1><blockquote>
<p>面试题：new string()是放在哪里，还放在哪里？（搜狐、万达集团）</p>
</blockquote>
<h2 id="8-1、String的不可变性"><a href="#8-1、String的不可变性" class="headerlink" title="8.1、String的不可变性"></a>8.1、String的不可变性</h2><ol>
<li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li>
<li>字符串常量池中是不会存储相同内容的字符串的。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"abc"</span>;<span class="comment">//字面量的定义方式</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"abc"</span>;</span><br><span class="line">    s1 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//比较s1和s2的地址值</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s1);<span class="comment">//hello</span></span><br><span class="line">    System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*****************"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">"abc"</span>;</span><br><span class="line">    s3 += <span class="string">"def"</span>;</span><br><span class="line">    System.out.println(s3);<span class="comment">//abcdef</span></span><br><span class="line">    System.out.println(s2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*****************"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"abc"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4.replace(<span class="string">'a'</span>, <span class="string">'m'</span>);</span><br><span class="line">    System.out.println(s4);<span class="comment">//abc</span></span><br><span class="line">    System.out.println(s5);<span class="comment">//mbc</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">StringTest1</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest1</span>();</span><br><span class="line">    ex.change(ex.str, ex.ch);</span><br><span class="line">    System.out.print(ex.str + <span class="string">" and "</span>);<span class="comment">//</span></span><br><span class="line">    System.out.println(ex.ch);</span><br><span class="line">}</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"good"</span>);</span><br><span class="line"><span class="type">char</span>[] ch = { <span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> {</span><br><span class="line">    str = <span class="string">"test ok"</span>;</span><br><span class="line">    ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-2、String的内存分配"><a href="#8-2、String的内存分配" class="headerlink" title="8.2、String的内存分配"></a>8.2、String的内存分配</h2><p>整体来说：</p>
<ul>
<li>Java 6及以前，字符串常量池存放在永久代。</li>
<li>Java 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，<strong>即将字符串常量池的位置调整到Java堆内</strong>。</li>
<li>Java 8 中，字符串常量仍然在堆。</li>
</ul>
<p><strong>StringTable为什么要调整？</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html#jdk7changes">https://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html#jdk7changes</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776357ad4c72.webp" alt="image-20250102144307042"></p>
</blockquote>
<p><strong>举例：</strong></p>
<p>jdk6:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/6776359b60257.webp" alt="image-20250102144339629"></p>
<p>jdk8:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677635ad53f7d.webp" alt="image-20250102144357486"></p>
<p><strong>具体细节：数组+链表</strong><br>String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。</p>
<p>在 jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，StringTable的长度可以通过一个参数指定：</p>
<ul>
<li>-XX:StringTableSize=99991</li>
</ul>
<h2 id="8-3、String的基本操作"><a href="#8-3、String的基本操作" class="headerlink" title="8.3、String的基本操作"></a>8.3、String的基本操作</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest3</span> {</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>{</span><br><span class="line">        System.out.println();<span class="comment">//2320</span></span><br><span class="line">        System.out.println();<span class="comment">//2321</span></span><br><span class="line">        System.out.println();<span class="comment">//2321</span></span><br><span class="line">        System.out.println(<span class="string">"1"</span>);<span class="comment">//2321</span></span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"5"</span>);</span><br><span class="line">        System.out.println(<span class="string">"6"</span>);</span><br><span class="line">        System.out.println(<span class="string">"7"</span>);</span><br><span class="line">        System.out.println(<span class="string">"8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"9"</span>);</span><br><span class="line">        System.out.println(<span class="string">"10"</span>);<span class="comment">//2330</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"1"</span>);<span class="comment">//2331</span></span><br><span class="line">        System.out.println(<span class="string">"2"</span>);<span class="comment">//2331</span></span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"5"</span>);</span><br><span class="line">        System.out.println(<span class="string">"6"</span>);</span><br><span class="line">        System.out.println(<span class="string">"7"</span>);</span><br><span class="line">        System.out.println(<span class="string">"8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"9"</span>);</span><br><span class="line">        System.out.println(<span class="string">"10"</span>);<span class="comment">//2331</span></span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;<span class="comment">//常量优化机制,编译的时候就已经是abc</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = "abc";</span></span><br><span class="line"><span class="comment">         * String s2 = "abc"</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-4、字符串拼接操作"><a href="#8-4、字符串拼接操作" class="headerlink" title="8.4、字符串拼接操作"></a>8.4、字符串拼接操作</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"b"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//new StringBuilder().append("a").append("b").toString() --&gt; new String("ab")</span></span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"b"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//体会执行效率：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++){</span><br><span class="line">        src = src + <span class="string">"a"</span>;<span class="comment">//每次循环都会创建一个StringBuilder</span></span><br><span class="line">    }</span><br><span class="line">    System.out.println(src);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        src.append(<span class="string">"a"</span>);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    System.out.println(src);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-5、new-String-问题"><a href="#8-5、new-String-问题" class="headerlink" title="8.5、new String()问题"></a>8.5、new String()问题</h2><p>String的实例化方式： </p>
<ul>
<li><p>方式一：通过字面量定义的方式</p>
</li>
<li><p>方式二：通过new + 构造器的方式</p>
</li>
<li><p>面试题：String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？</p>
<p>两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p>
</li>
</ul>
<h2 id="8-6、intern-方法"><a href="#8-6、intern-方法" class="headerlink" title="8.6、intern()方法"></a>8.6、intern()方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest4</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">        s.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"1"</span>;</span><br><span class="line">        System.out.println(s == s2);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">        s3.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"11"</span>;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>jdk6中的解释：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/67763673e3b81.webp" alt="image-20250102144715964"></p>
<p>jdk7中的解释：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677636831ebc9.webp" alt="image-20250102144731235"></p>
<p>题目变形：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"1"</span>;</span><br><span class="line">    s.intern();</span><br><span class="line">    System.out.println(s == s2);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"11"</span>;</span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/02/677636a3e6ef1.webp" alt="image-20250102144804062"></p>
<h2 id="8-7、G1的String去重操作"><a href="#8-7、G1的String去重操作" class="headerlink" title="8.7、G1的String去重操作"></a>8.7、G1的String去重操作</h2><p><strong>问题：String底层是什么结构？</strong></p>
<p>新的需求：</p>
<p>许多大规模的java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：string1.equals(string2)为true。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</p>
<p><strong>说明：</strong><br><strong>String去重不需要对jdk的类库和已经存在的java代码做任何的改动。</strong></p>
</div></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">時光</div><div class="post-copyright__author_desc">心寄朗朗乾坤，胸怀真修之道。</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.shiguang666.eu.org/2024/12/20/fddf53a80c95/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.shiguang666.eu.org/2024/12/20/fddf53a80c95/')">【尚硅谷】JVM-运行时内存篇</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.shiguang666.eu.org/2024/12/20/fddf53a80c95/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=【尚硅谷】JVM-运行时内存篇&amp;url=https://blog.shiguang666.eu.org/2024/12/20/fddf53a80c95/&amp;pic=https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.shiguang666.eu.org" target="_blank">時光</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java<span class="tagsPageCount">35</span></a><a class="post-meta__box__tags" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>尚硅谷<span class="tagsPageCount">46</span></a><a class="post-meta__box__tags" href="/tags/JVM/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JVM<span class="tagsPageCount">6</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img.shiguangdev.cn/i/2025/01/27/67979724772cb.webp" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/19/e500390e9a1c/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/19/67641af764140.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Hexo】安知鱼主题添加文章统计页面</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/20/faa89baba309/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/67655fe410474.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ChatGPT 桌面版免费发布：体验多种应用交互模式！</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/01/03/0774b72a23d9/" title="【尚硅谷】JVM-垃圾回收篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-03</div><div class="title">【尚硅谷】JVM-垃圾回收篇</div></div></a></div><div><a href="/2025/01/03/2f12d193da4e/" title="【尚硅谷】JVM-对象内存布局篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-03</div><div class="title">【尚硅谷】JVM-对象内存布局篇</div></div></a></div><div><a href="/2025/01/03/7e4937efeeff/" title="【尚硅谷】JVM-执行引擎篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-03</div><div class="title">【尚硅谷】JVM-执行引擎篇</div></div></a></div><div><a href="/2024/12/11/0a6035f3745c/" title="【尚硅谷】JVM-字节码篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-11</div><div class="title">【尚硅谷】JVM-字节码篇</div></div></a></div><div><a href="/2024/12/12/60bae9f9d9cc/" title="【尚硅谷】JVM-类的加载篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-12</div><div class="title">【尚硅谷】JVM-类的加载篇</div></div></a></div><div><a href="/2024/09/17/56a6db38519d/" title="【尚硅谷】JAVA基础-IO流"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-17</div><div class="title">【尚硅谷】JAVA基础-IO流</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display: none">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__description">代码成就万事基积沙镇海,<br>梦想永在凌云意意气风发。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">時光</h1><div class="author-info__desc">心寄朗朗乾坤，胸怀真修之道。</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/shiguang-coding" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content"><span>🌟欢迎光临時光的博客园子🌟</span><br> <span><a target="_blank" rel="noopener" href="https://blog.shiguangdev.cn"><b>blog.shiguangdev.cn</b></a></span><br> <span><a target="_blank" rel="noopener" href="https://blog.shiguang88.icu"><b>blog.shiguang88.icu</b></a></span><br> <span><a href="https://blog.shiguang666.eu.org"><b>blog.shiguang666.eu.org</b></a></span><br> <span>🤔 如有问题欢迎评论区交流！</span><br> <span>📧 如需联系我：<a href="mailto:an_shiguang@163.com"><b>发送邮件🚀</b></a></span> <div id="welcome-info"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">1、说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">2、程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%83%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、为什么需要它？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E6%A1%88%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">2.3.</span> <span class="toc-text">2.3、基本特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">2.4、两个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1%E3%80%81PC%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E5%82%A8%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1、PC寄存器存储字节码指令地址有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2%E3%80%81PC%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%AB%E8%AE%BE%E5%AE%9A%E4%B8%BA%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2、PC寄存器为什么被设定为线程私有的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text">3、虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E3%80%81%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%A0%88%E7%AE%A1%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%A0%86%E7%AE%A1%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1、如何理解栈管运行，堆管存储？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E3%80%81%E6%A0%88%E5%AD%98%E5%9C%A8GC%E5%90%97"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2、栈存在GC吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3%E3%80%81%E5%8F%AF%E8%83%BD%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3、可能抛出的异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%A0%88%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4、如何设置栈内存大小？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E6%A0%88%E7%9A%84%E5%8D%95%E4%BD%8D%EF%BC%9A%E6%A0%88%E5%B8%A7%EF%BC%88Stack-Frame%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">3.2、栈的单位：栈帧（Stack Frame）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%A0%88%E5%B8%A7%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1、方法和栈帧的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E3%80%81%E6%A0%88%E7%9A%84FILO%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2、栈的FILO原理?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81%E6%A0%88%E6%A1%A2%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">3.3、栈桢内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%88local-variables"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1、局部变量表（local variables)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1%E3%80%81%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">3.3.1.1、存在线程安全问题吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-2%E3%80%81%E5%85%B3%E4%BA%8ESlot%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">3.3.1.2、关于Slot的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-3%E3%80%81Slot%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9F"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">3.3.1.3、Slot的重复利用举例？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-4%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">3.3.1.4、静态变量与局部变量的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-5%E3%80%81%E4%B8%8EGC-Roots%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.1.5.</span> <span class="toc-text">3.3.1.5、与GC Roots的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88Operand-Stack%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2、操作数栈（Operand Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">3.3.2.1、概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-2%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">3.3.2.2、代码演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-3%E3%80%81%E4%BD%95%E4%B8%BA%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">3.3.2.3、何为栈顶缓存技术？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3、动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%91%A2%EF%BC%9F"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">3.3.3.1、为什么需要常量池呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-2%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">3.3.3.2、方法的调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4%E3%80%81%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.3.4、方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-5%E3%80%81%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.3.5、一些附加信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93%E4%B8%8E%E6%8B%93%E5%B1%95"><span class="toc-number">3.4.</span> <span class="toc-text">3.4、问题小结与拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.4.1.</span> <span class="toc-text">问题一：栈溢出的情况?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E8%B0%83%E6%95%B4%E6%A0%88%E5%A4%A7%E5%B0%8F-%E5%B0%B1%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%8D%E5%87%BA%E7%8E%B0%E6%BA%A2%E5%87%BA%E5%90%97"><span class="toc-number">3.4.2.</span> <span class="toc-text">问题二：调整栈大小,就能保证不出现溢出吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89%EF%BC%9A%E5%88%86%E9%85%8D%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E5%90%97"><span class="toc-number">3.4.3.</span> <span class="toc-text">问题三：分配的栈内存越大越好吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9B%9B%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E5%90%A6%E4%BC%9A%E6%B6%89%E5%8F%8A%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">3.4.4.</span> <span class="toc-text">问题四：垃圾回收是否会涉及到虚拟机栈?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%94%EF%BC%9A%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">3.4.5.</span> <span class="toc-text">问题五：方法中定义的局部变量是否线程安全?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">4、本地方法接口与本地方法栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">4.1、什么是本地方法?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Native-Method%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2、为什么要使用Native Method？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%8E%B0%E7%8A%B6"><span class="toc-number">4.3.</span> <span class="toc-text">4.3、本地方法现状?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">4.4.</span> <span class="toc-text">4.4、本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E5%A0%86"><span class="toc-number">5.</span> <span class="toc-text">5、堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">5.1、核心概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1%E3%80%81%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%88%86%E9%85%8D%E5%9C%A8%E5%A0%86%E4%B8%8A%EF%BC%9F"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1、对象都分配在堆上？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2%E3%80%81%E6%89%80%E6%9C%89%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%83%BD%E5%85%B1%E4%BA%AB%E5%A0%86%EF%BC%9F"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.2.2、所有的线程都共享堆？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E5%A0%86%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">5.2、堆的内部结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">5.3、如何设置堆内存大小？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3%E6%AF%94%E4%BE%8B%EF%BC%9F"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1、如何设置新生代与老年代比例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEEden%E3%80%81%E5%B9%B8%E5%AD%98%E8%80%85%E5%8C%BA%E6%AF%94%E4%BE%8B%EF%BC%9F"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2、如何设置Eden、幸存者区比例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3%E3%80%81OOM%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3、OOM举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4%E3%80%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%B0%8F%E7%BB%93"><span class="toc-number">5.3.4.</span> <span class="toc-text">5.3.4、参数设置小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Xms-Xmx"><span class="toc-number">5.3.4.1.</span> <span class="toc-text">-Xms -Xmx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xmn"><span class="toc-number">5.3.4.2.</span> <span class="toc-text">-Xmn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-NewRatio"><span class="toc-number">5.3.4.3.</span> <span class="toc-text">-XX:NewRatio</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-SurvivorRatio"><span class="toc-number">5.3.4.4.</span> <span class="toc-text">-XX:SurvivorRatio</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-MaxTenuringThreshold"><span class="toc-number">5.3.4.5.</span> <span class="toc-text">-XX:MaxTenuringThreshold</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-PrintGCDetails"><span class="toc-number">5.3.4.6.</span> <span class="toc-text">-XX:+PrintGCDetails</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-HandlePromotionFailure"><span class="toc-number">5.3.4.7.</span> <span class="toc-text">-XX:HandlePromotionFailure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-PrintFlagsFinal"><span class="toc-number">5.3.4.8.</span> <span class="toc-text">-XX:+PrintFlagsFinal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E9%87%91%E5%8F%A5"><span class="toc-number">5.4.</span> <span class="toc-text">5.4、对象分配金句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1%E3%80%81%E8%BF%87%E7%A8%8B%E5%89%96%E6%9E%90"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1、过程剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2、内存分配原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3%E3%80%81%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3、代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E3%80%81%E8%A7%A3%E9%87%8AMinorGC%E3%80%81MajorGC%E3%80%81FullGC"><span class="toc-number">5.5.</span> <span class="toc-text">5.5、解释MinorGC、MajorGC、FullGC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1%E3%80%81MinorGC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1、MinorGC触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2%E3%80%81MajorGC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2、MajorGC触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3%E3%80%81FullGC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.3.</span> <span class="toc-text">5.5.3、FullGC触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-4%E3%80%81%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.5.4.</span> <span class="toc-text">5.5.4、代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6%E3%80%81OOM%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">5.6.</span> <span class="toc-text">5.6、OOM如何解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7%E3%80%81%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="toc-number">5.7.</span> <span class="toc-text">5.7、堆空间分代思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-5%E3%80%81%E5%BF%AB%E9%80%9F%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%9ATLAB"><span class="toc-number">5.7.1.</span> <span class="toc-text">5.5.5、快速分配策略：TLAB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">6.</span> <span class="toc-text">6、方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.</span> <span class="toc-text">6.1、栈、堆、方法区的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">6.2、方法区在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.3.</span> <span class="toc-text">6.3、方法区的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4%E3%80%81HotSpot%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">6.4.</span> <span class="toc-text">6.4、HotSpot中方法区的演进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">6.5、方法区常用参数有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E9%83%BD%E5%AD%98%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">6.6、方法区都存什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1%E3%80%81%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">6.6.1.</span> <span class="toc-text">6.6.1、类型信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2%E3%80%81%E5%9F%9F-Field-%E4%BF%A1%E6%81%AF"><span class="toc-number">6.6.2.</span> <span class="toc-text">6.6.2、域(Field)信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3%E3%80%81%E6%96%B9%E6%B3%95-Method-%E4%BF%A1%E6%81%AF"><span class="toc-number">6.6.3.</span> <span class="toc-text">6.6.3、方法(Method)信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-4%E3%80%81non-final%E7%9A%84%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">6.6.4.</span> <span class="toc-text">6.6.4、non-final的类变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-5%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">6.6.5.</span> <span class="toc-text">6.6.5、运行时常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-5-1%E3%80%81%E5%85%B3%E8%81%94%EF%BC%9A%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">6.6.5.1.</span> <span class="toc-text">6.6.5.1、关联：常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-5-2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-number">6.6.5.2.</span> <span class="toc-text">6.6.5.2、为什么需要常量池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-5-3%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.6.5.3.</span> <span class="toc-text">6.6.5.3、常量池都有什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">6.7.</span> <span class="toc-text">6.7、方法区使用举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%8E%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-number">6.8.</span> <span class="toc-text">6.8、永久代与元空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8GC%EF%BC%9F%E5%9B%9E%E6%94%B6%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.9.</span> <span class="toc-text">6.9、方法区是否存在GC？回收什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%B0%8F%E7%BB%93"><span class="toc-number">6.10.</span> <span class="toc-text">6.10、内存结构小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">7.</span> <span class="toc-text">7、直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">7.1.</span> <span class="toc-text">7.1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BAvs%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">7.2.</span> <span class="toc-text">7.2、非直接缓冲区vs直接缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">7.3、大小设置方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E3%80%81%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">7.4.</span> <span class="toc-text">7.4、代码举例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81StringTable"><span class="toc-number">8.</span> <span class="toc-text">8、StringTable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E3%80%81String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">8.1.</span> <span class="toc-text">8.1、String的不可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E3%80%81String%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">8.2.</span> <span class="toc-text">8.2、String的内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3%E3%80%81String%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">8.3.</span> <span class="toc-text">8.3、String的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">8.4.</span> <span class="toc-text">8.4、字符串拼接操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5%E3%80%81new-String-%E9%97%AE%E9%A2%98"><span class="toc-number">8.5.</span> <span class="toc-text">8.5、new String()问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6%E3%80%81intern-%E6%96%B9%E6%B3%95"><span class="toc-number">8.6.</span> <span class="toc-text">8.6、intern()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7%E3%80%81G1%E7%9A%84String%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">8.7.</span> <span class="toc-text">8.7、G1的String去重操作</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/27/ee0479b506ca/" title="【Hexo】给网站添加春节灯笼挂件"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2025/01/27/67979724772cb.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Hexo】给网站添加春节灯笼挂件"></a><div class="content"><a class="title" href="/2025/01/27/ee0479b506ca/" title="【Hexo】给网站添加春节灯笼挂件">【Hexo】给网站添加春节灯笼挂件</a><time datetime="2025-01-27T14:05:40.000Z" title="发表于 2025-01-27 22:05:40">2025-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/0774b72a23d9/" title="【尚硅谷】JVM-垃圾回收篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【尚硅谷】JVM-垃圾回收篇"></a><div class="content"><a class="title" href="/2025/01/03/0774b72a23d9/" title="【尚硅谷】JVM-垃圾回收篇">【尚硅谷】JVM-垃圾回收篇</a><time datetime="2025-01-03T08:15:25.000Z" title="发表于 2025-01-03 16:15:25">2025-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/7e4937efeeff/" title="【尚硅谷】JVM-执行引擎篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【尚硅谷】JVM-执行引擎篇"></a><div class="content"><a class="title" href="/2025/01/03/7e4937efeeff/" title="【尚硅谷】JVM-执行引擎篇">【尚硅谷】JVM-执行引擎篇</a><time datetime="2025-01-03T06:50:22.000Z" title="发表于 2025-01-03 14:50:22">2025-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/2f12d193da4e/" title="【尚硅谷】JVM-对象内存布局篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/08/28/66cedaf5d014a.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【尚硅谷】JVM-对象内存布局篇"></a><div class="content"><a class="title" href="/2025/01/03/2f12d193da4e/" title="【尚硅谷】JVM-对象内存布局篇">【尚硅谷】JVM-对象内存布局篇</a><time datetime="2025-01-03T05:35:33.000Z" title="发表于 2025-01-03 13:35:33">2025-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/20/faa89baba309/" title="ChatGPT 桌面版免费发布：体验多种应用交互模式！"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/i/2024/12/20/67655fe410474.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ChatGPT 桌面版免费发布：体验多种应用交互模式！"></a><div class="content"><a class="title" href="/2024/12/20/faa89baba309/" title="ChatGPT 桌面版免费发布：体验多种应用交互模式！">ChatGPT 桌面版免费发布：体验多种应用交互模式！</a><time datetime="2024-12-20T12:12:05.000Z" title="发表于 2024-12-20 20:12:05">2024-12-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/shiguang-coding" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" href="mailto:an_shiguang@163.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" size="50px"><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html">开往</a><a class="footer-item" title="异次元之旅" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on">异次元之旅</a><a class="footer-item" title="列表导航" target="_blank" rel="noopener" href="https://zhblogs.ohyee.cc/">列表导航</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a></div></div><div class="footer-group"><div class="footer-title">文章</div><div class="footer-links"><a class="footer-item" title="归档" href="/archives/">归档</a><a class="footer-item" title="分类" href="/categories/">分类</a><a class="footer-item" title="标签" href="/tags/">标签</a><a class="footer-item" title="RSS" href="/tom.xml">RSS</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="留言板" href="/comment/">留言板</a><a class="footer-item" title="关于我" href="/about/">关于我</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"></a><a class="github-badge" target="_blank" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=blog.shiguangdev.cn" style="margin-inline:5px" data-title="萌ICP备20246006号" title="萌ICP备20246006号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/%E8%90%8Cicp%E5%A4%87-20246006%E5%8F%B7-FF1485" alt="萌ICP备20246006号"></a><a class="github-badge" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">©2023 - 2025 By <a class="footer-bar-link" href="/" title="時光" target="_blank">時光</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = []
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://img.shiguangdev.cn/" title="图床">图床</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="豫ICP备2024070732号">豫ICP备2024070732号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">188</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">17</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.shiguang666.eu.org" title="時光主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="時光主页"><span class="back-menu-item-text">時光主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://nav.shiguang666.eu.org" title="時光导航站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://nav.shiguang666.eu.org/images/logo-collapsed@2x.png" alt="時光导航站"><span class="back-menu-item-text">時光导航站</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://love.shiguang666.eu.org" title="表白生成器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://love.shiguang666.eu.org/favicon.ico" alt="表白生成器"><span class="back-menu-item-text">表白生成器</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://publish.shiguang666.eu.org/" title="時光站点发布页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/homepage.png" alt="時光站点发布页"><span class="back-menu-item-text">時光站点发布页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://release.shiguang666.eu.org/" title="地址发布页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/homepage.png" alt="地址发布页"><span class="back-menu-item-text">地址发布页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://qq.shiguang666.eu.org/" title="時光的QQ"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/qqavatar.jpg" alt="時光的QQ"><span class="back-menu-item-text">時光的QQ</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://game.shiguang666.eu.org" title="怀旧游戏机"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/chat.png" alt="怀旧游戏机"><span class="back-menu-item-text">怀旧游戏机</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://games.shiguang666.eu.org" title="H5小游戏合集"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://echeverra.cn/wp-content/uploads/2021/06/cropped-thmub-32x32.jpg" alt="H5小游戏合集"><span class="back-menu-item-text">H5小游戏合集</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">后台管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://umami.shiguangdev.cn/share/1CY8KW6pqM0UBUIL/blog.shiguangdev.cn" title="访客统计"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://umami.shiguangdev.cn/favicon.ico" alt="访客统计"><span class="back-menu-item-text">访客统计</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://img.shiguangdev.cn/" title="時光图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shiguangdev.cn/favicon.ico" alt="時光图床"><span class="back-menu-item-text">時光图床</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.shiguang666.eu.org/" title="Qexo"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://unpkg.com/qexo-static@2.2.3/qexo/images/icon.png" alt="Qexo"><span class="back-menu-item-text">Qexo</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="fa fa-line-chart faa-tada"></i><span> 统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随机</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/news/"><i class="fa fa-newspaper faa-tada"></i><span> 早报亭</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=10051718332&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/xjj/"><i class="fa fa-rocket faa-tada"></i><span> 养生堂</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comment/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>10</sup></a><a href="/tags/Alist/" style="font-size: 0.88rem;">Alist<sup>3</sup></a><a href="/tags/CentOS/" style="font-size: 0.88rem;">CentOS<sup>1</sup></a><a href="/tags/ChatGPT/" style="font-size: 0.88rem;">ChatGPT<sup>14</sup></a><a href="/tags/ChatGPt/" style="font-size: 0.88rem;">ChatGPt<sup>1</sup></a><a href="/tags/Chrome/" style="font-size: 0.88rem;">Chrome<sup>1</sup></a><a href="/tags/CloudFlare/" style="font-size: 0.88rem;">CloudFlare<sup>3</sup></a><a href="/tags/DNS/" style="font-size: 0.88rem;">DNS<sup>1</sup></a><a href="/tags/Ecology/" style="font-size: 0.88rem;">Ecology<sup>1</sup></a><a href="/tags/GPT-4o/" style="font-size: 0.88rem;">GPT-4o<sup>2</sup></a><a href="/tags/Gemini/" style="font-size: 0.88rem;">Gemini<sup>2</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>8</sup></a><a href="/tags/GitHub/" style="font-size: 0.88rem;">GitHub<sup>6</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>26</sup></a><a href="/tags/IDEA/" style="font-size: 0.88rem;">IDEA<sup>3</sup></a><a href="/tags/KeyBoardTestUtility/" style="font-size: 0.88rem;">KeyBoardTestUtility<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>4</sup></a><a href="/tags/Lombok/" style="font-size: 0.88rem;">Lombok<sup>1</sup></a><a href="/tags/Markdown/" style="font-size: 0.88rem;">Markdown<sup>2</sup></a><a href="/tags/MindManager/" style="font-size: 0.88rem;">MindManager<sup>1</sup></a><a href="/tags/Mysql/" style="font-size: 0.88rem;">Mysql<sup>2</sup></a><a href="/tags/Perplexity-AI/" style="font-size: 0.88rem;">Perplexity AI<sup>1</sup></a><a href="/tags/PicGo/" style="font-size: 0.88rem;">PicGo<sup>1</sup></a><a href="/tags/QQ/" style="font-size: 0.88rem;">QQ<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem;">SQL<sup>12</sup></a><a href="/tags/SSL/" style="font-size: 0.88rem;">SSL<sup>3</sup></a><a href="/tags/Sqlserver/" style="font-size: 0.88rem;">Sqlserver<sup>1</sup></a><a href="/tags/Typora/" style="font-size: 0.88rem;">Typora<sup>5</sup></a><a href="/tags/drawio/" style="font-size: 0.88rem;">drawio<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/svn/" style="font-size: 0.88rem;">svn<sup>2</sup></a><a href="/tags/%E5%9B%BE%E5%90%A7%E5%B7%A5%E5%85%B7%E7%AE%B1/" style="font-size: 0.88rem;">图吧工具箱<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">图床<sup>7</sup></a><a href="/tags/%E5%BC%80%E6%BA%90%E5%88%86%E4%BA%AB/" style="font-size: 0.88rem;">开源分享<sup>6</sup></a><a href="/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/" style="font-size: 0.88rem;">搜索引擎<sup>2</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/" style="font-size: 0.88rem;">数据恢复<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">模板<sup>4</sup></a><a href="/tags/%E8%B8%A9%E5%9D%91/" style="font-size: 0.88rem;">踩坑<sup>6</sup></a><a href="/tags/%E9%B1%BC%E7%9A%AE/" style="font-size: 0.88rem;">鱼皮<sup>11</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="10051718332" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/my/m/music/playlist?id=10051718332&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async="" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("05/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 時光 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async="" src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.shiguangdev.eu.org',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.shiguangdev.eu.org',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async="" src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.shiguangdev.eu.org',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async="" data-pjax="" src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/custom/footer-animal.js" defer=""></script><script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.9.0-rc.1/echarts.min.js"></script><script src="/api/denglong.js?text=新年快乐"> </script><script id="click-heart" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><!-- hexo injector body_end start -->
  <script data-pjax="" src="/js/hexo_githubcalendar.js"></script>
  <script data-pjax="">
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://githubcalendarapi.shiguang666.eu.org/api?user=shiguang-coding";
            var git_color =['#ebedf0', '#a2f7af', '#6ce480', '#54ad63', '#469252', '#31753c', '#1f5f2a', '#13531f', '#084111', '#032b09', '#000000'];
            var git_user ="shiguang-coding";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar");
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end -->
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = '75439fb77e5551eacf54f0df75565616dcf2ad';
        let tianliGPT_postSelector = '#article-container';
        let tianliGPT_Title = '文章摘要';
        let tianliGPT_postURL = '/^https?://[^/]+/[0-9]{4}/[0-9]{2}/[0-9]{2}/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '1000';
        let tianliGPT_typingAnimate = true;
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: true,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "PostChat",
          userDesc: "如果你对网站的内容有任何疑问，可以来问我哦～",
          addButton: true,
          beginningText: "这篇文章介绍了"
        };
    </script>
    <script data-postchat_key="75439fb77e5551eacf54f0df75565616dcf2ad" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>